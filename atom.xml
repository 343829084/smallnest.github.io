<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2015-09-15T04:38:30.349Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在@Value注解中为String类型的字段设置null值]]></title>
    <link href="http://colobu.com/2015/09/09/set-null-for-a-string-property-by-Value/"/>
    <id>http://colobu.com/2015/09/09/set-null-for-a-string-property-by-Value/</id>
    <published>2015-09-09T06:36:34.000Z</published>
    <updated>2015-09-09T07:17:50.141Z</updated>
    <content type="html"><![CDATA[<p>在Spring中可以使用<code>@Value</code>为<code>field</code>、<code>method</code>、<code>method/constructor</code>的参数设置缺省值。<br>但是，如果如何为一个字符串类型的字段设置null值呢？<br>下面的方法统统不对：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   <span class="annotation">@Value</span>(<span class="string">"${app.name1:}"</span>)</div><div class="line">   <span class="keyword">private</span> String name1;</div><div class="line">   </div><div class="line"><span class="annotation">@Value</span>(<span class="string">"${app.name2:''}"</span>)</div><div class="line">   <span class="keyword">private</span> String name2;</div><div class="line">   </div><div class="line"><span class="annotation">@Value</span>(<span class="string">"${app.name3:null}"</span>)</div><div class="line"><span class="keyword">private</span> String name3;</div></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="@Value">@Value</h3>
<p>我们先来看看<code>@Value</code>注解的使用方法。它主要用来为 <em>字段</em> 或者 <em>方法</em>/<em>构造函数</em>的参数 注入值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static class FieldValueTestBean</div><div class="line"></div><div class="line">    @Value("#{ systemProperties[''user.region''] ?: 'zh_CN'" }")</div><div class="line">    private String defaultLocale;</div><div class="line">	</div><div class="line">	@Value("${user.name}")</div><div class="line">    private String userName;</div><div class="line"></div><div class="line">    public void setDefaultLocale(String defaultLocale) {</div><div class="line">        this.defaultLocale = defaultLocale;</div><div class="line">    }</div><div class="line"></div><div class="line">    public String getDefaultLocale() {</div><div class="line">        return this.defaultLocale;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>还可以放在方法上:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span></span></div><div class="line"></div><div class="line">    <span class="title">private</span> <span class="title">String</span> <span class="title">defaultLocale</span>;</div><div class="line"></div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"#{ systemProperties[''user.region''] }"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span>(String defaultLocale) {</div><div class="line">        <span class="keyword">this</span>.defaultLocale = defaultLocale;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String <span class="title">getDefaultLocale</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至构造函数上:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MovieRecommender {</div><div class="line"></div><div class="line">    private String defaultLocale;</div><div class="line"></div><div class="line">    private CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,</div><div class="line">            @Value("#{systemProperties[''user.country'']}") String defaultLocale) {</div><div class="line">        this.customerPreferenceDao = customerPreferenceDao;</div><div class="line">        this.defaultLocale = defaultLocale;</div><div class="line">    }</div><div class="line"></div><div class="line">    // ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它支持两种表达方式：</p>
<ul>
<li>PlaceHolder方式。 默认使用 <code>${...}</code>方式,大括号内的placeholder。</li>
<li>Spring Expression Language方式。 格式为<code>#{...}</code>, 括号内的Spring EL表达式。 具体参考可以查看 <a href="http://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/htmlsingle/#expressions-language-ref" target="_blank" rel="external">Spring Language Reference</a></li>
</ul>
<h4 id="缺省值">缺省值</h4>
<p>如果没有placeholder或者表达式为空，我们可以提供一个缺省值。</p>
<ol>
<li><strong>PlaceHolder方式</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$<span class="rules">{<span class="rule"><span class="attribute">property</span>:<span class="value">default value</span></span></span>}</div></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Value</span>(<span class="string">"${mongodb.url:127.0.0.1}"</span>)</div><div class="line"><span class="keyword">private</span> String mongodbUrl;</div><div class="line"></div><div class="line"><span class="annotation">@Value</span>(<span class="string">"#{'${mongodb.url:172.0.0.1}'}"</span>) <span class="comment">//混合模式</span></div><div class="line"><span class="keyword">private</span> String mongodbUrl;</div><div class="line"></div><div class="line"><span class="annotation">@Value</span>(<span class="string">"#{config['mongodb.url']?:'127.0.0.1'}"</span>) <span class="comment">//混合模式+缺省值</span></div><div class="line"><span class="keyword">private</span> String mongodbUrl;</div></pre></td></tr></table></figure>

<p><em>本例子摘自: <a href="http://www.mkyong.com/spring3/spring-value-default-value/" target="_blank" rel="external">mkyong</a></em></p>
<ol>
<li>Spring EL方式</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#{<span class="ruby"><span class="symbol">expression?:</span>default value}</span></div></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Value</span>(<span class="string">"#{systemProperties['zookeeper.url'] ?: localhost:2181}"</span>)</div><div class="line"><span class="keyword">private</span> String zookeeperUrl;</div><div class="line"></div><div class="line"><span class="annotation">@Value</span>(<span class="string">"#{config['mongodb.url'] ?: '127.0.0.1:27017'}"</span>) </div><div class="line"><span class="keyword">private</span> String mongodbUrl;	</div><div class="line"></div><div class="line"><span class="annotation">@Value</span>(<span class="string">"#{user.age ?: 18}"</span>)</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</div></pre></td></tr></table></figure>

<h3 id="字符串null">字符串null</h3>
<p>如果配置的属性，我们希望设置一个null的缺省值，改怎么做呢？<br>两种方式：</p>
<ol>
<li>Spring EL方式</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Value</span>(<span class="string">"${app.name:#{null}}"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>

<ol>
<li>PlaceHolder方式<br>这种方式需要为<code>PlaceholderConfigurerSupport</code>或它的子类设置属性<code>nullValue</code>， 比如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">placeholderConfigurer.setNullValue(<span class="string">"@null"</span>);</div></pre></td></tr></table></figure>

<p>这样字符串<code>@null</code>就代表null对象。<br>你可以</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Value</span>(<span class="string">"${app.name:@null}"</span>)</div><div class="line"> <span class="keyword">private</span> String name;</div></pre></td></tr></table></figure>

<p>也可以在属性文件中设置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.<span class="variable">name=</span>@<span class="constant">null</span></div></pre></td></tr></table></figure>

<h3 id="完整的测试代码">完整的测试代码</h3>
<ul>
<li>App.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.colobu.spring;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line"></div><div class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</div><div class="line"></div><div class="line">        HelloService service = (HelloService)ctx.getBean(<span class="string">"helloService"</span>);</div><div class="line">        service.test();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>AppConfig.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.colobu.spring;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer;</div><div class="line"></div><div class="line"><span class="annotation">@PropertySource</span>(<span class="string">"classpath:/application.properties"</span>)</div><div class="line"><span class="annotation">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>{</div><div class="line"></div><div class="line"></div><div class="line">    <span class="annotation">@Bean</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  PropertySourcesPlaceholderConfigurer <span class="title">propertySourcesPlaceholderConfigurer</span>() <span class="keyword">throws</span> Exception {</div><div class="line">        PropertySourcesPlaceholderConfigurer placeholderConfigurer = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</div><div class="line">        placeholderConfigurer.setNullValue(<span class="string">"@null"</span>);</div><div class="line">        <span class="keyword">return</span> placeholderConfigurer;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>HelloService.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.colobu.spring;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</div><div class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</div><div class="line"></div><div class="line"><span class="annotation">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>{</div><div class="line"></div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.count}"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name1:abcd}"</span>)</div><div class="line">    <span class="keyword">private</span> String name1;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name2:`abcd`}"</span>)</div><div class="line">    <span class="keyword">private</span> String name2;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name3}"</span>)</div><div class="line">    <span class="keyword">private</span> String name3;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.enable}"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> appEnable;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name4:}"</span>)</div><div class="line">    <span class="keyword">private</span> String name4;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name5:''}"</span>)</div><div class="line">    <span class="keyword">private</span> String name5;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name6:@null}"</span>)</div><div class="line">    <span class="keyword">private</span> String name6;</div><div class="line">    <span class="annotation">@Value</span>(<span class="string">"${app.name7:#{null}}"</span>)</div><div class="line">    <span class="keyword">private</span> String name7;</div><div class="line"></div><div class="line">    <span class="annotation">@PostConstruct</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>() {</div><div class="line">        System.out.println(<span class="string">"start"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(){</div><div class="line">        System.out.println(<span class="string">"num="</span> + num);</div><div class="line">        System.out.println(<span class="string">"appEnable="</span> + appEnable);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"name1="</span> + name1);</div><div class="line">        System.out.println(<span class="string">"name2="</span> + name2);</div><div class="line">        System.out.println(<span class="string">"name3 ="</span> + name3);</div><div class="line">        System.out.println(<span class="string">"name4 ="</span> + name4);</div><div class="line">        System.out.println(<span class="string">"name5 = "</span> + name5);</div><div class="line">        System.out.println(<span class="string">"name6 = "</span> + name6);</div><div class="line">        System.out.println(<span class="string">"name7 = "</span> + name7);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@PreDestroy</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span>(){</div><div class="line">        System.out.println(<span class="string">"stop"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>application.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attribute">xmlns:util</span>=<span class="value">"http://www.springframework.org/schema/util"</span></div><div class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></div><div class="line">				            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</div><div class="line">				            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"</div><div class="line">       <span class="attribute">default-autowire</span>=<span class="value">"byType"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="title">context:annotation-config</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.colobu.spring"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">util:properties</span> <span class="attribute">id</span>=<span class="value">"configProperties"</span> <span class="attribute">location</span>=<span class="value">"classpath:application.properties"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">context:property-placeholder</span> <span class="attribute">properties-ref</span>=<span class="value">"configProperties"</span> <span class="attribute">ignore-resource-not-found</span>=<span class="value">"true"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>application.properties</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.<span class="variable">count=</span><span class="number">0</span></div><div class="line">app.<span class="variable">name3=</span>@<span class="constant">null</span></div><div class="line">app.<span class="variable">enable=</span><span class="constant">false</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>在Spring中可以使用<code>@Value</code>为<code>field</code>、<code>method</code>、<code>method/constructor</code>的参数设置缺省值。<br>但是，如果如何为一个字符串类型的字段设置null值呢？<br>下面的方法统统不对：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   <span class="annotation">@Value</span>(<span class="string">"${app.name1:}"</span>)</div><div class="line">   <span class="keyword">private</span> String name1;</div><div class="line">   </div><div class="line"><span class="annotation">@Value</span>(<span class="string">"${app.name2:''}"</span>)</div><div class="line">   <span class="keyword">private</span> String name2;</div><div class="line">   </div><div class="line"><span class="annotation">@Value</span>(<span class="string">"${app.name3:null}"</span>)</div><div class="line"><span class="keyword">private</span> String name3;</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Spring" scheme="http://colobu.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何编写Go代码]]></title>
    <link href="http://colobu.com/2015/09/07/How-to-Write-Go-Code/"/>
    <id>http://colobu.com/2015/09/07/How-to-Write-Go-Code/</id>
    <published>2015-09-07T06:30:58.000Z</published>
    <updated>2015-09-07T07:56:03.324Z</updated>
    <content type="html"><![CDATA[<p>官方原文: <a href="https://golang.org/doc/code.html" target="_blank" rel="external">How to Write Go Code</a>,<br>根据最新官方文档翻译。翻译参考<a href="http://www.cnblogs.com/wang_yb/" target="_blank" rel="external">wang_yb</a>的<a href="http://www.cnblogs.com/wang_yb/p/4333331.html" target="_blank" rel="external">如何写 go 代码 </a>。<br>因为官方文档有更新，我根据新版本的文档重新进行了翻译。</p>
<p>本文演示如何开发一个简单的 go package, 以及 <a href="https://golang.org/cmd/go/" target="_blank" rel="external">go tool</a> 的使用方法,<br>即获取(fetch), 编译(build), 安装(install) go package 的标准方法和命令.</p>
<p><em>go</em> tool 需要你按照一定的标准来组织代码. 请仔细阅读本文.<br>它介绍了用来构建和运行 Go 程序的最简单方法.</p>
<p>介绍本文的视频参照: <a href="https://www.youtube.com/watch?v=XCsL89YtqCs。" target="_blank" rel="external">https://www.youtube.com/watch?v=XCsL89YtqCs。</a><br><a id="more"></a></p>
<h2 id="代码组织">代码组织</h2>
<h3 id="工作区Workspace">工作区Workspace</h3>
<p><em>go</em> tool 是设计用来和公共仓库的开源代码一起工作的.<br>即使你不需要发布你的代码, go tool 的工作模型也同样适用于你.</p>
<p>Go 代码必须保存在 <em>工作区</em> 中, 工作区 就是一个特定的目录结构, 根目录下有如下3个目录:</p>
<ul>
<li><em>src</em> 目录: 存放 go 源码文件, 按 package 来组织 (一个 package 一个文件夹)</li>
<li><em>pkg</em> 目录: 存放 package 对象</li>
<li><em>bin</em> 目录: 存放可执行的命令command</li>
</ul>
<p><em>go</em> tool 编译 <em>src</em> 下的文件, 并将编译好的二进制文件分别放入 <em>pkg</em> 或者 <em>bin</em> 文件夹中.<br><em>src</em> 目录可以包含多个 版本控制仓库(比如 Git 或 Mercurial), 用来管理代码的开发.</p>
<p>一个实际的工作区的目录结构如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                          # <span class="keyword">command</span> <span class="built_in">executable</span></div><div class="line">    outyet                         # <span class="keyword">command</span> <span class="built_in">executable</span></div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.<span class="keyword">com</span>/golang/example/</div><div class="line">            stringutil.<span class="keyword">a</span>           # package object</div><div class="line">src/</div><div class="line">    github.<span class="keyword">com</span>/golang/example/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	hello/</div><div class="line">	    hello.<span class="keyword">go</span>               # <span class="keyword">command</span> <span class="keyword">source</span></div><div class="line">	outyet/</div><div class="line">	    main.<span class="keyword">go</span>                # <span class="keyword">command</span> <span class="keyword">source</span></div><div class="line">	    main_test.<span class="keyword">go</span>           # test <span class="keyword">source</span></div><div class="line">	stringutil/</div><div class="line">	    <span class="built_in">reverse</span>.<span class="keyword">go</span>             # package <span class="keyword">source</span></div><div class="line">	    reverse_test.<span class="keyword">go</span>        # test <span class="keyword">source</span></div></pre></td></tr></table></figure>

<p>这个工作区包含一个仓库(<em>example</em>),由两个命令组成(<em>hello</em>和<em>outyet</em>)，以及一个库(<em>stringutil</em>)。</p>
<p>一个典型的工作区可能包含很多源码库，这些源码库包含着N多的<em>package</em>和<em>command</em>。大部分的Go程序员会将他们的源码和依赖放在一个单一的工作区中。</p>
<p>命令Command和库libraries由各种source package编译而来。我们稍后再介绍<a href="">它</a>。</p>
<h3 id="GOPATH_环境变量">GOPATH 环境变量</h3>
<p><code>GOPATH</code> 环境变量指向你的 <em>工作区</em> 的位置. 这是你开发 Go 代码时唯一需要设置的环境变量.</p>
<p>开始开发时, 创建 工作区 的文件夹, 并设置对应的 <code>GOPATH</code> 环境变量.<br>你的 工作区 可以是任意文件夹, 本文中使用的路径是 <code>$HOME/work</code><br>注意 不要把 <code>GOPATH</code> 设置为 go 的安装路径. (另一种常用设置方式是设置<code>GOPATH=$HOME</code>)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir <span class="variable">$HOME</span>/work</div><div class="line">$ <span class="keyword">export</span> GOPATH=<span class="variable">$HOME</span>/work</div></pre></td></tr></table></figure>

<p>为了方便编译出的命令的执行, 将上面的 bin 目录加入到 PATH:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</div></pre></td></tr></table></figure>

<p>想了解更多设置GOPATH 环境变量的知识，可以查看<a href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable" target="_blank" rel="external">go help gopath</a></p>
<h3 id="Package路径">Package路径</h3>
<p>标准库中的 package 只要使用短路径即可, 比如 &quot;fmt&quot;, &quot;net/http&quot;。<br>对于自己的 package, 必须选一个基本路径以防止以后和标准库, 或者其他第三方的库产生冲突。<br>如果你的代码保存在某个代码仓库, 那么就可以使用那个代码仓库的根目录作为你的 package 的基本路径。<br>比如, 你有个 github 的账户在 <code>github.com/user</code>, 就可以使用 <code>github.com/user</code> 作为你的基本路径。</p>
<p><strong>注意</strong> 在能够正确编译代码之前, 你并不需要发布你的代码到远程的代码仓库。<br>但是如果有一天你发布代码的话, 组织好你的代码是个好习惯。<br>实际上, 你可以使用任意的路径名称, 只要它在 go 标准库和庞大的 go 生态系统中是唯一的。<br>我们使用 &quot;github.com/user&quot; 作为基本路径, 然后在工作区中创建文件夹来保存代码:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p <span class="variable">$GOPATH</span>/src/github.com/user</div></pre></td></tr></table></figure>

<h3 id="第一个_Go_程序">第一个 Go 程序</h3>
<p>为了编译和运行一个简单的 GO 程序, 首先要确定 package 路径(这里使用 <em>github.com/user/hello</em>),<br>并且在工作区中创建对应 package 文件夹.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/user/hello</div></pre></td></tr></table></figure>

<p>下一步, 在上面文件夹中创建 hello.go 文件, 文件内容如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Printf(<span class="string">"Hello, world.\n"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后, 可以通过 go tool 来编译和安装上面的 hello 程序。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go install github.com/user/hello</div></pre></td></tr></table></figure>

<p><strong>注意</strong> 你可以在任何路径下运行上述命令, go tool 会根据 GOPATH 环境变量来从工作区中查找 github.com/user/hello。<br>如果在 package 所在文件夹中运行 go install, 也可以省略 package 路径。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</div><div class="line">$ go install</div></pre></td></tr></table></figure>

<p>上面的命令编译了 hello 命令, 并产生此命令的二进制可执行文件。<br>然后将二进制文件 hello 安装到了 工作区 的 bin 文件夹下(Windows 下是 hello.exe)<br>在我们的例子中, 就是 $GOPATH/bin/hello, 即 $HOME/work/bin/hello。</p>
<p>go tool 只有在出错时才会输出信息, 如果上面的 go 命令没有输出就说明执行成功了.<br>然后, 就可以在命令行中运行这个命令了.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="variable">$GOPATH</span>/bin/hello</div><div class="line">Hello, world.</div></pre></td></tr></table></figure>

<p>或者, 如果你将 $GOPATH/bin 加入到 PATH 中了的话, 也可以执行执行 hello 命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hello</div></pre></td></tr></table></figure>

<p>如果你使用了代码版本管理工具, 正好可以初始化你的仓库, 添加文件, 并 commit 你的第一个改变。<br>当然这个步骤是可选的, 写 go 代码并不强制要求使用代码版本管理工具。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</div><div class="line">$ git init</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /home/user/work/src/github.com/user/hello/.git/</div><div class="line">$ git add hello.go</div><div class="line">$ git commit -m <span class="string">"initial commit"</span></div><div class="line">[master (root-commit) <span class="number">0</span>b4507d] initial commit</div><div class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</div><div class="line">  create mode <span class="number">100644</span> hello.go</div></pre></td></tr></table></figure>

<p>你可以把发布这个仓库作为练习题。</p>
<h3 id="第一个Go库">第一个Go库</h3>
<p>让我们来写一个库, 并将之用于上面的 hello 程序中.<br>同样, 首先确定 package 路径 (这里使用 github.com/user/stringutil), 并创建对应的文件夹。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/user/stringutil</div></pre></td></tr></table></figure>

<p>接着, 创建文件 <em>reverse.go</em>, 内容如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></div><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></div><div class="line"><span class="keyword">func</span> Reverse(s <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	r := []<span class="typename">rune</span>(s)</div><div class="line">	<span class="keyword">for</span> i, j :=<span class="number"> 0</span>, <span class="built_in">len</span>(r<span class="number">)-1</span>; i &lt; <span class="built_in">len</span>(r)<span class="number">/2</span>; i, j = i<span class="number">+1</span>, j<span class="number">-1</span> {</div><div class="line">		r[i], r[j] = r[j], r[i]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(r)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>用 go build 来编译此 package:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build github.com/user/stringutil</div></pre></td></tr></table></figure>

<p>或者在 package 的目录下, 直接运行 go build</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build</div></pre></td></tr></table></figure>

<p>上面的命令不会产生输出文件。 为了生成输出文件, 必须使用 <code>go install</code> 命令, 它会在 pkg 文件夹下生成 package 对象.<br>stringutil package 编译成功之后, 修改之前的 hello.go 文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/user/stringutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Printf(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>无论用 go tool 安装 package 对象还是 二进制文件, 它都会安装所有的依赖.<br>所以当你安装 hello 程序时,</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go install github.com/user/hello</div></pre></td></tr></table></figure>

<p>stringutil package 也会被自动安装.</p>
<p>运行新的 hello 程序, 可以看到如下输出:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, Go!</div></pre></td></tr></table></figure>

<p>经过上面的步骤, 你的 工作区应该像下面这样:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                 # <span class="keyword">command</span> <span class="built_in">executable</span></div><div class="line">pkg/</div><div class="line">    linux_amd64/          # this will reflect your OS <span class="built_in">and</span> architecture</div><div class="line">        github.<span class="keyword">com</span>/user/</div><div class="line">            stringutil.<span class="keyword">a</span>  # package object</div><div class="line">src/</div><div class="line">    github.<span class="keyword">com</span>/user/</div><div class="line">        hello/</div><div class="line">            hello.<span class="keyword">go</span>      # <span class="keyword">command</span> <span class="keyword">source</span></div><div class="line">        stringutil/</div><div class="line">            <span class="built_in">reverse</span>.<span class="keyword">go</span>    # package <span class="keyword">source</span></div></pre></td></tr></table></figure>

<p><strong>注意</strong> go install 将 stringutil.a 放进了 pkg/linux_amd64 文件夹下与源码对应的目录中。<br>以后, go tool 就可以找到这个 package, 从而判断是否需要重新编译。<br>linux_amd64 是表示当前使用的系统, 它的目的是为了区分交叉编译出的其他平台的 package。</p>
<p>Go 编译出的二进制文件都是静态链接的, 所以上面的 bin/hello 在执行时并不需要 linux_amd64/go-files/stringutil.a 文件。</p>
<h3 id="Package_name">Package name</h3>
<p>go 代码文件的第一行必须是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> name</div></pre></td></tr></table></figure>

<p>这里的 name 作为 package 的默认名称, 让其他 package import 的时候用.(同个 package 中的所有文件必须使用相同的 name)。<br>Go 约定 package name 是 import path 中最后一部分。<br>也就是说, 如果一个 package 被引用时写成 &quot;crypto/rot13&quot;, 那么这个 package 的 name 就是 rot13。</p>
<p>编译为可执行文件的代码的 package name 必须是 main。</p>
<p>连接进同一个二进制文件的package name 不一定要唯一, 只要 pakage 的 import path 是唯一的就行。<br>也就是上面的 crypto/rot13 必须唯一, 但是可以有 another-crypto/rot13。</p>
<p>Go 的命名规则可以参考: [Effective Go](<a href="http://golang.org/doc/effective_go.html#names）" target="_blank" rel="external">http://golang.org/doc/effective_go.html#names）</a></p>
<h2 id="测试">测试</h2>
<p>Go 中包含一个轻量级的测试框架, 由 <code>go test</code> 命令和 <code>testing package</code> 组成。</p>
<p>测试文件的名称以 <code>_test.go</code> 结尾, 其中包含格式如 <code>func TestXXXX(t *testing.T)</code>的函数。<br>测试框架会执行每个这样的函数, 如果函数中调用了 <code>t.Error</code> 或者 <code>t.Fail</code>, 就认为测试失败。</p>
<p>给上面的 package <em>stringutil</em> 增加测试文件, 路径: <em>$GOPATH/src/github.com/user/stringutil/reverse_test.go</em> , 内容如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> TestReverse(t *testing.T) {</div><div class="line">	cases := []<span class="keyword">struct</span> {</div><div class="line">		in, want <span class="typename">string</span></div><div class="line">	}{</div><div class="line">		{<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>},</div><div class="line">		{<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>},</div><div class="line">		{<span class="string">""</span>, <span class="string">""</span>},</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases {</div><div class="line">		got := Reverse(c.in)</div><div class="line">		<span class="keyword">if</span> got != c.want {</div><div class="line">			t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行测试的方法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/user/stringutil</div><div class="line">ok  	github.com/user/stringutil <span class="number">0.165</span>s</div></pre></td></tr></table></figure>

<p>或者进入到 package stringutil 的目录中后, 直接运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test</div><div class="line">ok  	github.com/user/stringutil <span class="number">0.165</span>s</div></pre></td></tr></table></figure>

<p>通过 <a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank" rel="external">go help test</a> 或者 <a href="http://golang.org/pkg/testing/" target="_blank" rel="external">http://golang.org/pkg/testing/</a> 来进一步 GO 的测试框架。</p>
<h2 id="远程_package">远程 package</h2>
<p>Go 的 <em>import path</em> 指示如何从版本管理系统(Git 或者 Mercurial) 中获取 package 的源码。go tool 可以利用这个特性来自动获取远程仓库的代码。<br>比如, 下面的例子中使用的代码同时也保存在 github 上(<a href="http://github.com/golang/example)。" target="_blank" rel="external">http://github.com/golang/example)。</a><br>如果你在代码中 import 了上面这个远程的 package, 那么 go get 命令会自动 获取, 编译, 安装这个 package。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/golang/example/hello</div><div class="line">$ <span class="variable">$GOPATH</span>/bin/hello</div><div class="line">Hello, Go examples!</div></pre></td></tr></table></figure>

<p>如果工作区中没有指定的 package,<code>go get</code> 命令会把这个 package 下载到 GOPATH 中定义的第一个工作区中。<br>(如果这个package已经存在，<code>go get</code>会跳过获取这一步，执行<code>go install</code>相同的行为)</p>
<p>上面的 go get 命令执行之后, 文件夹结构大致如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                           # <span class="keyword">command</span> <span class="built_in">executable</span></div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.<span class="keyword">com</span>/golang/example/</div><div class="line">            stringutil.<span class="keyword">a</span>            # package object</div><div class="line">        github.<span class="keyword">com</span>/user/</div><div class="line">            stringutil.<span class="keyword">a</span>            # package object</div><div class="line">src/</div><div class="line">    github.<span class="keyword">com</span>/golang/example/</div><div class="line">	.git/                       # Git repository metadata</div><div class="line">        hello/</div><div class="line">            hello.<span class="keyword">go</span>                # <span class="keyword">command</span> <span class="keyword">source</span></div><div class="line">        stringutil/</div><div class="line">            <span class="built_in">reverse</span>.<span class="keyword">go</span>              # package <span class="keyword">source</span></div><div class="line">            reverse_test.<span class="keyword">go</span>         # test <span class="keyword">source</span></div><div class="line">    github.<span class="keyword">com</span>/user/</div><div class="line">        hello/</div><div class="line">            hello.<span class="keyword">go</span>                # <span class="keyword">command</span> <span class="keyword">source</span></div><div class="line">        stringutil/</div><div class="line">            <span class="built_in">reverse</span>.<span class="keyword">go</span>              # package <span class="keyword">source</span></div><div class="line">            reverse_test.<span class="keyword">go</span>         # test <span class="keyword">source</span></div></pre></td></tr></table></figure>

<p>github.com 上的 hello 程序依赖同一个仓库中的 package stringutil,<br>即 github.com 上的 hello.go 中引用了 github.com 上的 package stringutil, 所以, go get 命令也下载, 编译, 安装了 stringutil 模块。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import <span class="string">"github.com/golang/example/stringutil"</span></div></pre></td></tr></table></figure>

<p>这个特性可以让你的 go package 很容易的被别人使用.<br><a href="https://golang.org/wiki/Projects" target="_blank" rel="external">Go Wiki</a> 和 <a href="https://godoc.org/" target="_blank" rel="external">godoc.org</a> 上列出了很多第三方 Go 工程。<br>关于使用 go tool 来使用远程仓库的更多信息, 请参考: <a href="https://golang.org/cmd/go/#hdr-Remote_import_paths" target="_blank" rel="external">go help importpath</a></p>
<h2 id="下一步">下一步</h2>
<ul>
<li>订阅 <a href="https://groups.google.com/group/golang-announce" target="_blank" rel="external">golang-announce</a> 邮件列表来了解最新的 Go release 信息</li>
<li>将 <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a> 作为参考资料来编写整洁, 地道的 Go 代码</li>
<li>通过 <a href="https://tour.golang.org/" target="_blank" rel="external">A Tour of Go </a> 来完成一次 go 的旅行</li>
<li>访问 <a href="https://golang.org/doc/#articles" target="_blank" rel="external">documentation page</a> 来了解一系列关于Go语言的有深度的文章, 以及 Go 库和工具.</li>
</ul>
<h2 id="寻求帮助">寻求帮助</h2>
<ul>
<li>寻求实时帮助, 可以使用 <a href="http://freenode.net/" target="_blank" rel="external">FreeNode</a> 的IRC server #go-nuts</li>
<li>Go 语言官方邮件列表 <a href="https://groups.google.com/forum/#!forum/golang-nuts" target="_blank" rel="external">Go Nuts</a></li>
<li>汇报 Go 语言的 bug 请使用 <a href="http://golang.org/issue" target="_blank" rel="external">Go issue tracker</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>官方原文: <a href="https://golang.org/doc/code.html" target="_blank" rel="external">How to Write Go Code</a>,<br>根据最新官方文档翻译。翻译参考<a href="http://www.cnblogs.com/wang_yb/" target="_blank" rel="external">wang_yb</a>的<a href="http://www.cnblogs.com/wang_yb/p/4333331.html" target="_blank" rel="external">如何写 go 代码 </a>。<br>因为官方文档有更新，我根据新版本的文档重新进行了翻译。</p>
<p>本文演示如何开发一个简单的 go package, 以及 <a href="https://golang.org/cmd/go/" target="_blank" rel="external">go tool</a> 的使用方法,<br>即获取(fetch), 编译(build), 安装(install) go package 的标准方法和命令.</p>
<p><em>go</em> tool 需要你按照一定的标准来组织代码. 请仔细阅读本文.<br>它介绍了用来构建和运行 Go 程序的最简单方法.</p>
<p>介绍本文的视频参照: <a href="https://www.youtube.com/watch?v=XCsL89YtqCs。" target="_blank" rel="external">https://www.youtube.com/watch?v=XCsL89YtqCs。</a><br>]]>
    
    </summary>
    
      <category term="Golang" scheme="http://colobu.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go的50度灰：Golang新开发者要注意的陷阱和常见错误]]></title>
    <link href="http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/"/>
    <id>http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/</id>
    <published>2015-09-07T03:28:54.000Z</published>
    <updated>2015-09-10T01:30:17.217Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs</a><br>翻译: <a href="http://www.shwley.com/index.php/archives/80/" target="_blank" rel="external">Go的50度灰：新Golang开发者要注意的陷阱、技巧和常见错误</a>, 译者: <a href="http://www.shwley.com/index.php/author/1/" target="_blank" rel="external">影风LEY </a></p>
<p>Go是一门简单有趣的语言，但与其他语言类似，它会有一些技巧。。。这些技巧的绝大部分并不是Go的缺陷造成的。如果你以前使用的是其他语言，那么这其中的有些错误就是很自然的陷阱。其它的是由错误的假设和缺少细节造成的。</p>
<p>如果你花时间学习这门语言，阅读官方说明、wiki、邮件列表讨论、大量的优秀博文和Rob Pike的展示，以及源代码，这些技巧中的绝大多数都是显而易见的。尽管不是每个人都是以这种方式开始学习的，但也没关系。如果你是Go语言新人，那么这里的信息将会节约你大量的调试代码的时间。<br><a id="more"></a></p>
<h2 id="初级">初级</h2>
<h3 id="开大括号不能放在单独的一行">开大括号不能放在单独的一行</h3>
<p>在大多数其他使用大括号的语言中，你需要选择放置它们的位置。Go的方式不同。你可以为此感谢下自动分号的注入（没有预读）。是的，Go中也是有分号的：-）<br>失败的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main()  </div><div class="line">{ <span class="comment">//error, can't have the opening brace on a separate line</span></div><div class="line">    fmt.Println(<span class="string">"hello there!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译错误：</p>
<blockquote>
<p>/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before {</p>
</blockquote>
<p>有效的例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    fmt.Println(<span class="string">"works!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="未使用的变量">未使用的变量</h3>
<p>如果你有未使用的变量，代码将编译失败。当然也有例外。在函数内一定要使用声明的变量，但未使用的全局变量是没问题的。<br>如果你给未使用的变量分配了一个新的值，代码还是会编译失败。你需要在某个地方使用这个变量，才能让编译器愉快的编译。<br>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">var</span> gvar <span class="typename">int</span> <span class="comment">//not an error</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> one <span class="typename">int</span>   <span class="comment">//error, unused variable</span></div><div class="line">    two :=<span class="number"> 2</span>      <span class="comment">//error, unused variable</span></div><div class="line">    <span class="keyword">var</span> three <span class="typename">int</span> <span class="comment">//error, even though it's assigned 3 on the next line</span></div><div class="line">    three =<span class="number"> 3</span>     </div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox473116179/main.go:6: one declared and not used<br>/tmp/sandbox473116179/main.go:7: two declared and not used<br>/tmp/sandbox473116179/main.go:8: three declared and not used</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> one <span class="typename">int</span></div><div class="line">    _ = one</div><div class="line"></div><div class="line">    two :=<span class="number"> 2</span> </div><div class="line">    fmt.Println(two)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> three <span class="typename">int</span> </div><div class="line">    three =<span class="number"> 3</span></div><div class="line">    one = three</div><div class="line"></div><div class="line">    <span class="keyword">var</span> four <span class="typename">int</span></div><div class="line">    four = four</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个选择是注释掉或者移除未使用的变量 ：-）</p>
<h3 id="未使用的Imports">未使用的Imports</h3>
<p>如果你引入一个包，而没有使用其中的任何函数、接口、结构体或者变量的话，代码将会编译失败。<br>你可以使用<a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="external">goimports</a>来增加引入或者移除未使用的引用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> golang.org/<span class="keyword">x</span>/tools/cmd/goimports</div></pre></td></tr></table></figure>

<p>如果你真的需要引入的包，你可以添加一个下划线标记符，_，来作为这个包的名字，从而避免编译失败。下滑线标记符用于引入，但不使用。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox627475386/main.go:4: imported and not used: &quot;fmt&quot;<br>/tmp/sandbox627475386/main.go:5: imported and not used: &quot;log&quot;<br>/tmp/sandbox627475386/main.go:6: imported and not used: &quot;time&quot;</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    _ <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = log.Println</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    _ = time.Now</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个选择是移除或者注释掉未使用的imports ：-）</p>
<h3 id="简式的变量声明仅可以在函数内部使用">简式的变量声明仅可以在函数内部使用</h3>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line">myvar :=<span class="number"> 1</span> <span class="comment">//error</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">var</span> myvar =<span class="number"> 1</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用简式声明重复声明变量">使用简式声明重复声明变量</h3>
<p>你不能在一个单独的声明中重复声明一个变量，但在多变量声明中这是允许的，其中至少要有一个新的声明变量。<br>重复变量需要在相同的代码块内，否则你将得到一个隐藏变量。<br>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    one :=<span class="number"> 0</span></div><div class="line">    one :=<span class="number"> 1</span> <span class="comment">//error</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox706333626/main.go:5: no new variables on left side of :=</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    one :=<span class="number"> 0</span></div><div class="line">    one, two :=<span class="number"> 1</span><span class="number">,2</span></div><div class="line"></div><div class="line">    one,two = two,one</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="偶然的变量隐藏Accidental_Variable_Shadowing">偶然的变量隐藏Accidental Variable Shadowing</h3>
<p>短式变量声明的语法如此的方便（尤其对于那些使用过动态语言的开发者而言），很容易让人把它当成一个正常的分配操作。如果你在一个新的代码块中犯了这个错误，将不会出现编译错误，但你的应用将不会做你所期望的事情。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x :=<span class="number"> 1</span></div><div class="line">    fmt.Println(x)     <span class="comment">//prints 1</span></div><div class="line">    {</div><div class="line">        fmt.Println(x) <span class="comment">//prints 1</span></div><div class="line">        x :=<span class="number"> 2</span></div><div class="line">        fmt.Println(x) <span class="comment">//prints 2</span></div><div class="line">    }</div><div class="line">    fmt.Println(x)     <span class="comment">//prints 1 (bad if you need 2)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>即使对于经验丰富的Go开发者而言，这也是一个非常常见的陷阱。这个坑很容易挖，但又很难发现。</p>
<p>你可以使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet" target="_blank" rel="external">vet</a>命令来发现一些这样的问题。 默认情况下， <code>vet</code>不会执行这样的检查，你需要设置<code>-shadow</code>参数：<br><code>go tool vet -shadow your_file.go</code>。</p>
<h3 id="不使用显式类型，无法使用“nil”来初始化变量">不使用显式类型，无法使用“nil”来初始化变量</h3>
<p><code>nil</code>标志符用于表示interface、函数、maps、slices和channels的“零值”。如果你不指定变量的类型，编译器将无法编译你的代码，因为它猜不出具体的类型。<br>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> x = <span class="constant">nil</span> <span class="comment">//error</span></div><div class="line"></div><div class="line">    _ = x</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox188239583/main.go:4: use of untyped nil</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>{} = <span class="constant">nil</span></div><div class="line"></div><div class="line">    _ = x</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用“nil”_Slices_and_Maps">使用“nil” Slices and Maps</h3>
<p>在一个<code>nil</code>的slice中添加元素是没问题的，但对一个map做同样的事将会生成一个运行时的panic。</p>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> s []<span class="typename">int</span></div><div class="line">    s = <span class="built_in">append</span>(s<span class="number">,1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div><div class="line">    m[<span class="string">"one"</span>] =<span class="number"> 1</span> <span class="comment">//error</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Map的容量">Map的容量</h3>
<p>你可以在map创建时指定它的容量，但你无法在map上使用cap()函数。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span><span class="number">,99</span>)</div><div class="line">    <span class="built_in">cap</span>(m) <span class="comment">//error</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox326543983/main.go:5: invalid argument m (type map[string]int) for cap</p>
</blockquote>
<h3 id="字符串不会为nil">字符串不会为<code>nil</code></h3>
<p>这对于经常使用<code>nil</code>分配字符串变量的开发者而言是个需要注意的地方。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> x <span class="typename">string</span> = <span class="constant">nil</span> <span class="comment">//error</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> x == <span class="constant">nil</span> { <span class="comment">//error</span></div><div class="line">        x = <span class="string">"default"</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment /tmp/sandbox630560459/main.go:6: invalid operation: x == nil (mismatched types string and nil)</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> x <span class="typename">string</span> <span class="comment">//defaults to "" (zero value)</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> x == <span class="string">""</span> {</div><div class="line">        x = <span class="string">"default"</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Array函数的参数">Array函数的参数</h3>
<p>如果你是一个C或则C++开发者，那么数组对你而言就是指针。当你向函数中传递数组时，函数会参照相同的内存区域，这样它们就可以修改原始的数据。Go中的数组是数值，因此当你向函数中传递数组时，函数会得到原始数组数据的一份复制。如果你打算更新数组的数据，这将会是个问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="number">[3</span>]<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line"></div><div class="line">    <span class="keyword">func</span>(arr <span class="number">[3</span>]<span class="typename">int</span>) {</div><div class="line">        arr<span class="number">[0</span>] =<span class="number"> 7</span></div><div class="line">        fmt.Println(arr) <span class="comment">//prints [7 2 3]</span></div><div class="line">    }(x)</div><div class="line"></div><div class="line">    fmt.Println(x) <span class="comment">//prints [1 2 3] (not ok if you need [7 2 3])</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你需要更新原始数组的数据，你可以使用数组指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="number">[3</span>]<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line"></div><div class="line">    <span class="keyword">func</span>(arr *<span class="number">[3</span>]<span class="typename">int</span>) {</div><div class="line">        (*arr)<span class="number">[0</span>] =<span class="number"> 7</span></div><div class="line">        fmt.Println(arr) <span class="comment">//prints &[7 2 3]</span></div><div class="line">    }(&x)</div><div class="line"></div><div class="line">    fmt.Println(x) <span class="comment">//prints [7 2 3]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个选择是使用slice。即使你的函数得到了slice变量的一份拷贝，它依旧会参照原始的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := []<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line"></div><div class="line">    <span class="keyword">func</span>(arr []<span class="typename">int</span>) {</div><div class="line">        arr<span class="number">[0</span>] =<span class="number"> 7</span></div><div class="line">        fmt.Println(arr) <span class="comment">//prints [7 2 3]</span></div><div class="line">    }(x)</div><div class="line"></div><div class="line">    fmt.Println(x) <span class="comment">//prints [7 2 3]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="在Slice和Array使用“range”语句时的出现的不希望得到的值">在Slice和Array使用“range”语句时的出现的不希望得到的值</h3>
<p>如果你在其他的语言中使用“for-in”或者“foreach”语句时会发生这种情况。Go中的“range”语法不太一样。它会得到两个值：第一个值是元素的索引，而另一个值是元素的数据。<br>Bad:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := []<span class="typename">string</span>{<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x {</div><div class="line">        fmt.Println(v) <span class="comment">//prints 0, 1, 2</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Good:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := []<span class="typename">string</span>{<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x {</div><div class="line">        fmt.Println(v) <span class="comment">//prints a, b, c</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Slices和Arrays是一维的">Slices和Arrays是一维的</h3>
<p>看起来Go好像支持多维的Array和Slice，但不是这样的。尽管可以创建数组的数组或者切片的切片。对于依赖于动态多维数组的数值计算应用而言，Go在性能和复杂度上还相距甚远。</p>
<p>你可以使用纯一维数组、“独立”切片的切片，“共享数据”切片的切片来构建动态的多维数组。</p>
<p>如果你使用纯一维的数组，你需要处理索引、边界检查、当数组需要变大时的内存重新分配。</p>
<p>使用“独立”slice来创建一个动态的多维数组需要两步。首先，你需要创建一个外部的slice。然后，你需要分配每个内部的slice。内部的slice相互之间独立。你可以增加减少它们，而不会影响其他内部的slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x :=<span class="number"> 2</span></div><div class="line">    y :=<span class="number"> 4</span></div><div class="line"></div><div class="line">    table := <span class="built_in">make</span>([][]<span class="typename">int</span>,x)</div><div class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> table {</div><div class="line">        table[i] = <span class="built_in">make</span>([]<span class="typename">int</span>,y)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用“共享数据”slice的slice来创建一个动态的多维数组需要三步。首先，你需要创建一个用于存放原始数据的数据“容器”。然后，你再创建外部的slice。最后，通过重新切片原始数据slice来初始化各个内部的slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    h, w :=<span class="number"> 2</span>,<span class="number"> 4</span></div><div class="line"></div><div class="line">    raw := <span class="built_in">make</span>([]<span class="typename">int</span>,h*w)</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw {</div><div class="line">        raw[i] = i</div><div class="line">    }</div><div class="line">    fmt.Println(raw,&raw<span class="number">[4</span>])</div><div class="line">    <span class="comment">//prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;</span></div><div class="line"></div><div class="line">    table := <span class="built_in">make</span>([][]<span class="typename">int</span>,h)</div><div class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> table {</div><div class="line">        table[i] = raw[i*w:i*w + w]</div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(table,&table<span class="number">[1</span>]<span class="number">[0</span>])</div><div class="line">    <span class="comment">//prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>关于多维array和slice已经有了专门申请，但现在看起来这是个低优先级的特性。</p>
<h3 id="访问不存在的Map_Keys">访问不存在的Map Keys</h3>
<p>这对于那些希望得到“nil”标示符的开发者而言是个技巧（和其他语言中做的一样）。如果对应的数据类型的“零值”是“nil”，那返回的值将会是“nil”，但对于其他的数据类型是不一样的。检测对应的“零值”可以用于确定map中的记录是否存在，但这并不总是可信（比如，如果在二值的map中“零值”是false，这时你要怎么做）。检测给定map中的记录是否存在的最可信的方法是，通过map的访问操作，检查第二个返回的值。</p>
<p>Bad:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">string</span>{<span class="string">"one"</span>:<span class="string">"a"</span>,<span class="string">"two"</span>:<span class="string">""</span>,<span class="string">"three"</span>:<span class="string">"c"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">if</span> v := x[<span class="string">"two"</span>]; v == <span class="string">""</span> { <span class="comment">//incorrect</span></div><div class="line">        fmt.Println(<span class="string">"no entry"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Good:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">string</span>{<span class="string">"one"</span>:<span class="string">"a"</span>,<span class="string">"two"</span>:<span class="string">""</span>,<span class="string">"three"</span>:<span class="string">"c"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">if</span> _,ok := x[<span class="string">"two"</span>]; !ok {</div><div class="line">        fmt.Println(<span class="string">"no entry"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Strings无法修改">Strings无法修改</h3>
<p>尝试使用索引操作来更新字符串变量中的单个字符将会失败。string是只读的byte slice（和一些额外的属性）。如果你确实需要更新一个字符串，那么使用byte slice，并在需要时把它转换为string类型。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="string">"text"</span></div><div class="line">    x<span class="number">[0</span>] = <span class="string">'T'</span></div><div class="line"></div><div class="line">    fmt.Println(x)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox305565531/main.go:7: cannot assign to x[0]</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="string">"text"</span></div><div class="line">    xbytes := []<span class="typename">byte</span>(x)</div><div class="line">    xbytes<span class="number">[0</span>] = <span class="string">'T'</span></div><div class="line"></div><div class="line">    fmt.Println(<span class="typename">string</span>(xbytes)) <span class="comment">//prints Text</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>需要注意的是：这并不是在文字string中更新字符的正确方式，因为给定的字符可能会存储在多个byte中。如果你确实需要更新一个文字string，先把它转换为一个rune slice。即使使用rune slice，单个字符也可能会占据多个rune，比如当你的字符有特定的重音符号时就是这种情况。这种复杂又模糊的“字符”本质是Go字符串使用byte序列表示的原因。</p>
<h3 id="String和Byte_Slice之间的转换">String和Byte Slice之间的转换</h3>
<p>当你把一个字符串转换为一个<code>byte slice</code>（或者反之）时，你就得到了一个原始数据的完整拷贝。这和其他语言中cast操作不同，也和新的<code>slice</code>变量指向原始<code>byte</code> slice使用的相同数组时的重新slice操作不同。</p>
<p>Go在<code>[]byte</code>到<code>string</code>和<code>string</code>到<code>[]byte</code>的转换中确实使用了一些优化来避免额外的分配（在todo列表中有更多的优化）。</p>
<p>第一个优化避免了当<code>[]byte</code> keys用于在<code>map[string]</code>集合中查询时的额外分配:<code>m[string(key)]</code>。</p>
<p>第二个优化避免了字符串转换为<code>[]byte</code>后在<code>for range</code>语句中的额外分配：<code>for i,v := range []byte(str) {...}</code>。</p>
<h3 id="String和索引操作">String和索引操作</h3>
<p>字符串上的索引操作返回一个byte值，而不是一个字符（和其他语言中的做法一样）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := <span class="string">"text"</span></div><div class="line">    fmt.Println(x<span class="number">[0</span>]) <span class="comment">//print 116</span></div><div class="line">    fmt.Printf(<span class="string">"%T"</span>,x<span class="number">[0</span>]) <span class="comment">//prints uint8</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你需要访问特定的字符串“字符”（unicode编码的points/runes），使用for range。官方的“unicode/utf8”包和实验中的utf8string包（golang.org/x/exp/utf8string）也可以用。utf8string包中包含了一个很方便的At()方法。把字符串转换为rune的切片也是一个选项。</p>
<h3 id="字符串不总是UTF8文本">字符串不总是UTF8文本</h3>
<p>字符串的值不需要是UTF8的文本。它们可以包含任意的字节。只有在string literal使用时，字符串才会是UTF8。即使之后它们可以使用转义序列来包含其他的数据。</p>
<p>为了知道字符串是否是UTF8，你可以使用“unicode/utf8”包中的ValidString()函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"unicode/utf8"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data1 := <span class="string">"ABC"</span></div><div class="line">    fmt.Println(utf8.ValidString(data1)) <span class="comment">//prints: true</span></div><div class="line"></div><div class="line">    data2 := <span class="string">"A\xfeC"</span></div><div class="line">    fmt.Println(utf8.ValidString(data2)) <span class="comment">//prints: false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="字符串的长度">字符串的长度</h3>
<p>让我们假设你是Python开发者，你有下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = <span class="string">u'♥'</span>  </div><div class="line">print(len(data)) <span class="comment">#prints: 1</span></div></pre></td></tr></table></figure>

<p>当把它转换为Go代码时，你可能会大吃一惊。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := <span class="string">"♥"</span></div><div class="line">    fmt.Println(<span class="built_in">len</span>(data)) <span class="comment">//prints: 3</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>内建的<code>len()</code>函数返回byte的数量，而不是像Python中计算好的unicode字符串中字符的数量。</p>
<p>要在Go中得到相同的结果，可以使用“unicode/utf8”包中的<code>RuneCountInString()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"unicode/utf8"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := <span class="string">"♥"</span></div><div class="line">    fmt.Println(utf8.RuneCountInString(data)) <span class="comment">//prints: 1</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>理论上说<code>RuneCountInString()</code>函数并不返回字符的数量，因为单个字符可能占用多个rune。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"unicode/utf8"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := <span class="string">"é"</span></div><div class="line">    fmt.Println(<span class="built_in">len</span>(data))                    <span class="comment">//prints: 3</span></div><div class="line">    fmt.Println(utf8.RuneCountInString(data)) <span class="comment">//prints: 2</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="在多行的Slice、Array和Map语句中遗漏逗号">在多行的Slice、Array和Map语句中遗漏逗号</h3>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := []<span class="typename">int</span>{</div><div class="line">   <span class="number"> 1</span>,</div><div class="line">   <span class="number"> 2</span> <span class="comment">//error</span></div><div class="line">    }</div><div class="line">    _ = x</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected }</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    x := []<span class="typename">int</span>{</div><div class="line">   <span class="number"> 1</span>,</div><div class="line">   <span class="number"> 2</span>,</div><div class="line">    }</div><div class="line">    x = x</div><div class="line"></div><div class="line">    y := []<span class="typename">int</span><span class="number">{3</span><span class="number">,4</span>,} <span class="comment">//no error</span></div><div class="line">    y = y</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当你把声明折叠到单行时，如果你没加末尾的逗号，你将不会得到编译错误。</p>
<h3 id="log-Fatal和log-Panic不仅仅是Log">log.Fatal和log.Panic不仅仅是Log</h3>
<p>Logging库一般提供不同的log等级。与这些logging库不同，Go中log包在你调用它的<code>Fatal*()</code>和<code>Panic*()</code>函数时，可以做的不仅仅是log。当你的应用调用这些函数时，Go也将会终止应用 :-)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"log"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    log.Fatalln(<span class="string">"Fatal Level: log entry"</span>) <span class="comment">//app exits here</span></div><div class="line">    log.Println(<span class="string">"Normal Level: log entry"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="内建的数据结构操作不是同步的">内建的数据结构操作不是同步的</h3>
<p>即使Go本身有很多特性来支持并发，并发安全的数据集合并不是其中之一 :-)确保数据集合以原子的方式更新是你的职责。Goroutines和channels是实现这些原子操作的推荐方式，但你也可以使用“sync”包，如果它对你的应用有意义的话。</p>
<h3 id="String在“range”语句中的迭代值">String在“range”语句中的迭代值</h3>
<p>索引值（“range”操作返回的第一个值）是返回的第二个值的当前“字符”（unicode编码的point/rune）的第一个byte的索引。它不是当前“字符”的索引，这与其他语言不同。注意真实的字符可能会由多个rune表示。如果你需要处理字符，确保你使用了“norm”包（golang.org/x/text/unicode/norm）。</p>
<p>string变量的<code>for range</code>语句将会尝试把数据翻译为UTF8文本。对于它无法理解的任何byte序列，它将返回0xfffd runes（即unicode替换字符），而不是真实的数据。如果你任意（非UTF8文本）的数据保存在string变量中，确保把它们转换为byte slice，以得到所有保存的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := <span class="string">"A\xfe\x02\xff\x04"</span></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        fmt.Printf(<span class="string">"%#x "</span>,v)</div><div class="line">    }</div><div class="line">    <span class="comment">//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)</span></div><div class="line"></div><div class="line">    fmt.Println()</div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> []<span class="typename">byte</span>(data) {</div><div class="line">        fmt.Printf(<span class="string">"%#x "</span>,v)</div><div class="line">    }</div><div class="line">    <span class="comment">//prints: 0x41 0xfe 0x2 0xff 0x4 (good)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="对Map使用“for_range”语句迭代">对Map使用“for range”语句迭代</h3>
<p>如果你希望以某个顺序（比如，按key值排序）的方式得到元素，就需要这个技巧。每次的map迭代将会生成不同的结果。Go的runtime有心尝试随机化迭代顺序，但并不总会成功，这样你可能得到一些相同的map迭代结果。所以如果连续看到5个相同的迭代结果，不要惊讶。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    m := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>{<span class="string">"one"</span><span class="number">:1</span>,<span class="string">"two"</span><span class="number">:2</span>,<span class="string">"three"</span><span class="number">:3</span>,<span class="string">"four"</span><span class="number">:4</span>}</div><div class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m {</div><div class="line">        fmt.Println(k,v)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而且如果你使用Go的游乐场（<a href="https://play.golang.org/)，你将总会得到同样的结果，因为除非你修改代码，否则它不会重新编译代码。" target="_blank" rel="external">https://play.golang.org/)，你将总会得到同样的结果，因为除非你修改代码，否则它不会重新编译代码。</a></p>
<h3 id="&quot;switch&quot;声明中的失效行为">&quot;switch&quot;声明中的失效行为</h3>
<p>在“switch”声明语句中的“case”语句块在默认情况下会break。这和其他语言中的进入下一个“next”代码块的默认行为不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    isSpace := <span class="keyword">func</span>(ch <span class="typename">byte</span>) <span class="typename">bool</span> {</div><div class="line">        <span class="keyword">switch</span>(ch) {</div><div class="line">        <span class="keyword">case</span> <span class="string">' '</span>: <span class="comment">//error</span></div><div class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>)) <span class="comment">//prints true (ok)</span></div><div class="line">    fmt.Println(isSpace(<span class="string">' '</span>))  <span class="comment">//prints false (not ok)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以通过在每个“case”块的结尾使用“fallthrough”，来强制“case”代码块进入。你也可以重写switch语句，来使用“case”块中的表达式列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    isSpace := <span class="keyword">func</span>(ch <span class="typename">byte</span>) <span class="typename">bool</span> {</div><div class="line">        <span class="keyword">switch</span>(ch) {</div><div class="line">        <span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'\t'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>)) <span class="comment">//prints true (ok)</span></div><div class="line">    fmt.Println(isSpace(<span class="string">' '</span>))  <span class="comment">//prints true (ok)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="自增和自减">自增和自减</h3>
<p>许多语言都有自增和自减操作。不像其他语言，Go不支持前置版本的操作。你也无法在表达式中使用这两个操作符。<br>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line">    i :=<span class="number"> 0</span></div><div class="line">    ++i <span class="comment">//error</span></div><div class="line">    fmt.Println(data[i++]) <span class="comment">//error</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox101231828/main.go:8: syntax error: unexpected ++ /tmp/sandbox101231828/main.go:9: syntax error: unexpected ++, expecting :</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line">    i :=<span class="number"> 0</span></div><div class="line">    i++</div><div class="line">    fmt.Println(data[i])</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="按位NOT操作">按位NOT操作</h3>
<p>许多语言使用 <code>~</code>作为一元的NOT操作符（即按位补足），但Go为了这个重用了XOR操作符（^）。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    fmt.Println(<span class="number">~2</span>) <span class="comment">//error</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox965529189/main.go:6: the bitwise complement operator is ^</p>
</blockquote>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> d <span class="typename">uint8</span> =<span class="number"> 2</span></div><div class="line">    fmt.Printf(<span class="string">"%08b\n"</span>,^d)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Go依旧使用<code>^</code>作为XOR的操作符，这可能会让一些人迷惑。</p>
<p>如果你愿意，你可以使用一个二元的XOR操作（如， 0x02 XOR 0xff）来表示一个一元的NOT操作（如，NOT 0x02）。这可以解释为什么<code>^</code>被重用来表示一元的NOT操作。</p>
<p>Go也有特殊的‘AND NOT’按位操作（<code>&amp;^</code>），这也让NOT操作更加的让人迷惑。这看起来需要特殊的特性/hack来支持 <code>A AND (NOT B)</code>，而无需括号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> a <span class="typename">uint8</span> =<span class="number"> 0</span>x82</div><div class="line">    <span class="keyword">var</span> b <span class="typename">uint8</span> =<span class="number"> 0</span>x02</div><div class="line">    fmt.Printf(<span class="string">"%08b [A]\n"</span>,a)</div><div class="line">    fmt.Printf(<span class="string">"%08b [B]\n"</span>,b)</div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"%08b (NOT B)\n"</span>,^b)</div><div class="line">    fmt.Printf(<span class="string">"%08b ^ %08b = %08b [B XOR 0xff]\n"</span>,b<span class="number">,0</span>xff,b ^<span class="number"> 0</span>xff)</div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"%08b ^ %08b = %08b [A XOR B]\n"</span>,a,b,a ^ b)</div><div class="line">    fmt.Printf(<span class="string">"%08b & %08b = %08b [A AND B]\n"</span>,a,b,a & b)</div><div class="line">    fmt.Printf(<span class="string">"%08b &^%08b = %08b [A 'AND NOT' B]\n"</span>,a,b,a &^ b)</div><div class="line">    fmt.Printf(<span class="string">"%08b&(^%08b)= %08b [A AND (NOT B)]\n"</span>,a,b,a & (^b))</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="操作优先级的差异">操作优先级的差异</h3>
<p>除了”bit clear“操作（<code>&amp;^</code>），Go也一个与许多其他语言共享的标准操作符的集合。尽管操作优先级并不总是一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    fmt.Printf(<span class="string">"0x2 & 0x2 + 0x4 -&gt; %#x\n"</span><span class="number">,0</span>x2 &<span class="number"> 0</span>x2 +<span class="number"> 0</span>x4)</div><div class="line">    <span class="comment">//prints: 0x2 & 0x2 + 0x4 -&gt; 0x6</span></div><div class="line">    <span class="comment">//Go:    (0x2 & 0x2) + 0x4</span></div><div class="line">    <span class="comment">//C++:    0x2 & (0x2 + 0x4) -&gt; 0x2</span></div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n"</span><span class="number">,0</span>x2 +<span class="number"> 0</span>x2 &lt;&lt;<span class="number"> 0</span>x1)</div><div class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></div><div class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></div><div class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"0xf | 0x2 ^ 0x2 -&gt; %#x\n"</span><span class="number">,0</span>xf |<span class="number"> 0</span>x2 ^<span class="number"> 0</span>x2)</div><div class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></div><div class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></div><div class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="未导出的结构体不会被编码">未导出的结构体不会被编码</h3>
<p>以小写字母开头的结构体将不会被（json、xml、gob等）编码，因此当你编码这些未导出的结构体时，你将会得到零值。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"encoding/json"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyData <span class="keyword">struct</span> {  </div><div class="line">    One <span class="typename">int</span></div><div class="line">    two <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    in := MyData<span class="number">{1</span>,<span class="string">"two"</span>}</div><div class="line">    fmt.Printf(<span class="string">"%#v\n"</span>,in) <span class="comment">//prints main.MyData{One:1, two:"two"}</span></div><div class="line"></div><div class="line">    encoded,_ := json.Marshal(in)</div><div class="line">    fmt.Println(<span class="typename">string</span>(encoded)) <span class="comment">//prints {"One":1}</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> out MyData</div><div class="line">    json.Unmarshal(encoded,&out)</div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"%#v\n"</span>,out) <span class="comment">//prints main.MyData{One:1, two:""}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="有活动的Goroutines下的应用退出">有活动的Goroutines下的应用退出</h3>
<p>应用将不会等待所有的goroutines完成。这对于初学者而言是个很常见的错误。每个人都是以某个程度开始，因此如果犯了初学者的错误也没神马好丢脸的 :-)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    workerCount :=<span class="number"> 2</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; workerCount; i++ {</div><div class="line">        <span class="keyword">go</span> doit(i)</div><div class="line">    }</div><div class="line">    time.Sleep<span class="number">(1</span> * time.Second)</div><div class="line">    fmt.Println(<span class="string">"all done!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> doit(workerId <span class="typename">int</span>) {  </div><div class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你将会看到：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>] <span class="keyword">is</span> <span class="property">running</span> </div><div class="line">[<span class="number">1</span>] <span class="keyword">is</span> <span class="property">running</span> </div><div class="line">all done!</div></pre></td></tr></table></figure>

<p>一个最常见的解决方法是使用“WaitGroup”变量。它将会让主goroutine等待所有的worker goroutine完成。如果你的应用有长时运行的消息处理循环的worker，你也将需要一个方法向这些goroutine发送信号，让它们退出。你可以给各个worker发送一个“kill”消息。另一个选项是关闭一个所有worker都接收的channel。这是一次向所有goroutine发送信号的简单方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">    workerCount :=<span class="number"> 2</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; workerCount; i++ {</div><div class="line">        wg.Add<span class="number">(1</span>)</div><div class="line">        <span class="keyword">go</span> doit(i,done,wg)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">close</span>(done)</div><div class="line">    wg.Wait()</div><div class="line">    fmt.Println(<span class="string">"all done!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> doit(workerId <span class="typename">int</span>,done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{},wg sync.WaitGroup) {  </div><div class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</div><div class="line">    <span class="keyword">defer</span> wg.Done()</div><div class="line">    &lt;- done</div><div class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你运行这个应用，你将会看到：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>] <span class="keyword">is</span> <span class="property">running</span> </div><div class="line">[<span class="number">0</span>] <span class="keyword">is</span> done </div><div class="line">[<span class="number">1</span>] <span class="keyword">is</span> <span class="property">running</span> </div><div class="line">[<span class="number">1</span>] <span class="keyword">is</span> done</div></pre></td></tr></table></figure>

<p>看起来所有的worker在主goroutine退出前都完成了。棒！然而，你也将会看到这个：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">fatal</span> <span class="built_in">error</span>: all goroutines are asleep - deadlock!</div></pre></td></tr></table></figure>

<p>这可不太好 :-) 发送了神马？为什么会出现死锁？worker退出了，它们也执行了<code>wg.Done()</code>。应用应该没问题啊。</p>
<p>死锁发生是因为各个worker都得到了原始的“WaitGroup”变量的一个拷贝。当worker执行<code>wg.Done()</code>时，并没有在主goroutine上的“WaitGroup”变量上生效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">    wq := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">    workerCount :=<span class="number"> 2</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; workerCount; i++ {</div><div class="line">        wg.Add<span class="number">(1</span>)</div><div class="line">        <span class="keyword">go</span> doit(i,wq,done,&wg)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; workerCount; i++ {</div><div class="line">        wq &lt;- i</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">close</span>(done)</div><div class="line">    wg.Wait()</div><div class="line">    fmt.Println(<span class="string">"all done!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> doit(workerId <span class="typename">int</span>, wq &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{},done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{},wg *sync.WaitGroup) {  </div><div class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>,workerId)</div><div class="line">    <span class="keyword">defer</span> wg.Done()</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> m := &lt;- wq:</div><div class="line">            fmt.Printf(<span class="string">"[%v] m =&gt; %v\n"</span>,workerId,m)</div><div class="line">        <span class="keyword">case</span> &lt;- done:</div><div class="line">            fmt.Printf(<span class="string">"[%v] is done\n"</span>,workerId)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在它会如预期般工作 :-)</p>
<h3 id="向无缓存的Channel发送消息，只要目标接收者准备好就会立即返回">向无缓存的Channel发送消息，只要目标接收者准备好就会立即返回</h3>
<p>发送者将不会被阻塞，除非消息正在被接收者处理。根据你运行代码的机器的不同，接收者的goroutine可能会或者不会有足够的时间，在发送者继续执行前处理消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch {</div><div class="line">            fmt.Println(<span class="string">"processed:"</span>,m)</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">    ch &lt;- <span class="string">"cmd.1"</span></div><div class="line">    ch &lt;- <span class="string">"cmd.2"</span> <span class="comment">//won't be processed</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="向已关闭的Channel发送会引起Panic">向已关闭的Channel发送会引起Panic</h3>
<p>从一个关闭的channel接收是安全的。在接收状态下的<code>ok</code>的返回值将被设置为<code>false</code>，这意味着没有数据被接收。如果你从一个有缓存的channel接收，你将会首先得到缓存的数据，一旦它为空，返回的<code>ok</code>值将变为<code>false</code>。</p>
<p>向关闭的channel中发送数据会引起panic。这个行为有文档说明，但对于新的Go开发者的直觉不同，他们可能希望发送行为与接收行为很像。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>(idx <span class="typename">int</span>) {</div><div class="line">            ch &lt;- (idx +<span class="number"> 1</span>) *<span class="number"> 2</span></div><div class="line">        }(i)</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">//get the first result</span></div><div class="line">    fmt.Println(&lt;-ch)</div><div class="line">    <span class="built_in">close</span>(ch) <span class="comment">//not ok (you still have other senders)</span></div><div class="line">    <span class="comment">//do other work</span></div><div class="line">    time.Sleep<span class="number">(2</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>根据不同的应用，修复方法也将不同。可能是很小的代码修改，也可能需要修改应用的设计。无论是哪种方法，你都需要确保你的应用不会向关闭的channel中发送数据。</p>
<p>上面那个有bug的例子可以通过使用一个特殊的废弃的channel来向剩余的worker发送不再需要它们的结果的信号来修复。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>(idx <span class="typename">int</span>) {</div><div class="line">            <span class="keyword">select</span> {</div><div class="line">            <span class="keyword">case</span> ch &lt;- (idx +<span class="number"> 1</span>) *<span class="number"> 2</span>: fmt.Println(idx,<span class="string">"sent result"</span>)</div><div class="line">            <span class="keyword">case</span> &lt;- done: fmt.Println(idx,<span class="string">"exiting"</span>)</div><div class="line">            }</div><div class="line">        }(i)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//get first result</span></div><div class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</div><div class="line">    <span class="built_in">close</span>(done)</div><div class="line">    <span class="comment">//do other work</span></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用&quot;nil&quot;_Channels">使用&quot;nil&quot; Channels</h3>
<p>在一个<code>nil</code>的channel上发送和接收操作会被永久阻塞。这个行为有详细的文档解释，但它对于新的Go开发者而言是个惊喜。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="typename">int</span></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>(idx <span class="typename">int</span>) {</div><div class="line">            ch &lt;- (idx +<span class="number"> 1</span>) *<span class="number"> 2</span></div><div class="line">        }(i)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//get first result</span></div><div class="line">    fmt.Println(<span class="string">"result:"</span>,&lt;-ch)</div><div class="line">    <span class="comment">//do other work</span></div><div class="line">    time.Sleep<span class="number">(2</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果运行代码你将会看到一个runtime错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">fatal</span> <span class="built_in">error</span>: all goroutines are asleep - deadlock!</div></pre></td></tr></table></figure>

<p>这个行为可以在<code>select</code>声明中用于动态开启和关闭<code>case</code>代码块的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  </div><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    inch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line">    outch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        <span class="keyword">var</span> in &lt;- <span class="keyword">chan</span> <span class="typename">int</span> = inch</div><div class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span> &lt;- <span class="typename">int</span></div><div class="line">        <span class="keyword">var</span> val <span class="typename">int</span></div><div class="line">        <span class="keyword">for</span> {</div><div class="line">           <span class="keyword">select</span> {</div><div class="line">            <span class="keyword">case</span> out &lt;- val:</div><div class="line">                out = <span class="constant">nil</span></div><div class="line">                in = inch</div><div class="line">            <span class="keyword">case</span> val = &lt;- in:</div><div class="line">                out = outch</div><div class="line">                in = <span class="constant">nil</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outch {</div><div class="line">            fmt.Println(<span class="string">"result:"</span>,r)</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(0</span>)</div><div class="line">    inch &lt;-<span class="number"> 1</span></div><div class="line">    inch &lt;-<span class="number"> 2</span></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="传值方法的接收者无法修改原有的值">传值方法的接收者无法修改原有的值</h3>
<p>方法的接收者就像常规的函数参数。如果声明为值，那么你的函数/方法得到的是接收者参数的拷贝。这意味着对接收者所做的修改将不会影响原有的值，除非接收者是一个map或者slice变量，而你更新了集合中的元素，或者你更新的域的接收者是指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    num <span class="typename">int</span></div><div class="line">    key *<span class="typename">string</span></div><div class="line">    items <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (this *data) pmethod() {  </div><div class="line">    this.num =<span class="number"> 7</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (this data) vmethod() {  </div><div class="line">    this.num =<span class="number"> 8</span></div><div class="line">    *this.key = <span class="string">"v.key"</span></div><div class="line">    this.items[<span class="string">"vmethod"</span>] = <span class="constant">true</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    key := <span class="string">"key.1"</span></div><div class="line">    d := data<span class="number">{1</span>,&key,<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">bool</span>)}</div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items)</div><div class="line">    <span class="comment">//prints num=1 key=key.1 items=map[]</span></div><div class="line"></div><div class="line">    d.pmethod()</div><div class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items) </div><div class="line">    <span class="comment">//prints num=7 key=key.1 items=map[]</span></div><div class="line"></div><div class="line">    d.vmethod()</div><div class="line">    fmt.Printf(<span class="string">"num=%v key=%v items=%v\n"</span>,d.num,*d.key,d.items)</div><div class="line">    <span class="comment">//prints num=7 key=v.key items=map[vmethod:true]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="中级">中级</h2>
<h3 id="关闭HTTP的响应">关闭HTTP的响应</h3>
<p>当你使用标准http库发起请求时，你得到一个http的响应变量。如果你不读取响应主体，你依旧需要关闭它。注意对于空的响应你也一定要这么做。对于新的Go开发者而言，这个很容易就会忘掉。</p>
<p>一些新的Go开发者确实尝试关闭响应主体，但他们在错误的地方做。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</div><div class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//not ok</span></div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="typename">string</span>(body))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码对于成功的请求没问题，但如果http的请求失败，<code>resp</code>变量可能会是<code>nil</code>，这将导致一个<code>runtime panic</code>。</p>
<p>最常见的关闭响应主体的方法是在http响应的错误检查后调用<code>defer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//ok, most of the time :-)</span></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="typename">string</span>(body))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大多数情况下，当你的http响应失败时，<code>resp</code>变量将为<code>nil</code>，而<code>err</code>变量将是<code>non-nil</code>。然而，当你得到一个重定向的错误时，两个变量都将是<code>non-nil</code>。这意味着你最后依然会内存泄露。</p>
<p>通过在http响应错误处理中添加一个关闭<code>non-nil</code>响应主体的的调用来修复这个问题。另一个方法是使用一个<code>defer</code>调用来关闭所有失败和成功的请求的响应主体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    resp, err := http.Get(<span class="string">"https://api.ipify.org?format=json"</span>)</div><div class="line">    <span class="keyword">if</span> resp != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">defer</span> resp.Body.Close()</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="typename">string</span>(body))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>resp.Body.Close()</code>的原始实现也会读取并丢弃剩余的响应主体数据。这确保了http的链接在keepalive http连接行为开启的情况下，可以被另一个请求复用。最新的http客户端的行为是不同的。现在读取并丢弃剩余的响应数据是你的职责。如果你不这么做，http的连接可能会关闭，而无法被重用。这个小技巧应该会写在Go 1.5的文档中。</p>
<p>如果http连接的重用对你的应用很重要，你可能需要在响应处理逻辑的后面添加像下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">_, err </span>=<span class="string"> io.Copy(ioutil.Discard, resp.Body)</span></div></pre></td></tr></table></figure>

<p>如果你不立即读取整个响应将是必要的，这可能在你处理json API响应时会发生：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">json</span>.<span class="type">NewDecoder</span>(resp.<span class="type">Body</span>).<span class="type">Decode</span>(&<span class="typedef"><span class="keyword">data</span>)</span></div></pre></td></tr></table></figure>

<h3 id="关闭HTTP的连接">关闭HTTP的连接</h3>
<p>一些HTTP服务器保持会保持一段时间的网络连接（根据HTTP 1.1的说明和服务器端的“keep-alive”配置）。默认情况下，标准http库只在目标HTTP服务器要求关闭时才会关闭网络连接。这意味着你的应用在某些条件下消耗完sockets/file的描述符。</p>
<p>你可以通过设置请求变量中的<code>Close</code>域的值为<code>true</code>，来让http库在请求完成时关闭连接。</p>
<p>另一个选项是添加一个<code>Connection</code>的请求头，并设置为<code>close</code>。目标HTTP服务器应该也会响应一个<code>Connection: close</code>的头。当http库看到这个响应头时，它也将会关闭连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>,<span class="string">"http://golang.org"</span>,<span class="constant">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    req.Close = <span class="constant">true</span></div><div class="line">    <span class="comment">//or do this:</span></div><div class="line">    <span class="comment">//req.Header.Add("Connection", "close")</span></div><div class="line"></div><div class="line">    resp, err := http.DefaultClient.Do(req)</div><div class="line">    <span class="keyword">if</span> resp != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">defer</span> resp.Body.Close()</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="built_in">len</span>(<span class="typename">string</span>(body)))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也可以取消http的全局连接复用。你将需要为此创建一个自定义的http传输配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    tr := &http.Transport{DisableKeepAlives: <span class="constant">true</span>}</div><div class="line">    client := &http.Client{Transport: tr}</div><div class="line"></div><div class="line">    resp, err := client.Get(<span class="string">"http://golang.org"</span>)</div><div class="line">    <span class="keyword">if</span> resp != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">defer</span> resp.Body.Close()</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(resp.StatusCode)</div><div class="line"></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="built_in">len</span>(<span class="typename">string</span>(body)))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你向同一个HTTP服务器发送大量的请求，那么把保持网络连接的打开是没问题的。然而，如果你的应用在短时间内向大量不同的HTTP服务器发送一两个请求，那么在引用收到响应后立刻关闭网络连接是一个好主意。增加打开文件的限制数可能也是个好主意。当然，正确的选择源自于应用。</p>
<h3 id="比较Structs,_Arrays,_Slices,_and_Maps">比较Structs, Arrays, Slices, and Maps</h3>
<p>如果结构体中的各个元素都可以用你可以使用等号来比较的话，那就可以使用相号, ==，来比较结构体变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    num <span class="typename">int</span></div><div class="line">    fp <span class="typename">float32</span></div><div class="line">    <span class="built_in">complex</span> <span class="typename">complex64</span></div><div class="line">    str <span class="typename">string</span></div><div class="line">    char <span class="typename">rune</span></div><div class="line">    yes <span class="typename">bool</span></div><div class="line">    events &lt;-<span class="keyword">chan</span> <span class="typename">string</span></div><div class="line">    handler <span class="keyword">interface</span>{}</div><div class="line">    ref *<span class="typename">byte</span></div><div class="line">    raw <span class="number">[10</span>]<span class="typename">byte</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    v1 := data{}</div><div class="line">    v2 := data{}</div><div class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,v1 == v2) <span class="comment">//prints: v1 == v2: true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果结构体中的元素无法比较，那使用等号将导致编译错误。注意数组仅在它们的数据元素可比较的情况下才可以比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    num <span class="typename">int</span>                <span class="comment">//ok</span></div><div class="line">    checks <span class="number">[10</span>]<span class="keyword">func</span>() <span class="typename">bool</span> <span class="comment">//not comparable</span></div><div class="line">    doit <span class="keyword">func</span>() <span class="typename">bool</span>       <span class="comment">//not comparable</span></div><div class="line">    m <span class="keyword">map</span>[<span class="typename">string</span>] <span class="typename">string</span>   <span class="comment">//not comparable</span></div><div class="line">    bytes []<span class="typename">byte</span>           <span class="comment">//not comparable</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    v1 := data{}</div><div class="line">    v2 := data{}</div><div class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,v1 == v2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Go确实提供了一些助手函数，用于比较那些无法使用等号比较的变量。</p>
<p>最常用的方法是使用reflect包中的<code>DeepEqual()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    num <span class="typename">int</span>                <span class="comment">//ok</span></div><div class="line">    checks <span class="number">[10</span>]<span class="keyword">func</span>() <span class="typename">bool</span> <span class="comment">//not comparable</span></div><div class="line">    doit <span class="keyword">func</span>() <span class="typename">bool</span>       <span class="comment">//not comparable</span></div><div class="line">    m <span class="keyword">map</span>[<span class="typename">string</span>] <span class="typename">string</span>   <span class="comment">//not comparable</span></div><div class="line">    bytes []<span class="typename">byte</span>           <span class="comment">//not comparable</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    v1 := data{}</div><div class="line">    v2 := data{}</div><div class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,reflect.DeepEqual(v1,v2)) <span class="comment">//prints: v1 == v2: true</span></div><div class="line"></div><div class="line">    m1 := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">string</span>{<span class="string">"one"</span>: <span class="string">"a"</span>,<span class="string">"two"</span>: <span class="string">"b"</span>}</div><div class="line">    m2 := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">string</span>{<span class="string">"two"</span>: <span class="string">"b"</span>, <span class="string">"one"</span>: <span class="string">"a"</span>}</div><div class="line">    fmt.Println(<span class="string">"m1 == m2:"</span>,reflect.DeepEqual(m1, m2)) <span class="comment">//prints: m1 == m2: true</span></div><div class="line"></div><div class="line">    s1 := []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">    s2 := []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">    fmt.Println(<span class="string">"s1 == s2:"</span>,reflect.DeepEqual(s1, s2)) <span class="comment">//prints: s1 == s2: true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了很慢（这个可能会也可能不会影响你的应用），<code>DeepEqual()</code>也有其他自身的技巧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> b1 []<span class="typename">byte</span> = <span class="constant">nil</span></div><div class="line">    b2 := []<span class="typename">byte</span>{}</div><div class="line">    fmt.Println(<span class="string">"b1 == b2:"</span>,reflect.DeepEqual(b1, b2)) <span class="comment">//prints: b1 == b2: false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>DeepEqual()</code>不会认为空的<code>slice</code>与“nil”的<code>slice</code>相等。这个行为与你使用<code>bytes.Equal()</code>函数的行为不同。<code>bytes.Equal()</code>认为“nil”和空的slice是相等的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"bytes"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> b1 []<span class="typename">byte</span> = <span class="constant">nil</span></div><div class="line">    b2 := []<span class="typename">byte</span>{}</div><div class="line">    fmt.Println(<span class="string">"b1 == b2:"</span>,bytes.Equal(b1, b2)) <span class="comment">//prints: b1 == b2: true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>DeepEqual()</code>在比较slice时并不总是完美的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">    <span class="string">"encoding/json"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> str <span class="typename">string</span> = <span class="string">"one"</span></div><div class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>{} = <span class="string">"one"</span></div><div class="line">    fmt.Println(<span class="string">"str == in:"</span>,str == in,reflect.DeepEqual(str, in)) </div><div class="line">    <span class="comment">//prints: str == in: true true</span></div><div class="line"></div><div class="line">    v1 := []<span class="typename">string</span>{<span class="string">"one"</span>,<span class="string">"two"</span>}</div><div class="line">    v2 := []<span class="keyword">interface</span>{}{<span class="string">"one"</span>,<span class="string">"two"</span>}</div><div class="line">    fmt.Println(<span class="string">"v1 == v2:"</span>,reflect.DeepEqual(v1, v2)) </div><div class="line">    <span class="comment">//prints: v1 == v2: false (not ok)</span></div><div class="line"></div><div class="line">    data := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}{</div><div class="line">        <span class="string">"code"</span>:<span class="number"> 200</span>,</div><div class="line">        <span class="string">"value"</span>: []<span class="typename">string</span>{<span class="string">"one"</span>,<span class="string">"two"</span>},</div><div class="line">    }</div><div class="line">    encoded, _ := json.Marshal(data)</div><div class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}</div><div class="line">    json.Unmarshal(encoded, &decoded)</div><div class="line">    fmt.Println(<span class="string">"data == decoded:"</span>,reflect.DeepEqual(data, decoded)) </div><div class="line">    <span class="comment">//prints: data == decoded: false (not ok)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你的<code>byte slice</code>（或者字符串）中包含文字数据，而当你要不区分大小写形式的值时（在使用<code>==</code>，<code>bytes.Equal()</code>，或者<code>bytes.Compare()</code>），你可能会尝试使用“bytes”和“string”包中的<code>ToUpper()</code>或者<code>ToLower()</code>函数。对于英语文本，这么做是没问题的，但对于许多其他的语言来说就不行了。这时应该使用<code>strings.EqualFold()</code>和<code>bytes.EqualFold()</code>。</p>
<p>如果你的byte slice中包含需要验证用户数据的隐私信息（比如，加密哈希、tokens等），不要使用<code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>，或者<code>bytes.Compare()</code>，因为这些函数将会让你的应用易于被定时攻击。为了避免泄露时间信息，使用&#39;crypto/subtle&#39;包中的函数（即，<code>subtle.ConstantTimeCompare()</code>）。</p>
<h3 id="从Panic中恢复">从Panic中恢复</h3>
<p><code>recover()</code>函数可以用于获取/拦截<code>panic</code>。仅当在一个<code>defer</code>函数中被完成时，调用<code>recover()</code>将会完成这个小技巧。</p>
<p>Incorrect:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="built_in">recover</span>() <span class="comment">//doesn't do anything</span></div><div class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</div><div class="line">    <span class="built_in">recover</span>() <span class="comment">//won't be executed :)</span></div><div class="line">    fmt.Println(<span class="string">"ok"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">        fmt.Println(<span class="string">"recovered:"</span>,<span class="built_in">recover</span>())</div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>recover()</code>的调用仅当它在<code>defer</code>函数中被直接调用时才有效。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> doRecover() {  </div><div class="line">    fmt.Println(<span class="string">"recovered =&gt;"</span>,<span class="built_in">recover</span>()) <span class="comment">//prints: recovered =&gt; &lt;nil&gt;</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">        doRecover() <span class="comment">//panic is not recovered</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="在Slice,_Array,_and_Map_&quot;range&quot;语句中更新引用元素的值">在Slice, Array, and Map &quot;range&quot;语句中更新引用元素的值</h3>
<p>在“range”语句中生成的数据的值是真实集合元素的拷贝。它们不是原有元素的引用。<br>这意味着更新这些值将不会修改原来的数据。同时也意味着使用这些值的地址将不会得到原有数据的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        v *=<span class="number"> 10</span> <span class="comment">//original item is not changed</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"data:"</span>,data) <span class="comment">//prints data: [1 2 3]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你需要更新原有集合中的数据，使用索引操作符来获得数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line">    <span class="keyword">for</span> i,_ := <span class="keyword">range</span> data {</div><div class="line">        data[i] *=<span class="number"> 10</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"data:"</span>,data) <span class="comment">//prints data: [10 20 30]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你的集合保存的是指针，那规则会稍有不同。<br>如果要更新原有记录指向的数据，你依然需要使用索引操作，但你可以使用for range语句中的第二个值来更新存储在目标位置的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []*<span class="keyword">struct</span>{num <span class="typename">int</span>} { <span class="number">{1</span>},<span class="number">{2</span>},<span class="number">{3</span>} }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        v.num *=<span class="number"> 10</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(data<span class="number">[0</span>],data<span class="number">[1</span>],data<span class="number">[2</span>]) <span class="comment">//prints &{10} &{20} &{30}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="在Slice中&quot;隐藏&quot;数据">在Slice中&quot;隐藏&quot;数据</h3>
<p>当你重新划分一个slice时，新的slice将引用原有slice的数组。如果你忘了这个行为的话，在你的应用分配大量临时的slice用于创建新的slice来引用原有数据的一小部分时，会导致难以预期的内存使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> get() []<span class="typename">byte</span> {  </div><div class="line">    raw := <span class="built_in">make</span>([]<span class="typename">byte</span><span class="number">,10000</span>)</div><div class="line">    fmt.Println(<span class="built_in">len</span>(raw),<span class="built_in">cap</span>(raw),&raw<span class="number">[0</span>]) <span class="comment">//prints: 10000 10000 &lt;byte_addr_x&gt;</span></div><div class="line">    <span class="keyword">return</span> raw[<span class="number">:3</span>]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := get()</div><div class="line">    fmt.Println(<span class="built_in">len</span>(data),<span class="built_in">cap</span>(data),&data<span class="number">[0</span>]) <span class="comment">//prints: 3 10000 &lt;byte_addr_x&gt;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了避免这个陷阱，你需要从临时的slice中拷贝数据（而不是重新划分slice）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> get() []<span class="typename">byte</span> {  </div><div class="line">    raw := <span class="built_in">make</span>([]<span class="typename">byte</span><span class="number">,10000</span>)</div><div class="line">    fmt.Println(<span class="built_in">len</span>(raw),<span class="built_in">cap</span>(raw),&raw<span class="number">[0</span>]) <span class="comment">//prints: 10000 10000 &lt;byte_addr_x&gt;</span></div><div class="line">    res := <span class="built_in">make</span>([]<span class="typename">byte</span><span class="number">,3</span>)</div><div class="line">    <span class="built_in">copy</span>(res,raw[<span class="number">:3</span>])</div><div class="line">    <span class="keyword">return</span> res</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := get()</div><div class="line">    fmt.Println(<span class="built_in">len</span>(data),<span class="built_in">cap</span>(data),&data<span class="number">[0</span>]) <span class="comment">//prints: 3 3 &lt;byte_addr_y&gt;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Slice的数据“毁坏”">Slice的数据“毁坏”</h3>
<p>比如说你需要重新一个路径（在slice中保存）。你通过修改第一个文件夹的名字，然后把名字合并来创建新的路劲，来重新划分指向各个文件夹的路径。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"bytes"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    path := []<span class="typename">byte</span>(<span class="string">"AAAA/BBBBBBBBB"</span>)</div><div class="line">    sepIndex := bytes.IndexByte(path,<span class="string">'/'</span>)</div><div class="line">    dir1 := path[:sepIndex]</div><div class="line">    dir2 := path[sepIndex<span class="number">+1</span>:]</div><div class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="typename">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></div><div class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="typename">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></div><div class="line"></div><div class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">"suffix"</span>...)</div><div class="line">    path = bytes.Join([][]<span class="typename">byte</span>{dir1,dir2},[]<span class="typename">byte</span>{<span class="string">'/'</span>})</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="typename">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></div><div class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="typename">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; uffixBBBB (not ok)</span></div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"new path =&gt;"</span>,<span class="typename">string</span>(path))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>结果与你想的不一样。与&quot;AAAAsuffix/BBBBBBBBB&quot;相反，你将会得到&quot;AAAAsuffix/uffixBBBB&quot;。这个情况的发生是因为两个文件夹的slice都潜在的引用了同一个原始的路径slice。这意味着原始路径也被修改了。根据你的应用，这也许会是个问题。</p>
<p>通过分配新的slice并拷贝需要的数据，你可以修复这个问题。另一个选择是使用完整的slice表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"bytes"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    path := []<span class="typename">byte</span>(<span class="string">"AAAA/BBBBBBBBB"</span>)</div><div class="line">    sepIndex := bytes.IndexByte(path,<span class="string">'/'</span>)</div><div class="line">    dir1 := path[:sepIndex:sepIndex] <span class="comment">//full slice expression</span></div><div class="line">    dir2 := path[sepIndex<span class="number">+1</span>:]</div><div class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="typename">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAA</span></div><div class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="typename">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB</span></div><div class="line"></div><div class="line">    dir1 = <span class="built_in">append</span>(dir1,<span class="string">"suffix"</span>...)</div><div class="line">    path = bytes.Join([][]<span class="typename">byte</span>{dir1,dir2},[]<span class="typename">byte</span>{<span class="string">'/'</span>})</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"dir1 =&gt;"</span>,<span class="typename">string</span>(dir1)) <span class="comment">//prints: dir1 =&gt; AAAAsuffix</span></div><div class="line">    fmt.Println(<span class="string">"dir2 =&gt;"</span>,<span class="typename">string</span>(dir2)) <span class="comment">//prints: dir2 =&gt; BBBBBBBBB (ok now)</span></div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"new path =&gt;"</span>,<span class="typename">string</span>(path))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>完整的slice表达式中的额外参数可以控制新的slice的容量。现在在那个slice后添加元素将会触发一个新的buffer分配，而不是覆盖第二个slice中的数据。</p>
<h3 id="陈旧的(Stale)Slices">陈旧的(Stale)Slices</h3>
<p>多个slice可以引用同一个数据。比如，当你从一个已有的slice创建一个新的slice时，这就会发生。如果你的应用功能需要这种行为，那么你将需要关注下“走味的”slice。</p>
<p>在某些情况下，在一个slice中添加新的数据，在原有数组无法保持更多新的数据时，将导致分配一个新的数组。而现在其他的slice还指向老的数组（和老的数据）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    s1 := []<span class="typename">int</span><span class="number">{1</span><span class="number">,2</span><span class="number">,3</span>}</div><div class="line">    fmt.Println(<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1),s1) <span class="comment">//prints 3 3 [1 2 3]</span></div><div class="line"></div><div class="line">    s2 := s1<span class="number">[1</span>:]</div><div class="line">    fmt.Println(<span class="built_in">len</span>(s2),<span class="built_in">cap</span>(s2),s2) <span class="comment">//prints 2 2 [2 3]</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 { s2[i] +=<span class="number"> 20</span> }</div><div class="line"></div><div class="line">    <span class="comment">//still referencing the same array</span></div><div class="line">    fmt.Println(s1) <span class="comment">//prints [1 22 23]</span></div><div class="line">    fmt.Println(s2) <span class="comment">//prints [22 23]</span></div><div class="line"></div><div class="line">    s2 = <span class="built_in">append</span>(s2<span class="number">,4</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 { s2[i] +=<span class="number"> 10</span> }</div><div class="line"></div><div class="line">    <span class="comment">//s1 is now "stale"</span></div><div class="line">    fmt.Println(s1) <span class="comment">//prints [1 22 23]</span></div><div class="line">    fmt.Println(s2) <span class="comment">//prints [32 33 14]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="类型声明和方法">类型声明和方法</h3>
<p>当你通过把一个现有（非interface）的类型定义为一个新的类型时，新的类型不会继承现有类型的方法。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"sync"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> myMutex sync.Mutex</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> mtx myMutex</div><div class="line">    mtx.Lock() <span class="comment">//error</span></div><div class="line">    mtx.Unlock() <span class="comment">//error  </span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox106401185/main.go:9: mtx.Lock undefined (type myMutex has no field or method Lock) /tmp/sandbox106401185/main.go:10: mtx.Unlock undefined (type myMutex has no field or method Unlock)</p>
</blockquote>
<p>如果你确实需要原有类型的方法，你可以定义一个新的struct类型，用匿名方式把原有类型嵌入其中。</p>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"sync"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> {  </div><div class="line">    sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> lock myLocker</div><div class="line">    lock.Lock() <span class="comment">//ok</span></div><div class="line">    lock.Unlock() <span class="comment">//ok</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>interface类型的声明也会保留它们的方法集合。<br>Works: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"sync"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> myLocker sync.Locker</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> lock myLocker = <span class="built_in">new</span>(sync.Mutex)</div><div class="line">    lock.Lock() <span class="comment">//ok</span></div><div class="line">    lock.Unlock() <span class="comment">//ok</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="从&quot;for_switch&quot;和&quot;for_select&quot;代码块中跳出">从&quot;for switch&quot;和&quot;for select&quot;代码块中跳出</h3>
<p>没有标签的“break”声明只能从内部的switch/select代码块中跳出来。如果无法使用“return”声明的话，那就为外部循环定义一个标签是另一个好的选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    loop:</div><div class="line">        <span class="keyword">for</span> {</div><div class="line">            <span class="keyword">switch</span> {</div><div class="line">            <span class="keyword">case</span> <span class="constant">true</span>:</div><div class="line">                fmt.Println(<span class="string">"breaking out..."</span>)</div><div class="line">                <span class="keyword">break</span> loop</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"out!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>&quot;goto&quot;声明也可以完成这个功能。。。</p>
<h3 id="&quot;for&quot;声明中的迭代变量和闭包">&quot;for&quot;声明中的迭代变量和闭包</h3>
<p>这在Go中是个很常见的技巧。for语句中的迭代变量在每次迭代时被重新使用。这就意味着你在for循环中创建的闭包（即函数字面量）将会引用同一个变量（而在那些goroutine开始执行时就会得到那个变量的值）。</p>
<p>Incorrect:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">string</span>{<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">            fmt.Println(v)</div><div class="line">        }()</div><div class="line">    }</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">    <span class="comment">//goroutines print: three, three, three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>最简单的解决方法（不需要修改goroutine）是，在for循环代码块内把当前迭代的变量值保存到一个局部变量中。</p>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">string</span>{<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        vcopy := v <span class="comment">//</span></div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">            fmt.Println(vcopy)</div><div class="line">        }()</div><div class="line">    }</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">    <span class="comment">//goroutines print: one, two, three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个解决方法是把当前的迭代变量作为匿名goroutine的参数。</p>
<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []<span class="typename">string</span>{<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>}</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>(in <span class="typename">string</span>) {</div><div class="line">            fmt.Println(in)</div><div class="line">        }(v)</div><div class="line">    }</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">    <span class="comment">//goroutines print: one, two, three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面这个陷阱稍微复杂一些的版本。</p>
<p>Incorrect:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *field) <span class="built_in">print</span>() {  </div><div class="line">    fmt.Println(p.name)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []field{ {<span class="string">"one"</span>},{<span class="string">"two"</span>},{<span class="string">"three"</span>} }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</div><div class="line">    }</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">    <span class="comment">//goroutines print: three, three, three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *field) <span class="built_in">print</span>() {  </div><div class="line">    fmt.Println(p.name)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []field{ {<span class="string">"one"</span>},{<span class="string">"two"</span>},{<span class="string">"three"</span>} }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        v := v</div><div class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</div><div class="line">    }</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">    <span class="comment">//goroutines print: one, two, three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在运行这段代码时你认为会看到什么结果？（原因是什么？）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *field) <span class="built_in">print</span>() {  </div><div class="line">    fmt.Println(p.name)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    data := []*field{ {<span class="string">"one"</span>},{<span class="string">"two"</span>},{<span class="string">"three"</span>} }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> data {</div><div class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</div><div class="line">    }</div><div class="line"></div><div class="line">    time.Sleep<span class="number">(3</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Defer函数调用参数的求值">Defer函数调用参数的求值</h3>
<p>被<code>defer</code>的函数的参数会在<code>defer</code>声明时求值（而不是在函数实际执行时）。<br>Arguments for a deferred function call are evaluated when the defer statement is evaluated (not when the function is actually executing).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> i <span class="typename">int</span> =<span class="number"> 1</span></div><div class="line"></div><div class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"result =&gt;"</span>,<span class="keyword">func</span>() <span class="typename">int</span> { <span class="keyword">return</span> i *<span class="number"> 2</span> }())</div><div class="line">    i++</div><div class="line">    <span class="comment">//prints: result =&gt; 2 (not ok if you expected 4)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="被Defer的函数调用执行">被Defer的函数调用执行</h3>
<p>被defer的调用会在包含的函数的末尾执行，而不是包含代码块的末尾。对于Go新手而言，一个很常犯的错误就是无法区分被defer的代码执行规则和变量作用规则。如果你有一个长时运行的函数，而函数内有一个for循环试图在每次迭代时都defer资源清理调用，那就会出现问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"path/filepath"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) !=<span class="number"> 2</span> {</div><div class="line">        os.Exit<span class="number">(-1</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    start, err := os.Stat(os.Args<span class="number">[1</span>])</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> || !start.IsDir(){</div><div class="line">        os.Exit<span class="number">(-1</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">var</span> targets []<span class="typename">string</span></div><div class="line">    filepath.Walk(os.Args<span class="number">[1</span>], <span class="keyword">func</span>(fpath <span class="typename">string</span>, fi os.FileInfo, err error) error {</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> !fi.Mode().IsRegular() {</div><div class="line">            <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">        }</div><div class="line"></div><div class="line">        targets = <span class="built_in">append</span>(targets,fpath)</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">    })</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,target := <span class="keyword">range</span> targets {</div><div class="line">        f, err := os.Open(target)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            fmt.Println(<span class="string">"bad target:"</span>,target,<span class="string">"error:"</span>,err) <span class="comment">//prints error: too many open files</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">        }</div><div class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">//will not be closed at the end of this code block</span></div><div class="line">        <span class="comment">//do something with the file...</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>解决这个问题的一个方法是把代码块写成一个函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"path/filepath"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) !=<span class="number"> 2</span> {</div><div class="line">        os.Exit<span class="number">(-1</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    start, err := os.Stat(os.Args<span class="number">[1</span>])</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> || !start.IsDir(){</div><div class="line">        os.Exit<span class="number">(-1</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">var</span> targets []<span class="typename">string</span></div><div class="line">    filepath.Walk(os.Args<span class="number">[1</span>], <span class="keyword">func</span>(fpath <span class="typename">string</span>, fi os.FileInfo, err error) error {</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> !fi.Mode().IsRegular() {</div><div class="line">            <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">        }</div><div class="line"></div><div class="line">        targets = <span class="built_in">append</span>(targets,fpath)</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">    })</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _,target := <span class="keyword">range</span> targets {</div><div class="line">        <span class="keyword">func</span>() {</div><div class="line">            f, err := os.Open(target)</div><div class="line">            <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                fmt.Println(<span class="string">"bad target:"</span>,target,<span class="string">"error:"</span>,err)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">//ok</span></div><div class="line">            <span class="comment">//do something with the file...</span></div><div class="line">        }()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个方法是去掉<code>defer</code>语句 :-)</p>
<h3 id="失败的类型断言">失败的类型断言</h3>
<p>失败的类型断言返回断言声明中使用的目标类型的“零值”。这在与隐藏变量混合时，会发生未知情况。</p>
<p>Incorrect:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line">func main() {  </div><div class="line">    <span class="built_in">var</span> <span class="built_in">data</span> interface{} <span class="subst">=</span> <span class="string">"great"</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">data</span>, ok <span class="subst">:=</span> <span class="built_in">data</span><span class="built_in">.</span>(int); ok {</div><div class="line">        fmt<span class="built_in">.</span>Println(<span class="string">"[is an int] value =&gt;"</span>,<span class="built_in">data</span>)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        fmt<span class="built_in">.</span>Println(<span class="string">"[not an int] value =&gt;"</span>,<span class="built_in">data</span>) </div><div class="line">        <span class="comment">//prints: [not an int] value =&gt; 0 (not "great")</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>{} = <span class="string">"great"</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> res, ok := data.(<span class="typename">int</span>); ok {</div><div class="line">        fmt.Println(<span class="string">"[is an int] value =&gt;"</span>,res)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        fmt.Println(<span class="string">"[not an int] value =&gt;"</span>,data) </div><div class="line">        <span class="comment">//prints: [not an int] value =&gt; great (as expected)</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="阻塞的Goroutine和资源泄露">阻塞的Goroutine和资源泄露</h3>
<p>Rob Pike在2012年的Google I/O大会上所做的“Go Concurrency Patterns”的演讲上，说道过几种基础的并发模式。从一组目标中获取第一个结果就是其中之一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> First(query <span class="typename">string</span>, replicas ...Search) Result {  </div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</div><div class="line">    searchReplica := <span class="keyword">func</span>(i <span class="typename">int</span>) { c &lt;- replicas[i](query) }</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas {</div><div class="line">        <span class="keyword">go</span> searchReplica(i)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> &lt;-c</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个函数在每次搜索重复时都会起一个goroutine。每个goroutine把它的搜索结果发送到结果的channel中。结果channel的第一个值被返回。</p>
<p>那其他goroutine的结果会怎样呢？还有那些goroutine自身呢？</p>
<p>在<code>First()</code>函数中的结果channel是没缓存的。这意味着只有第一个goroutine返回。其他的goroutine会困在尝试发送结果的过程中。这意味着，如果你有不止一个的重复时，每个调用将会泄露资源。</p>
<p>为了避免泄露，你需要确保所有的goroutine退出。一个不错的方法是使用一个有足够保存所有缓存结果的channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> First(query <span class="typename">string</span>, replicas ...Search) Result {  </div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</div><div class="line">    searchReplica := <span class="keyword">func</span>(i <span class="typename">int</span>) { c &lt;- replicas[i](query) }</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas {</div><div class="line">        <span class="keyword">go</span> searchReplica(i)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> &lt;-c</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个不错的解决方法是使用一个有default情况的select语句和一个保存一个缓存结果的channel。default情况保证了即使当结果channel无法收到消息的情况下，goroutine也不会堵塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> First(query <span class="typename">string</span>, replicas ...Search) Result {  </div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result<span class="number">,1</span>)</div><div class="line">    searchReplica := <span class="keyword">func</span>(i <span class="typename">int</span>) { </div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas {</div><div class="line">        <span class="keyword">go</span> searchReplica(i)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> &lt;-c</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也可以使用特殊的取消channel来终止workers。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> First(query <span class="typename">string</span>, replicas ...Search) Result {  </div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</div><div class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</div><div class="line">    searchReplica := <span class="keyword">func</span>(i <span class="typename">int</span>) { </div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</div><div class="line">        <span class="keyword">case</span> &lt;- done:</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas {</div><div class="line">        <span class="keyword">go</span> searchReplica(i)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &lt;-c</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为何在演讲中会包含这些bug？Rob Pike仅仅是不想把演示复杂化。这么作是合理的，但对于Go新手而言，可能会直接使用代码，而不去思考它可能有问题。</p>
<h2 id="高级">高级</h2>
<h3 id="使用指针接收方法的值的实例">使用指针接收方法的值的实例</h3>
<p>只要值是可取址的，那在这个值上调用指针接收方法是没问题的。换句话说，在某些情况下，你不需要在有一个接收值的方法版本。</p>
<p>然而并不是所有的变量是可取址的。Map的元素就不是。通过interface引用的变量也不是。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *data) <span class="built_in">print</span>() {  </div><div class="line">    fmt.Println(<span class="string">"name:"</span>,p.name)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> {  </div><div class="line">    <span class="built_in">print</span>()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    d1 := data{<span class="string">"one"</span>}</div><div class="line">    d1.<span class="built_in">print</span>() <span class="comment">//ok</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> in printer = data{<span class="string">"two"</span>} <span class="comment">//error</span></div><div class="line">    in.<span class="built_in">print</span>()</div><div class="line"></div><div class="line">    m := <span class="keyword">map</span>[<span class="typename">string</span>]data {<span class="string">"x"</span>:data{<span class="string">"three"</span>}}</div><div class="line">    m[<span class="string">"x"</span>].<span class="built_in">print</span>() <span class="comment">//error</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Errors:</p>
<blockquote>
<p>/tmp/sandbox017696142/main.go:21: cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver)<br>/tmp/sandbox017696142/main.go:25: cannot call pointer method on m[&quot;x&quot;]<br>/tmp/sandbox017696142/main.go:25: cannot take the address of m[&quot;x&quot;]</p>
</blockquote>
<h3 id="更新Map的值">更新Map的值</h3>
<p>如果你有一个struct值的map，你无法更新单个的struct值。</p>
<p>Fails:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    m := <span class="keyword">map</span>[<span class="typename">string</span>]data {<span class="string">"x"</span>:{<span class="string">"one"</span>}}</div><div class="line">    m[<span class="string">"x"</span>].name = <span class="string">"two"</span> <span class="comment">//error</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Compile Error:</p>
<blockquote>
<p>/tmp/sandbox380452744/main.go:9: cannot assign to m[&quot;x&quot;].name</p>
</blockquote>
<p>这个操作无效是因为map元素是无法取址的。</p>
<p>而让Go新手更加困惑的是slice元素是可以取址的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    s := []data one</div><div class="line">    s<span class="number">[0</span>].name = <span class="string">"two"</span> <span class="comment">//ok</span></div><div class="line">    fmt.Println(s)    <span class="comment">//prints: [{two}]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意在不久之前，使用编译器之一（gccgo）是可以更新map的元素值的，但这一行为很快就被修复了 :-)它也被认为是Go 1.3的潜在特性。在那时还不是要急需支持的，但依旧在todo list中。</p>
<p>第一个有效的方法是使用一个临时变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    m := <span class="keyword">map</span>[<span class="typename">string</span>]data {<span class="string">"x"</span>:{<span class="string">"one"</span>}}</div><div class="line">    r := m[<span class="string">"x"</span>]</div><div class="line">    r.name = <span class="string">"two"</span></div><div class="line">    m[<span class="string">"x"</span>] = r</div><div class="line">    fmt.Printf(<span class="string">"%v"</span>,m) <span class="comment">//prints: map[x:{two}]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个有效的方法是使用指针的map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    m := <span class="keyword">map</span>[<span class="typename">string</span>]*data {<span class="string">"x"</span>:{<span class="string">"one"</span>}}</div><div class="line">    m[<span class="string">"x"</span>].name = <span class="string">"two"</span> <span class="comment">//ok</span></div><div class="line">    fmt.Println(m[<span class="string">"x"</span>]) <span class="comment">//prints: &{two}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>顺便说下，当你运行下面的代码时会发生什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> {  </div><div class="line">    name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    m := <span class="keyword">map</span>[<span class="typename">string</span>]*data {<span class="string">"x"</span>:{<span class="string">"one"</span>}}</div><div class="line">    m[<span class="string">"z"</span>].name = <span class="string">"what?"</span> <span class="comment">//???</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="&quot;nil&quot;_Interfaces和&quot;nil&quot;_Interfaces的值">&quot;nil&quot; Interfaces和&quot;nil&quot; Interfaces的值</h3>
<p>这在Go中是第二最常见的技巧，因为interface虽然看起来像指针，但并不是指针。interface变量仅在类型和值为“nil”时才为“nil”。</p>
<p>interface的类型和值会根据用于创建对应interface变量的类型和值的变化而变化。当你检查一个interface变量是否等于“nil”时，这就会导致未预期的行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">var</span> data *<span class="typename">byte</span></div><div class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>{}</div><div class="line"></div><div class="line">    fmt.Println(data,data == <span class="constant">nil</span>) <span class="comment">//prints: &lt;nil&gt; true</span></div><div class="line">    fmt.Println(in,in == <span class="constant">nil</span>)     <span class="comment">//prints: &lt;nil&gt; true</span></div><div class="line"></div><div class="line">    in = data</div><div class="line">    fmt.Println(in,in == <span class="constant">nil</span>)     <span class="comment">//prints: &lt;nil&gt; false</span></div><div class="line">    <span class="comment">//'data' is 'nil', but 'in' is not 'nil'</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当你的函数返回interface时，小心这个陷阱。</p>
<p>Incorrect:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    doit := <span class="keyword">func</span>(arg <span class="typename">int</span>) <span class="keyword">interface</span>{} {</div><div class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>{} = <span class="constant">nil</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(arg &gt;<span class="number"> 0</span>) {</div><div class="line">            result = &<span class="keyword">struct</span>{}{}</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> res := doit<span class="number">(-1</span>); res != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(<span class="string">"good result:"</span>,res) <span class="comment">//prints: good result: &lt;nil&gt;</span></div><div class="line">        <span class="comment">//'res' is not 'nil', but its value is 'nil'</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Works:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    doit := <span class="keyword">func</span>(arg <span class="typename">int</span>) <span class="keyword">interface</span>{} {</div><div class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>{} = <span class="constant">nil</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(arg &gt;<span class="number"> 0</span>) {</div><div class="line">            result = &<span class="keyword">struct</span>{}{}</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            ret</div></pre></td></tr></table></figure>

<h3 id="栈和堆变量">栈和堆变量</h3>
<p>你并不总是知道变量是分配到栈还是堆上。在C++中，使用new创建的变量总是在堆上。在Go中，即使是使用<code>new()</code>或者<code>make()</code>函数来分配，变量的位置还是由编译器决定。编译器根据变量的大小和“泄露分析”的结果来决定其位置。这也意味着在局部变量上返回引用是没问题的，而这在C或者C++这样的语言中是不行的。</p>
<p>如果你想知道变量分配的位置，在“go build”或“go run”上传入“-m“ gc标志（即，go run -gcflags -m app.go）。</p>
<h3 id="GOMAXPROCS,_并发,_和并行">GOMAXPROCS, 并发, 和并行</h3>
<p>默认情况下，Go仅使用一个执行上下文/OS线程（在当前的版本）。这个数量可以通过设置<code>GOMAXPROCS</code>来提高。</p>
<p>一个常见的误解是，<code>GOMAXPROCS</code>表示了CPU的数量，Go将使用这个数量来运行goroutine。而<code>runtime.GOMAXPROCS()</code>函数的文档让人更加的迷茫。<code>GOMAXPROCS</code>变量描述（<a href="https://golang.org/pkg/runtime/）所讨论OS线程的内容比较好。" target="_blank" rel="external">https://golang.org/pkg/runtime/）所讨论OS线程的内容比较好。</a></p>
<p>你可以设置<code>GOMAXPROCS</code>的数量大于CPU的数量。<code>GOMAXPROCS</code>的最大值是256。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"runtime"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    fmt.Println(runtime.GOMAXPROCS<span class="number">(-1</span>)) <span class="comment">//prints: 1</span></div><div class="line">    fmt.Println(runtime.NumCPU())       <span class="comment">//prints: 1 (on play.golang.org)</span></div><div class="line">    runtime.GOMAXPROCS<span class="number">(20</span>)</div><div class="line">    fmt.Println(runtime.GOMAXPROCS<span class="number">(-1</span>)) <span class="comment">//prints: 20</span></div><div class="line">    runtime.GOMAXPROCS<span class="number">(300</span>)</div><div class="line">    fmt.Println(runtime.GOMAXPROCS<span class="number">(-1</span>)) <span class="comment">//prints: 256</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="读写操作的重排顺序">读写操作的重排顺序</h3>
<p>Go可能会对某些操作进行重新排序，但它能保证在一个goroutine内的所有行为顺序是不变的。然而，它并不保证多goroutine的执行顺序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"runtime"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS<span class="number">(3</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> a, b <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> u1() {  </div><div class="line">    a =<span class="number"> 1</span></div><div class="line">    b =<span class="number"> 2</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> u2() {  </div><div class="line">    a =<span class="number"> 3</span></div><div class="line">    b =<span class="number"> 4</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> p() {  </div><div class="line">    <span class="built_in">println</span>(a)</div><div class="line">    <span class="built_in">println</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    <span class="keyword">go</span> u1()</div><div class="line">    <span class="keyword">go</span> u2()</div><div class="line">    <span class="keyword">go</span> p()</div><div class="line">    time.Sleep<span class="number">(1</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你多运行几次上面的代码，你可能会发现a和b变量有多个不同的组合：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1 </div><div class="line">2</div><div class="line"></div><div class="line">3 </div><div class="line">4</div><div class="line"></div><div class="line">0 </div><div class="line">2</div><div class="line"></div><div class="line">0 </div><div class="line">0</div><div class="line"></div><div class="line">1 </div><div class="line">4</div></pre></td></tr></table></figure>

<p><code>a</code>和<code>b</code>最有趣的组合式是&quot;02&quot;。这表明<code>b</code>在<code>a</code>之前更新了。</p>
<p>如果你需要在多goroutine内放置读写顺序的变化，你将需要使用channel，或者使用&quot;sync&quot;包构建合适的结构体。</p>
<h3 id="优先调度">优先调度</h3>
<p>有可能会出现这种情况，一个无耻的goroutine阻止其他goroutine运行。当你有一个不让调度器运行的for循环时，这就会发生。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    done := <span class="constant">false</span></div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>(){</div><div class="line">        done = <span class="constant">true</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> !done {</div><div class="line">    }</div><div class="line">    fmt.Println(<span class="string">"done!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>for循环并不需要是空的。只要它包含了不会触发调度执行的代码，就会发生这种问题。</p>
<p>调度器会在GC、“go”声明、阻塞channel操作、阻塞系统调用和lock操作后运行。它也会在非内联函数调用后执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    done := <span class="constant">false</span></div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>(){</div><div class="line">        done = <span class="constant">true</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> !done {</div><div class="line">        fmt.Println(<span class="string">"not done!"</span>) <span class="comment">//not inlined</span></div><div class="line">    }</div><div class="line">    fmt.Println(<span class="string">"done!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>要想知道你在for循环中调用的函数是否是内联的，你可以在“go build”或“go run”时传入“-m” gc标志（如， <code>go build -gcflags -m</code>）。</p>
<p>另一个选择是显式的唤起调度器。你可以使用“runtime”包中的<code>Goshed()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"runtime"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    done := <span class="constant">false</span></div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>(){</div><div class="line">        done = <span class="constant">true</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> !done {</div><div class="line">        runtime.Gosched()</div><div class="line">    }</div><div class="line">    fmt.Println(<span class="string">"done!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你看到了这里，并想留下评论或者想法，你可以在这个<a href="https://www.reddit.com/r/golang/comments/360vlb/draft_traps_gotchas_and_common_mistakes_in_go/" target="_blank" rel="external">Reddit讨论</a>里随意留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs</a><br>翻译: <a href="http://www.shwley.com/index.php/archives/80/" target="_blank" rel="external">Go的50度灰：新Golang开发者要注意的陷阱、技巧和常见错误</a>, 译者: <a href="http://www.shwley.com/index.php/author/1/" target="_blank" rel="external">影风LEY </a></p>
<p>Go是一门简单有趣的语言，但与其他语言类似，它会有一些技巧。。。这些技巧的绝大部分并不是Go的缺陷造成的。如果你以前使用的是其他语言，那么这其中的有些错误就是很自然的陷阱。其它的是由错误的假设和缺少细节造成的。</p>
<p>如果你花时间学习这门语言，阅读官方说明、wiki、邮件列表讨论、大量的优秀博文和Rob Pike的展示，以及源代码，这些技巧中的绝大多数都是显而易见的。尽管不是每个人都是以这种方式开始学习的，但也没关系。如果你是Go语言新人，那么这里的信息将会节约你大量的调试代码的时间。<br>]]>
    
    </summary>
    
      <category term="Golang" scheme="http://colobu.com/categories/Golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用LinkedHashMap实现LRU缓存]]></title>
    <link href="http://colobu.com/2015/09/07/LRU-cache-implemented-by-Java-LinkedHashMap/"/>
    <id>http://colobu.com/2015/09/07/LRU-cache-implemented-by-Java-LinkedHashMap/</id>
    <published>2015-09-07T01:17:03.000Z</published>
    <updated>2015-09-07T01:46:49.385Z</updated>
    <content type="html"><![CDATA[<p>可能很多人已经知道了这个技术，但是对于我来说，虽然使用Java十余年了，最近才了解到<code>LinkedHashMap</code>这个类。使用这个类可以方便的实现一个本地的LRU Cache类。<br><a id="more"></a><br>之所以没有关注到这个类，是因为在面对本地缓存的case时，我经常会考虑<code>guava</code>这个框架。<br>最早可以搜到的一篇关于<code>LinkedHashMap</code>实现本地缓存的文章之一是这篇: <a href="http://java-planet.blogspot.pt/2005/08/how-to-set-up-simple-lru-cache-using.html" target="_blank" rel="external">How to set up a simple LRU cache using LinkedHashMap </a>，发表于2005年。文末有附了几篇关于<code>LinkedHashMap</code>类的介绍。</p>
<p>这个类实现了Hash和双向链表两种数据结构的混合。 所以通过<code>get</code>方法可以很快的得到相应的元素，而链表结构又可以根据<code>access</code>或者<code>insert</code>进行排序。但是这种<br>方式也会有性能的损耗，因为对数据的插入需要同时更新这两个数据结构，对数据的访问在<code>accessOrder</code>情况下也会涉及数据的移动。 我们知道数据量大的情况下对链表的更改是很耗时的，所以使用的时候要仔细考量。</p>
<p>好了，下面就是一个local cache的实现,抄自 <a href="http://chriswu.me/blog/a-lru-cache-in-10-lines-of-java/" target="_blank" rel="external">A LRU Cache in 10 Lines of Java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="keyword">int</span> cacheSize) {</div><div class="line">    <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75</span>, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">this</span>.cacheSize = cacheSize;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span>(Map.Entry&lt;K, V&gt; eldest) {</div><div class="line">    <span class="keyword">return</span> size() &gt;= cacheSize;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>主要实现<code>removeEldestEntry</code>方法，这个方法如果返回true,则会移除最老的数据。这只会在调用<code>put</code>或者<code>putAll</code>时发生。</p>
<p>很重要的一点， <strong>此类不是线程安全的</strong>，所以使用的时候你需要加锁。</p>
<h4 id="参考文档">参考文档</h4>
<ol>
<li><a href="http://chriswu.me/blog/a-lru-cache-in-10-lines-of-java/" target="_blank" rel="external">A LRU Cache in 10 Lines of Java</a></li>
<li><a href="http://java-planet.blogspot.pt/2005/08/how-to-set-up-simple-lru-cache-using.html" target="_blank" rel="external">How to set up a simple LRU cache using LinkedHashMap </a></li>
<li><a href="http://codereview.stackexchange.com/questions/3138/linkedhashmap-as-lru-cache" target="_blank" rel="external">LinkedHashMap as LRU cache</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>可能很多人已经知道了这个技术，但是对于我来说，虽然使用Java十余年了，最近才了解到<code>LinkedHashMap</code>这个类。使用这个类可以方便的实现一个本地的LRU Cache类。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 CSS 实现三角形与平行四边形]]></title>
    <link href="http://colobu.com/2015/08/25/use-css-to-paint-triangle-and-parallelogram/"/>
    <id>http://colobu.com/2015/08/25/use-css-to-paint-triangle-and-parallelogram/</id>
    <published>2015-08-25T05:38:32.000Z</published>
    <updated>2015-08-25T05:49:11.517Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://jerryzou.com/posts/use-css-to-paint-triangle-and-parallelogram/?utm_source=tuicool" target="_blank" rel="external">用 CSS 实现三角形与平行四边形</a>, 作者：<a href="mailto:jerry.zry@outlook.com" target="_blank" rel="external">邹润阳</a></p>
<p>最近在逛某个技术网站的时候，感觉文章关键词上的样式好酷炫啊。于是我将那种写法照搬到了我的博客中，也许最近逛过我博客的小伙伴已经发现了它出现在哪儿了——分页的样式。来张截图：<br><img src="1.png" alt=""><br>你在首页的底部也可以看到这样一个分页栏；是不是看上去还不错？下面就来看看这是如何实现的吧~<br><a id="more"></a></p>
<h2 id="第一种方法：利用border">第一种方法：利用border</h2>
<p>第一种方法是借助border属性 hack 出三角形，然后通过一个矩形拼接两个三角形最终制造出一个平行四边形。为什么使用border可以产生三角形呢？先来看看一张图片：<br><img src="2.png" alt=""><br>看了图中的三个小图形的变化过程，你应该已经清楚了一半。其实 hack 出三角形只需要两个条件，第一，元素本身的长宽为0；其次，将不需要的部分通过 border-color 来设置隐藏。通过类似的方法，你还可以创造出梯形，上图中的三个图形的代码如下。（另附 <a href="http://codepen.io/jerryzou/pen/mJYJym" target="_blank" rel="external">CodePen 示例</a>）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="id">#first</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">20px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">10px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-style</span>:<span class="value"> solid</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-color</span>:<span class="value"> red green blue brown</span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"></div><div class="line"><span class="id">#second</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">10px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-style</span>:<span class="value"> solid</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-color</span>:<span class="value"> red green blue brown</span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"></div><div class="line"><span class="id">#third</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-width</span>:<span class="value"> <span class="number">10px</span></span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-style</span>:<span class="value"> solid</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">border-color</span>:<span class="value"> red transparent transparent transparent</span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<p>接下来就要考虑如何拼接出一个平行四边形了。在<code>border</code>法中，它由三部分组成，分别是左三角形、矩形、右三角形。如果每次绘制平行四边形都要创建三个元素显然过于麻烦了，所以在这里<code>:before</code>和<code>:after</code>伪元素是个不错的选择。下面我们实现一下这样的效果：<br><img src="3.png" alt=""></p>
<p>为了将三角形与矩形无缝拼接到一起，多处属性要保持一致，所以使用类似 Less, Sass, Stylus 等 CSS 预处理器来写这段代码会更容易维护，下面给出 Scss 版本的代码。（另附 <a href="http://codepen.io/jerryzou/pen/ZGNGWZ?editors=110" target="_blank" rel="external">CodePen 链接</a>）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//三角形的宽高</div><div class="line">$height: 24px;</div><div class="line">$width: 12px;</div><div class="line"></div><div class="line">//对平行四边形三部分的颜色进行赋值</div><div class="line">@mixin parallelogram-color($color) {</div><div class="line">  background: $color;</div><div class="line">  &:before { border-color: transparent $color $color transparent; }</div><div class="line">  &:after { border-color: $color transparent transparent $color; }</div><div class="line">}</div><div class="line"></div><div class="line">//单个三角形的样式</div><div class="line">@mixin triangle() {</div><div class="line">  content: '';</div><div class="line">  display: block;</div><div class="line">  width: 0;</div><div class="line">  height: 0;</div><div class="line">  position: absolute;</div><div class="line">  border-style: solid;</div><div class="line">  border-width: $height/2 $width/2;</div><div class="line">  top: 0;</div><div class="line">}</div><div class="line"></div><div class="line">//平行四边形的样式</div><div class="line">.para {</div><div class="line">  display: inline-block;</div><div class="line">  position: relative;</div><div class="line">  padding: 0 10px;</div><div class="line">  height: $height;</div><div class="line">  line-height: $height;</div><div class="line">  margin-left: $width;</div><div class="line">  color: #fff;</div><div class="line"></div><div class="line">  &:after {</div><div class="line">    @include triangle();</div><div class="line">    right: -$width;</div><div class="line">  }</div><div class="line"></div><div class="line">  &:before {</div><div class="line">    @include triangle();</div><div class="line">    left: -$width;</div><div class="line">  }</div><div class="line"></div><div class="line">  @include parallelogram-color(red);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>需要注意的是，如果通过 <code>$height</code>、<code>$width</code> 设置的三角形斜率太小或太大都有可能造成渲染出锯齿，所以使用起来要多多测试一下不同的宽高所得到的视觉效果如何。</p>
<h2 id="利用transform">利用transform</h2>
<p>使用transform来实现平行四边形的方法是我在逛<a href="http://www.alitrip.com/" target="_blank" rel="external">去啊</a>的时候看到的，效果大概是这个样子：<br><img src="4.png" alt=""></p>
<p>看到之后觉得好神奇啊，原来还可以只有平行四边形的外轮廓。（因为方法一只能创造填充效果的平行四边形）实现起来非常简单，主要是借助了<code>transform: skew(...)</code>，下面就来看看源码吧。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">.city {</div><div class="line">  display: inline-block;</div><div class="line">  padding: 5px 20px;</div><div class="line">  border: 1px solid #44a5fc;</div><div class="line">  color: #333;</div><div class="line">  transform: skew(-20deg);</div><div class="line">}</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class="city"&gt;上海&lt;/div&gt;</div></pre></td></tr></table></figure>

<p>于是我们得到了这样的效果：<br><img src="5.png" alt=""><br>看到图片的你一定是这样想的：<br><img src="damn.gif" alt=""><br>别着急嘛，我们的确是把整个 div 进行了歪曲，导致中间的文字也是倾斜的，而这显然不是我们所要的效果。所以我们需要加一个内层元素，并对内层元素做一次逆向的歪曲，从而得到我们想要的效果：<br><img src="6.png" alt=""><br>实现代码如下，另附 <a href="http://codepen.io/jerryzou/pen/BNeNwV?editors=110" target="_blank" rel="external">CodePen 示例</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">.city {</div><div class="line">  display: inline-block;</div><div class="line">  padding: 5px 20px;</div><div class="line">  border: 1px solid #44a5fc;</div><div class="line">  color: #333;</div><div class="line">  transform: skew(-20deg);</div><div class="line">}</div><div class="line"></div><div class="line">.city div {</div><div class="line">  transform: skew(20deg);</div><div class="line">}</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;div class="city"&gt;</div><div class="line">  &lt;div&gt;上海&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>第一种方法使用 <code>border</code> 属性 hack 出三角形，并通过对三个元素进行拼接最终实现了平行四边形；而第二种方法则通过 <code>transform: skew</code> 来得到平行四边形。总体来说，第二种方法相对于第一种代码量小得多，而且也很好理解。唯一的不足是无法构造像本站的分页中所使用的梯形。希望本文对各位有所帮助。</p>
<h3 id="UPDATE">UPDATE</h3>
<ul>
<li><strong>2015.8.18</strong>, <a href="http://weibo.com/fouber" target="_blank" rel="external">@前端农民工</a> 给出了一个 <a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="external">CSS-Tricks</a> 的链接，是关于各种用 CSS 绘制几何图形的方法，浅显易懂，推荐大家看看！</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://jerryzou.com/posts/use-css-to-paint-triangle-and-parallelogram/?utm_source=tuicool" target="_blank" rel="external">用 CSS 实现三角形与平行四边形</a>, 作者：<a href="mailto:jerry.zry@outlook.com" target="_blank" rel="external">邹润阳</a></p>
<p>最近在逛某个技术网站的时候，感觉文章关键词上的样式好酷炫啊。于是我将那种写法照搬到了我的博客中，也许最近逛过我博客的小伙伴已经发现了它出现在哪儿了——分页的样式。来张截图：<br><img src="1.png" alt=""><br>你在首页的底部也可以看到这样一个分页栏；是不是看上去还不错？下面就来看看这是如何实现的吧~<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://colobu.com/tags/CSS/"/>
    
      <category term="前端开发" scheme="http://colobu.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程语言的隐藏特性]]></title>
    <link href="http://colobu.com/2015/08/24/Hidden-Features-of-Programming-Languages/"/>
    <id>http://colobu.com/2015/08/24/Hidden-Features-of-Programming-Languages/</id>
    <published>2015-08-24T05:29:05.000Z</published>
    <updated>2015-08-24T06:14:44.076Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.stackoverflow.com/" target="_blank" rel="external">StackOverflow</a>有很多有趣的问答， 其中有一些问答汇集了很多人的智慧。 其中<a href="http://stackoverflow.com/search?q=Hidden+Features&amp;s=fef2f7b8-4b25-466e-8e47-a95fbcdc5e24" target="_blank" rel="external">Hidden features of系列</a>揭示了一些语言的隐藏特性，非常的有趣， 比如Java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; fruits = <span class="keyword">new</span> HashSet&lt;String&gt;() { {</div><div class="line">	add(<span class="string">"苹果"</span>);</div><div class="line">	add(<span class="string">"香蕉"</span>);</div><div class="line">	add(<span class="string">"梨"</span>);</div><div class="line">	add(<span class="string">"芒果"</span>);</div><div class="line"> } };</div></pre></td></tr></table></figure>

<p>尽管这些问答很早(自08年开始)就开始收集整理了，但是很多的答案都出人意料，并且你在教科书中是不会看到这些技巧的。<br><a id="more"></a></p>
<p>以下列出了投票最高的一些语言和工具的隐藏特性。<br><a href="http://stackoverflow.com/questions/9033/hidden-features-of-c" target="_blank" rel="external">Hidden Features of C#? </a><br><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python" target="_blank" rel="external">Hidden features of Python </a><br><a href="http://stackoverflow.com/questions/15496/hidden-features-of-java" target="_blank" rel="external">Hidden Features of Java </a><br><a href="http://stackoverflow.com/questions/61088/hidden-features-of-javascript" target="_blank" rel="external">Hidden Features of JavaScript? </a><br><a href="http://stackoverflow.com/questions/63998/hidden-features-of-ruby" target="_blank" rel="external">Hidden features of Ruby </a><br><a href="http://stackoverflow.com/questions/1025181/hidden-features-of-scala" target="_blank" rel="external">Hidden features of Scala </a><br><a href="http://stackoverflow.com/questions/54929/hidden-features-of-asp-net" target="_blank" rel="external">Hidden Features of ASP.NET</a><br><a href="http://stackoverflow.com/questions/161872/hidden-features-of-perl" target="_blank" rel="external">Hidden features of Perl? </a><br><a href="http://stackoverflow.com/questions/132241/hidden-features-of-c" target="_blank" rel="external">Hidden features of C </a><br><a href="http://stackoverflow.com/questions/954327/hidden-features-of-html" target="_blank" rel="external">Hidden features of HTML </a><br><a href="http://stackoverflow.com/questions/954327/hidden-features-of-html" target="_blank" rel="external">Hidden Features of SQL Server </a><br><a href="http://stackoverflow.com/questions/75538/hidden-features-of-c" target="_blank" rel="external">Hidden Features of C++? </a><br><a href="http://stackoverflow.com/questions/211378/hidden-features-of-bash" target="_blank" rel="external">Hidden features of Bash </a><br><a href="http://stackoverflow.com/questions/1619133/hidden-features-of-android-development" target="_blank" rel="external">Hidden features of Android development? </a><br><a href="http://stackoverflow.com/questions/146297/hidden-features-of-xcode" target="_blank" rel="external">Hidden Features of Xcode </a><br><a href="http://stackoverflow.com/questions/954894/hidden-features-of-http" target="_blank" rel="external">Hidden features of HTTP </a><br><a href="http://stackoverflow.com/questions/303512/hidden-features-of-groovy" target="_blank" rel="external">Hidden features of Groovy? </a><br><a href="http://stackoverflow.com/questions/5410191/hidden-features-of-xcode-4" target="_blank" rel="external">Hidden Features of Xcode 4</a><br><a href="http://stackoverflow.com/questions/61401/hidden-features-of-php" target="_blank" rel="external">Hidden Features of PHP? </a><br><a href="http://stackoverflow.com/questions/2524025/hidden-features-intellij-idea" target="_blank" rel="external">Hidden Features IntelliJ IDEA </a><br><a href="http://stackoverflow.com/questions/628407/hidden-features-of-css" target="_blank" rel="external">Hidden features of CSS </a><br><a href="http://stackoverflow.com/questions/1063497/hidden-features-of-erlang" target="_blank" rel="external">Hidden Features of Erlang </a><br><a href="http://stackoverflow.com/questions/245395/hidden-features-of-windows-batch-files" target="_blank" rel="external">Hidden features of Windows batch files </a><br><a href="http://stackoverflow.com/questions/2493996/hidden-features-of-clojure" target="_blank" rel="external">Hidden features of Clojure </a><br><a href="http://stackoverflow.com/questions/368858/hidden-features-of-mysql" target="_blank" rel="external">Hidden Features of MySQL </a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.stackoverflow.com/" target="_blank" rel="external">StackOverflow</a>有很多有趣的问答， 其中有一些问答汇集了很多人的智慧。 其中<a href="http://stackoverflow.com/search?q=Hidden+Features&amp;s=fef2f7b8-4b25-466e-8e47-a95fbcdc5e24" target="_blank" rel="external">Hidden features of系列</a>揭示了一些语言的隐藏特性，非常的有趣， 比如Java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; fruits = <span class="keyword">new</span> HashSet&lt;String&gt;() { {</div><div class="line">	add(<span class="string">"苹果"</span>);</div><div class="line">	add(<span class="string">"香蕉"</span>);</div><div class="line">	add(<span class="string">"梨"</span>);</div><div class="line">	add(<span class="string">"芒果"</span>);</div><div class="line"> } };</div></pre></td></tr></table></figure>

<p>尽管这些问答很早(自08年开始)就开始收集整理了，但是很多的答案都出人意料，并且你在教科书中是不会看到这些技巧的。<br>]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle多渠道打包 ]]></title>
    <link href="http://colobu.com/2015/08/24/assemble-android-application-for-multiple-channels/"/>
    <id>http://colobu.com/2015/08/24/assemble-android-application-for-multiple-channels/</id>
    <published>2015-08-24T00:48:44.000Z</published>
    <updated>2015-08-24T00:57:11.220Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://stormzhang.com/devtools/2015/01/15/android-studio-tutorial6/" target="_blank" rel="external">Android Studio系列教程六--Gradle多渠道打包 </a>,</p>
<blockquote>
<p>美团采用了另外一种hack的方式快速为多渠道打包： <a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">美团Android自动化之旅—生成渠道包</a>,在META-INF文件夹下添加不同的空文件。</p>
</blockquote>
<p>由于国内Android市场众多渠道，为了统计每个渠道的下载及其它数据统计，就需要我们针对每个渠道单独打包，如果让你打几十个市场的包岂不烦死了，不过有了Gradle，这再也不是事了。<br><a id="more"></a></p>
<h3 id="友盟多渠道打包">友盟多渠道打包</h3>
<p>废话不多说，以友盟统计为例，在AndroidManifest.xml里面会有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">    android:name=<span class="string">"UMENG_CHANNEL"</span></div><div class="line">    android:value=<span class="string">"Channel_ID"</span> /&gt;</div></pre></td></tr></table></figure>

<p>里面的Channel_ID就是渠道标示。我们的目标就是在编译的时候这个值能够自动变化。</p>
<ul>
<li>第一步 在AndroidManifest.xml里配置PlaceHolder</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">    android:name=<span class="string">"UMENG_CHANNEL"</span></div><div class="line">    android:value=<span class="string">"${UMENG_CHANNEL_VALUE}"</span> /&gt;</div></pre></td></tr></table></figure>

<ul>
<li>第二步 在build.gradle设置productFlavors</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="title">android</span> {  </div><div class="line">    <span class="title">productFlavors</span> {</div><div class="line">        <span class="title">xiaomi</span> {</div><div class="line">            <span class="title">manifestPlaceholders</span> = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]</div><div class="line">        }</div><div class="line">        _360 {</div><div class="line">            <span class="title">manifestPlaceholders</span> = [UMENG_CHANNEL_VALUE: <span class="string">"_360"</span>]</div><div class="line">        }</div><div class="line">        baidu {</div><div class="line">            <span class="title">manifestPlaceholders</span> = [UMENG_CHANNEL_VALUE: <span class="string">"baidu"</span>]</div><div class="line">        }</div><div class="line">        wandoujia {</div><div class="line">            <span class="title">manifestPlaceholders</span> = [UMENG_CHANNEL_VALUE: <span class="string">"wandoujia"</span>]</div><div class="line">        }</div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者批量修改</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">android {  </span></span></div><div class="line">    productFlavors {</div><div class="line">        xiaomi {}</div><div class="line">        _360 {}</div><div class="line">        baidu {}</div><div class="line">        wandoujia {}</div><div class="line">    }  </div><div class="line"></div><div class="line">    productFlavors.all { </div><div class="line">        flavor -&gt; flavor.manifestPlaceholders = [<span class="constant">UMENG_CHANNEL_VALUE</span><span class="symbol">:</span> name] </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>很简单清晰有没有？直接执行 <em>./gradlew assembleRelease</em> ， 然后就可以静静的喝杯咖啡等待打包完成吧。</p>
<h3 id="assemble结合Build_Variants来创建task">assemble结合Build Variants来创建task</h3>
<p>上一篇博客介绍了 assemble 这个命令，会结合 Build Type 创建自己的task，如:</p>
<ul>
<li>./gradlew assembleDebug*<ul>
<li>./gradlew assembleRelease*</li>
</ul>
</li>
</ul>
<p>除此之外 assemble 还能和 Product Flavor 结合创建新的任务，其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor ， 举个例子大家就明白了：</p>
<p>如果我们想打包wandoujia渠道的release版本，执行如下命令就好了：</p>
<ul>
<li>./gradlew assembleWandoujiaRelease*</li>
</ul>
<p>如果我们只打wandoujia渠道版本，则：</p>
<ul>
<li>./gradlew assembleWandoujia*</li>
</ul>
<p>此命令会生成wandoujia渠道的Release和Debug版本</p>
<p>同理我想打全部Release版本：</p>
<ul>
<li>./gradlew assembleRelease*</li>
</ul>
<p>这条命令会把Product Flavor下的所有渠道的Release版本都打出来。</p>
<p>总之，assemble 命令创建task有如下用法：</p>
<ul>
<li><strong>assemble</strong>： 允许直接构建一个Variant版本，例如assembleFlavor1Debug。</li>
<li><strong>assemble</strong>： 允许构建指定Build Type的所有APK，例如assembleDebug将会构建Flavor1Debug和Flavor2Debug两个Variant版本。</li>
<li><strong>assemble</strong>： 允许构建指定flavor的所有APK，例如assembleFlavor1将会构建Flavor1Debug和Flavor1Release两个Variant版本。</li>
</ul>
<h3 id="完整的gradle脚本">完整的gradle脚本</h3>
<p>最后福利大放送，来一份我在项目中使用的完整的gradle文件配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line"></div><div class="line"><span class="keyword">def</span> releaseTime() {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</div><div class="line">}</div><div class="line"></div><div class="line">android {</div><div class="line">    compileSdkVersion <span class="number">21</span></div><div class="line">    buildToolsVersion <span class="string">'21.1.2'</span></div><div class="line"></div><div class="line">    defaultConfig {</div><div class="line">        applicationId <span class="string">"com.boohee.*"</span></div><div class="line">        minSdkVersion <span class="number">14</span></div><div class="line">        targetSdkVersion <span class="number">21</span></div><div class="line">        versionCode <span class="number">1</span></div><div class="line">        versionName <span class="string">"1.0"</span></div><div class="line">        </div><div class="line">        <span class="comment">// dex突破65535的限制</span></div><div class="line">        multiDexEnabled <span class="keyword">true</span></div><div class="line">        <span class="comment">// 默认是umeng的渠道</span></div><div class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"umeng"</span>]</div><div class="line">    }</div><div class="line"></div><div class="line">    lintOptions {</div><div class="line">        abortOnError <span class="keyword">false</span></div><div class="line">    }</div><div class="line"></div><div class="line">    signingConfigs {</div><div class="line">        debug {</div><div class="line">            <span class="comment">// No debug config</span></div><div class="line">        }</div><div class="line"></div><div class="line">        release {</div><div class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../yourapp.keystore"</span>)</div><div class="line">            storePassword <span class="string">"your password"</span></div><div class="line">            keyAlias <span class="string">"your alias"</span></div><div class="line">            keyPassword <span class="string">"your password"</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    buildTypes {</div><div class="line">        debug {</div><div class="line">            <span class="comment">// 显示Log</span></div><div class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span></div><div class="line"></div><div class="line">            versionNameSuffix <span class="string">"-debug"</span></div><div class="line">            minifyEnabled <span class="keyword">false</span></div><div class="line">            zipAlignEnabled <span class="keyword">false</span></div><div class="line">            shrinkResources <span class="keyword">false</span></div><div class="line">            signingConfig signingConfigs.debug</div><div class="line">        }</div><div class="line"></div><div class="line">        release {</div><div class="line">            <span class="comment">// 不显示Log</span></div><div class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></div><div class="line"></div><div class="line">            minifyEnabled <span class="keyword">true</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line">            signingConfig signingConfigs.release</div><div class="line"></div><div class="line">            applicationVariants.all { variant -&gt;</div><div class="line">                variant.outputs.<span class="keyword">each</span> { output -&gt;</div><div class="line">                    <span class="keyword">def</span> outputFile = output.outputFile</div><div class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> && outputFile.name.endsWith(<span class="string">'.apk'</span>)) {</div><div class="line">                    	<span class="comment">// 输出apk名称为boohee_v1.0_2015-01-15_wandoujia.apk</span></div><div class="line">                        <span class="keyword">def</span> fileName = <span class="string">"boohee_v${defaultConfig.versionName}_${releaseTime()}_${variant.productFlavors[0].name}.apk"</span></div><div class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 友盟多渠道打包</span></div><div class="line">    productFlavors {</div><div class="line">        wandoujia {}</div><div class="line">        _360 {}</div><div class="line">        baidu {}</div><div class="line">        xiaomi {}</div><div class="line">        tencent {}</div><div class="line">        taobao {}</div><div class="line">        ...</div><div class="line">    }</div><div class="line"></div><div class="line">    productFlavors.all { flavor -&gt;</div><div class="line">        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> {</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</div><div class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:support-v4:21.0.3'</span></div><div class="line">    <span class="keyword">compile</span> <span class="string">'com.jakewharton:butterknife:6.0.0'</span></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大家有问题或疑问、建议欢迎博客留言，Android Studio的教程暂且到这里结束了，相信大家基本的都已会使用了，还有其他技巧与操作靠大家自己摸索了，之后有时间也会在博客上整理下一些Tips之类的，欢迎大家关注。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://stormzhang.com/devtools/2015/01/15/android-studio-tutorial6/" target="_blank" rel="external">Android Studio系列教程六--Gradle多渠道打包 </a>,</p>
<blockquote>
<p>美团采用了另外一种hack的方式快速为多渠道打包： <a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">美团Android自动化之旅—生成渠道包</a>,在META-INF文件夹下添加不同的空文件。</p>
</blockquote>
<p>由于国内Android市场众多渠道，为了统计每个渠道的下载及其它数据统计，就需要我们针对每个渠道单独打包，如果让你打几十个市场的包岂不烦死了，不过有了Gradle，这再也不是事了。<br>]]>
    
    </summary>
    
      <category term="Gradle" scheme="http://colobu.com/tags/Gradle/"/>
    
      <category term="Android" scheme="http://colobu.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty 5.0 中的新变化和注意点]]></title>
    <link href="http://colobu.com/2015/08/18/netty-new-and-noteworthy-in-5-0/"/>
    <id>http://colobu.com/2015/08/18/netty-new-and-noteworthy-in-5-0/</id>
    <published>2015-08-18T03:21:16.000Z</published>
    <updated>2015-08-18T07:13:04.366Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自官方文档<a href="http://netty.io/wiki/new-and-noteworthy-in-5.0.html" target="_blank" rel="external">New and noteworthy in 5.0</a>.<br>本文带你了解Netty 5.0 的值得注意的改变和新特性,帮助你将应用程序迁移到最新的版本.</p>
<p>不像 3.x 和 4.0 之间的改变那么大, 5.0 并没有很大的改变，尽管它在设计的简化性上做了一些突破. 我们尽可能平滑地使4.x转换到5.0,但是如果在迁移的过程中有问题请让我们知道.</p>
<p>其它版本之间的改变和新特性文档请看：<br><a href="/2015/08/18/netty-new-and-noteworthy-in-4-1/">Netty 4.1中的新变化和注意点</a><br><a href="/2015/08/18/netty-new-and-noteworthy-in-4-0/">Netty 4.0中的新变化和注意点</a></p>
<a id="more"></a>
<h2 id="核心改变">核心改变</h2>
<h3 id="简化_handler_类型继承关系">简化 handler 类型继承关系</h3>
<p><code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 被合并到 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>. 现在ChannelHandler拥有inbound 和 outbound handler 方法.</p>
<p><code>ChannelInboundHandlerAdapter</code>, <code>ChannelOutboundHandlerAdapter</code>, 和 <code>ChannelDuplexHandlerAdapter</code> 弃用了， 被 <code>ChannelHandlerAdapter</code> 取代.</p>
<p>因为现在你无法区分一个 handler是 inbound handler 或者 outbound handler, 所以<code>CombinedChannelDuplexHandler</code> 被 <code>ChannelHandlerAppender</code>取代.</p>
<p>想了解这个改变的更多信息，请看 <a href="https://github.com/netty/netty/pull/1999" target="_blank" rel="external">pull request #1999</a>.</p>
<h3 id="channelRead0()_→_messageReceived()">channelRead0() → messageReceived()</h3>
<p>我知道，这是一个<a href="https://github.com/netty/netty/issues/1590" target="_blank" rel="external">傻傻的错误</a>. 如果你正在使用<code>SimpleChannelInboundHandler</code>, 你不得不将<code>channelRead0()</code>重命名为<code>messageReceived()</code>.</p>
<h3 id="更灵活的线程模型">更灵活的线程模型</h3>
<p>在Netty 4.x中， 每个<code>EventLoop</code>和一个固定的线程紧密耦合， 这个线程会执行它注册的channel的所有的I/O事件，以及指派给它的任务.<br>在5.0中， 一个EventLoop不再直接使用线程，而是使用一个 <code>Executor</code>. 也就是， 它使用一个 <code>Executor</code> 对象作为构造函数的参数，以前是在一个无尽的循环中拉取I/O事件， 吸纳在是每次迭代的结果是一个task，将此task提交给<code>Executor</code>执行.<br>如果没有特别指定，<code>Executor</code>默认使用 <code>ForkJoinPool</code>. <code>ForkJoinPool</code>使用thread-local 队列. 也就是说, 从线程A中提交到<code>ForkJoinPool</code>到非常可能再由线程A执行. 这提供了EventLoop高层次的thread affinity.</p>
<p>而且，程序员也可以提供他们自己的<code>Executor</code> (也叫做 thread pool) 调度 <code>EventLoop</code>. 一个场景可以证明它有用：当 Netty用作大规模的软件系统中. 假定此系统已经使用一个线程池并发地执行它的任务. Netty 4.x简单的产生大量的线程，完全不顾它是一个大规模系统的一部分. 自Netty 5.0起, 开发者可以运行 Netty 和系统的其它部分在同一个线程池中， 通过应用更好的调度策略和较少的调度开支可以潜在地提高性能. 细节讨论可以参照 <a href="https://github.com/netty/netty/issues/2250" target="_blank" rel="external">GitHub issue 2250</a>.</p>
<p>应该提到的是，这个改变不会影响<code>ChannelHandlers</code>的方式. 在开发者看来，唯一改变的是不再保证同一个 <code>ChannelHandler</code> 会被同一个线程执行. 然而可以保证的是， 它不会同时被两个或者两个以上的线程执行.此外, Netty 会负责内存可见性的问题，所以不必担心线程安全性和 ChannelHandler的<code>volatile</code>变量.</p>
<p>这个改变的另一个影响就是 <code>NioEventLoop</code>, <code>NioEventLoopGroup</code>, <code>EpollEventLoop</code> 和 <code>EpollEventLoopGroup</code> 不再使用<code>ThreadFactory</code>作为构造函数的参数. 这些构造函数现在取而代之使用<code>Executor</code> 和 <code>ExecutorFactory</code>对象.</p>
<h3 id="更好的Channel-deregister(-)">更好的<code>Channel.deregister(...)</code></h3>
<p>Netty 4.0引入了<code>Channel.deregister(...)</code>, 5.0中它的行为被更新了以便符合Netty的线程模型.<br>现在可以保证在<code>ChannelHandler</code>中提交到<code>EventLoop</code>中的所有task在Channel取消注册(deregister)前都会被EventLoop执行<br>然而<code>Channel.deregister(...)</code>保留了非阻塞的操作，所以你不得不等待 返回的<code>ChannelFuture</code>成功后才能将它安全的注册到另一个<code>EventLoop</code>.</p>
<p>当调用<code>Channel.deregister(...)</code>后任何尝试在这个<code>ChannelHandler</code>中提交新的task (Runnable 或 Callable) 到会触发 <code>RejectedExecutionException</code>. 一旦这个 <code>Channel</code>注册到另外一个<code>EventLoop</code>, 一切归于正常.</p>
<p><code>ChannelHandler</code>通过 <code>EventLoop.schedule*(...)</code>方法提交的task当Channel取消注册后会停止执行, 当Channel再次注册时这些task会自动移到新的<code>EventLoop</code>中继续执行. 这个限制只会影响在Channel取消注册时被调度的task. 那么delay的或者定期执行的task不受影响.</p>
<p>你也可以突破这个限制，尽管不被推荐.  Netty 5.0 引入了一个新的方法 <code>EventLoop.unwrap()</code>, 它返回原始的<code>EventLoop</code>并不会执行一个健全的检查. 更准确的讲， 当提交task或者调度task到 &quot;unwrapped&quot; EventLoop时, 不会保证这些task会被并发执行，调度的task也不保证自动移到新的EventLoop.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自官方文档<a href="http://netty.io/wiki/new-and-noteworthy-in-5.0.html" target="_blank" rel="external">New and noteworthy in 5.0</a>.<br>本文带你了解Netty 5.0 的值得注意的改变和新特性,帮助你将应用程序迁移到最新的版本.</p>
<p>不像 3.x 和 4.0 之间的改变那么大, 5.0 并没有很大的改变，尽管它在设计的简化性上做了一些突破. 我们尽可能平滑地使4.x转换到5.0,但是如果在迁移的过程中有问题请让我们知道.</p>
<p>其它版本之间的改变和新特性文档请看：<br><a href="/2015/08/18/netty-new-and-noteworthy-in-4-1/">Netty 4.1中的新变化和注意点</a><br><a href="/2015/08/18/netty-new-and-noteworthy-in-4-0/">Netty 4.0中的新变化和注意点</a></p>
]]>
    
    </summary>
    
      <category term="Netty" scheme="http://colobu.com/tags/Netty/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty 4.1中的新变化和注意点]]></title>
    <link href="http://colobu.com/2015/08/18/netty-new-and-noteworthy-in-4-1/"/>
    <id>http://colobu.com/2015/08/18/netty-new-and-noteworthy-in-4-1/</id>
    <published>2015-08-18T01:34:06.000Z</published>
    <updated>2015-08-18T03:03:07.050Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自官方文档<a href="http://netty.io/wiki/new-and-noteworthy-in-4.1.html" target="_blank" rel="external">New and noteworthy in 4.1</a>，</p>
<p>本文带你了解Netty 4.0到Netty 4.1的值得注意的改变和新特性.<br><a id="more"></a></p>
<h2 id="题外话">题外话</h2>
<p>尽管我们尽量保持向下兼容，4.1 还是有一些和4.0不完全兼容的地方. 请确保使用新的Netty版本重新编译你的应用.<br>当你重新编译你的应用时，你可以能看到一些弃用警告. 请依照修改建议来更正它们, 这样当你升级到新的版本时会遇到较少的麻烦.</p>
<h2 id="核心改变">核心改变</h2>
<h3 id="Android支持">Android支持</h3>
<p>考虑到:</p>
<ul>
<li>移动设备日益强大</li>
<li>自 Ice Cream Sandwich版本后ADK中大部分NIO 和 SSLEngine的问题都被修复</li>
<li>用户很想在移动应用中重用它们的编解码器和handler</li>
</ul>
<p>我们决定官方的支持 Android (4.0 及以上版本) .<br>然而，我们并没有一个为Android提供的测试套件. 如果你发现在Android使用的问题, 请提交一个 issue. 也请考虑贡献Android的测试代码作为整个构建过程的一部分.</p>
<h3 id="ChannelHandlerContext-attr(-)_==_Channel-attr(-)"><code>ChannelHandlerContext.attr(..) == Channel.attr(..)</code></h3>
<p><a href="http://netty.io/4.1/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>和 <a href="http://netty.io/4.1/api/io/netty/channel/ChannelHandlerContext.html" target="_blank" rel="external">ChannelHandlerContext</a>实现了 <a href="http://netty.io/4.1/api/io/netty/util/AttributeMap.html" target="_blank" rel="external">AttributeMap</a>接口， 允许用户附加一个或者多个属性在它们上. 有时候用户迷惑的是[<a href="http://netty.io/4.1/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>和 <a href="http://netty.io/4.1/api/io/netty/channel/ChannelHandlerContext.html" target="_blank" rel="external">ChannelHandlerContext</a>用户自己的属性存储. 例如，即使你通过<code>Channel.attr(KEY_X).set(valueX)</code>设置一个属性&#39;KEY_X&#39; , 你也不会通过<code>ChannelHandlerContext.attr(KEY_X).get()</code>得到这个属性， 相反亦然. 这种行为不仅让人迷惑，而且也浪费内存.</p>
<p>为了解决这个问题, 我们决定为每个Channel在内部只保留一个map. AttributeMap总是使用<a href="http://netty.io/4.1/api/io/netty/util/AttributeKey.html" target="_blank" rel="external">AttributeKey</a> 作为它的主键. AttributeKey确保主键的唯一性, 这样每个Channel不会有多余一个的attribute map. 由于用户会将他们自己的主键定义为 <a href="http://netty.io/4.1/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的private static final 字段 , 不会有重复的键值的担忧.</p>
<h3 id="Channel-hasAttr(-)"><code>Channel.hasAttr(...)</code></h3>
<p>现在我们可以有效地检查一个属性是否存在.</p>
<h3 id="更容易更精确的追踪buffer_leak">更容易更精确的追踪buffer leak</h3>
<p>先前， 找到buffer泄漏并不容易,泄漏警告不太有帮助. 现在我们有了一个先进的泄漏报告机制，当开销增加时会被启用。(We now have an advanced leak reporting mechanism which can be enabled at the cost of increased overhead.)</p>
<p>查看<a href="https://github.com/netty/netty/wiki/Reference-counted-objects" target="_blank" rel="external">Reference counted objects</a>得到更多信息 . 这个特性太重要了，所以也被增加回 4.0.14.</p>
<h3 id="PooledByteBufAllocator作为默认的buffer_allocator"><code>PooledByteBufAllocator</code>作为默认的buffer allocator</h3>
<p>在 4.x 中,  尽管有一些功能局限性， <code>UnpooledByteBufAllocator</code> 曾是默认的allocator. 现在 <code>PooledByteBufAllocator</code> 已经使用了很长一段时间了，而且我们有了先进的buffer泄漏追踪机制，是时候把它作为默认的buffer allocator了.</p>
<p>现在<code>PooledByteBufAllocator</code> 是默认的buffer allocator.</p>
<h3 id="全局唯一的_channel_ID">全局唯一的 channel ID</h3>
<p>每个Channel都有一个唯一的ID,依据一下信息产生：</p>
<ul>
<li>MAC 地址 (EUI-48 or EUI-64), </li>
<li>进程 ID,</li>
<li><code>System#currentTimeMillis()</code></li>
<li><code>System#nanoTime()</code></li>
<li>一个随机的 32-bit integer</li>
<li>一个顺序增加的32-bit integer.</li>
</ul>
<p>Channe ID可以通过 <code>Channel.id()</code>方法得到.</p>
<h3 id="更灵活的线程模型">更灵活的线程模型</h3>
<p>一个新的<a href="http://netty.io/4.1/api/io/netty/channel/ChannelHandlerInvoker.html" target="_blank" rel="external">ChannelHandlerInvoker</a> 加入， 允许用户对哪个线程处理handler方法有更多的控制<br>作为往<a href="http://netty.io/4.1/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>中增加<a href="http://netty.io/4.1/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>时指定<a href="http://netty.io/4.1/api/io/netty/util/concurrent/EventExecutor.html" target="_blank" rel="external">EventExecutor</a>的替代，指定一个定制的<code>ChannelHandlerInvoker</code>实现可以实现更多的控制.</p>
<p>想了解更多的信息,可以参考 <a href="https://github.com/netty/netty/commit/132af3a485015ff912bd567a47881814d2ce1828" target="_blank" rel="external">commit 132af3a</a>.</p>
<h3 id="EmbeddedChannel_可用性">EmbeddedChannel 可用性</h3>
<p><a href="http://netty.io/4.1/api/io/netty/channel/embedded/EmbeddedChannel.html" target="_blank" rel="external">EmbeddedChannel</a> 的<code>readInbound()</code> 和 <code>readOutbound()</code>  返回一个 特定类型的参数， 你不必将返回值在转型， 减少了单元测试代码的啰嗦.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EmbeddedChannel ch = ...;</div><div class="line"></div><div class="line"><span class="comment">// BEFORE:</span></div><div class="line">FullHttpRequest req = (FullHttpRequest) ch.readInbound();</div><div class="line"></div><div class="line"><span class="comment">// AFTER:</span></div><div class="line">FullHttpRequest req = ch.readInbound();</div></pre></td></tr></table></figure>

<h3 id="能够使用Executor替换ThreadFactory">能够使用<code>Executor</code>替换<code>ThreadFactory</code></h3>
<p>一些应用要求用户运行他们的任务在一个指定的<code>Executor</code>. 而4.x在创建event loop时需要用户指定的是<code>ThreadFactory</code> ，现在已经用<code>Executor</code>替换了.</p>
<p>关于这个改变的更多信息，你可以查看 <a href="https://github.com/netty/netty/pull/1762" target="_blank" rel="external">pull request #1762</a>.</p>
<h3 id="更友好的类加载器_Class_loader_friendliness">更友好的类加载器 Class loader friendliness</h3>
<p>在容器环境中一些类型如<code>AttributeKey</code>对应用程序来说不是太友好，现在没有这个问题了.</p>
<h3 id="ByteBufAllocator-calculateNewCapacity()"><code>ByteBufAllocator.calculateNewCapacity()</code></h3>
<p>计算可扩展的<code>ByteBuf</code>容量的代码从<code>AbstractByteBuf</code>移到<code>ByteBufAllocator</code>, 因为<code>ByteBufAllocator</code>更方便的知道它管理的buffer的容量计算信息.</p>
<h2 id="新的编解码和handler">新的编解码和handler</h2>
<ul>
<li>Binary memcache protocol codec</li>
<li>Compression codecs<pre><code><span class="bullet">* </span>BZip2
<span class="bullet">* </span>FastLZ
<span class="bullet">* </span>LZ4
<span class="bullet">* </span>LZF
</code></pre></li>
<li>DNS protocol codec</li>
<li>HAProxy protocol codec</li>
<li>MQTT protocol codec</li>
<li>SPDY/3.1 support</li>
<li>STOMP codec</li>
<li>SOCKSx codec, 支持版本 4, 4a, 和 5; 查看 <code>socksx</code>包.</li>
<li><a href="http://netty.io/4.1/api/io/netty/handler/codec/xml/XmlFrameDecoder.html" target="_blank" rel="external">XmlFrameDecoder</a> 允许处理XML文档流.</li>
<li><a href="http://netty.io/4.1/api/io/netty/handler/codec/json/JsonObjectDecoder.html" target="_blank" rel="external">JsonObjectDecoder</a> 允许处理JSON对象流.</li>
<li>IP filtering handlers</li>
</ul>
<h2 id="其它编解码的改变">其它编解码的改变</h2>
<h3 id="AsciiString">AsciiString</h3>
<p><a href="http://netty.io/4.1/api/io/netty/handler/codec/AsciiString.html" target="_blank" rel="external">AsciiString</a>是一个新的<code>CharSequence</code>实现, 包含的字符只占1个字节. 当你处理US-ASCII 或者 ISO-8859-1 字符串时可以节省空间.</p>
<p>例如, HTTP 编解码器和STOMP编解码器使用<code>AsciiString</code>处理header name. 因为将<code>AsciiString</code>编码到<code>ByteBuf</code>中不会有类型转换的代价，比String类型有更好的性能.</p>
<h3 id="TextHeaders"><code>TextHeaders</code></h3>
<p><a href="http://netty.io/4.1/api/io/netty/handler/codec/TextHeaders.html" target="_blank" rel="external">TextHeaders</a> 提供了一个通用的数据结构，类似Http Header类型的字符串 <a href="http://en.wikipedia.org/wiki/Multimap" target="_blank" rel="external">mutimap</a>.  <code>HttpHeaders</code>也用<code>TextHeaders</code>重写.</p>
<h3 id="MessageAggregator"><code>MessageAggregator</code></h3>
<p><a href="http://netty.io/4.1/api/io/netty/handler/codec/MessageAggregator.html" target="_blank" rel="external">MessageAggregator</a> 为聚合多个小消息成一个大消息提供了通用的功能，就像<code>HttpObjectAggregator</code>实现的那样. <code>HttpObjectAggregator</code>使用<code>MessageAggregator</code>进行了重写.</p>
<h3 id="HttpObjectAggregator更好的处理超出尺寸的消息"><code>HttpObjectAggregator</code>更好的处理超出尺寸的消息</h3>
<p>在4.0中在客户端发送消息前没有办法拒绝一个超过指定大小的HTTP 消息，即使 <code>100-continue</code> header已经设置.<br>4.1中增加了一个可以override方法，叫做<code>handleOversizedMessage</code>， 因此用户可以执行他想要的任务. 默认条件下, 它会返回一个 &#39;413 Request Entity Too Large&#39; response, 然后关闭连接.</p>
<h3 id="ChunkedInput_和_ChunkedWriteHandler"><code>ChunkedInput</code> 和 <code>ChunkedWriteHandler</code></h3>
<p><code>ChunkedInput</code> 有两个新的方法; <code>progress()</code> 和 <code>length()</code> 返回数据传输的进度以及流的程度. <code>ChunkedWriteHandler</code>使用这个信息通知 <code>ChannelProgressiveFutureListener</code>.</p>
<h3 id="SnappyFramedEncoder_和_SnappyFramedDecoder"><code>SnappyFramedEncoder</code> 和 <code>SnappyFramedDecoder</code></h3>
<p>这两个类被改名为<code>SnappyFrameEncoder</code> and <code>SnappyFrameDecoder</code>. T老的类被标记为弃用， 实际上它们是新的类的子类.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自官方文档<a href="http://netty.io/wiki/new-and-noteworthy-in-4.1.html" target="_blank" rel="external">New and noteworthy in 4.1</a>，</p>
<p>本文带你了解Netty 4.0到Netty 4.1的值得注意的改变和新特性.<br>]]>
    
    </summary>
    
      <category term="Netty" scheme="http://colobu.com/tags/Netty/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty 4.0中的新变化和注意点]]></title>
    <link href="http://colobu.com/2015/08/17/netty-new-and-noteworthy-in-4-0/"/>
    <id>http://colobu.com/2015/08/17/netty-new-and-noteworthy-in-4-0/</id>
    <published>2015-08-17T06:27:15.000Z</published>
    <updated>2015-08-18T01:31:43.650Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自官方文档<a href="http://netty.io/wiki/new-and-noteworthy-in-4.0.html" target="_blank" rel="external">New and noteworthy in 4.0</a>，</p>
<p>本文带你了解Netty 4.0的值得注意的改变和新特性，帮助你将应用程序从老的Netty迁移到最新的版本上。<br><a id="more"></a></p>
<h2 id="项目结构的改变">项目结构的改变</h2>
<p>Netty的包名从 <code>org.jboss.netty</code> 改成 <code>io.netty</code>， 因为 <a href="http://netty.io/news/2011/11/04/new-web-site.html" target="_blank" rel="external">我们不再是JBoss.org的一份子了</a>.<br>二进制的 JAR 文件被分成多个模块， 这样用户可以从类路径中排除不需要的特性.  当前的结构如下:</p>
<table>
<thead>
<tr>
<th>Artifact ID</th>
<th>Description                                       </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>netty-parent</code></td>
<td>Maven parent POM</td>
</tr>
<tr>
<td><code>netty-common</code></td>
<td>Utility classes and logging facade</td>
</tr>
<tr>
<td><code>netty-buffer</code></td>
<td><code>ByteBuf</code> API that replaces <code>java.nio.ByteBuffer</code></td>
</tr>
<tr>
<td><code>netty-transport</code></td>
<td>Channel API and core transports</td>
</tr>
<tr>
<td><code>netty-transport-rxtx</code></td>
<td><a href="http://goo.gl/vTFBv" target="_blank" rel="external">Rxtx</a> transport</td>
</tr>
<tr>
<td><code>netty-transport-sctp</code></td>
<td><a href="http://goo.gl/oXxaU" target="_blank" rel="external">SCTP</a> transport</td>
</tr>
<tr>
<td><code>netty-transport-udt</code></td>
<td><a href="http://udt.sourceforge.net/" target="_blank" rel="external">UDT</a> transport</td>
</tr>
<tr>
<td><code>netty-handler</code></td>
<td>Useful <code>ChannelHandler</code> implementations</td>
</tr>
<tr>
<td><code>netty-codec</code></td>
<td>Codec framework that helps write an encoder and a decoder</td>
</tr>
<tr>
<td><code>netty-codec-http</code></td>
<td>Codecs related with HTTP, Web Sockets, SPDY, and RTSP</td>
</tr>
<tr>
<td><code>netty-codec-socks</code></td>
<td>Codecs related with SOCKS protocol</td>
</tr>
<tr>
<td><code>netty-all</code></td>
<td>All-in-one JAR that combines all artifacts above</td>
</tr>
<tr>
<td><code>netty-tarball</code></td>
<td>Tarball distribution</td>
</tr>
<tr>
<td><code>netty-example</code></td>
<td>Examples</td>
</tr>
<tr>
<td><code>netty-testsuite-*</code></td>
<td>A collection of integration tests</td>
</tr>
<tr>
<td><code>netty-microbench</code></td>
<td>Microbenchmarks</td>
</tr>
</tbody>
</table>
<p>现在所有的 artifacts (除了 <code>netty-all.jar</code>) 都实现了 OSGi bundle, 可以用在你的 OSGi 容器中.</p>
<h2 id="通用_API_的改变">通用 API 的改变</h2>
<ul>
<li>Netty中大部分的操作都支持链式方法，简化了操作</li>
<li>不能配置的getter 不再有<code>get-</code> 前缀. (例如 <code>Channel.getRemoteAddress()</code> → <code>Channel.remoteAddress()</code>)</li>
<li>布尔属性仍然保留 <code>is-</code> 前缀， 避免造成迷惑 (例如 &#39;empty&#39;  既是形容词也是动词, 所以 <code>empty()</code> 有两个意思)</li>
<li>4.0 CR4 和 4.0 CR5之间的 改变请参照 <a href="http://netty.io/news/2013/06/18/4-0-0-CR5.html" target="_blank" rel="external">Netty 4.0.0.CR5 released with new-new API</a></li>
</ul>
<h2 id="Buffer_API_的改变">Buffer API 的改变</h2>
<h3 id="ChannelBuffer_→_ByteBuf"><code>ChannelBuffer</code> → <code>ByteBuf</code></h3>
<p>由于上面提到的项目结构的改变, buffer API可以作为一个独立的包使用.  即使你对使用Netty作为网络应用框架不感兴趣，你也可以使用buffer API.<br>因此, 类型名<code>ChannelBuffer</code> 不再合适了， 所以改名为 <code>ByteBuf</code>.</p>
<p>用来创建新buffer的工具类 <code>ChannelBuffers</code>被分成了两个工具类： <code>Unpooled</code>  和 <code>ByteBufUtil</code>.  从名字<code>Unpooled</code>上也能猜出, 4.0引入了池化的 <code>ByteBuf</code>， 可以通过 <code>ByteBufAllocator</code><br>的具体实现来分配(allocated).</p>
<h3 id="ByteBuf_不是一个接口，而是一个抽象类class"><code>ByteBuf</code> 不是一个接口，而是一个抽象类class</h3>
<p>根据我们内部的性能测试，将<code>ByteBuf</code> 从接口改为抽象类可以给总吞吐量带来5%的提升.</p>
<h3 id="大部分的buffer变成了动态的，具有可配置的最大容量">大部分的buffer变成了动态的，具有可配置的最大容量</h3>
<p>在3.x, buffer可以是固定大小或者动态的，固定大小的buffer一旦创建容量就不能改变。 而动态buffer的容量在<code>write*(...)</code>方法需要更多空间时可以改变。<br>自4.0开始， 所有的buffer都是动态的。 然而，它们要比以前的动态buffer更好。你可以更容易更安全地增加或者减少buffer的容量。因为提供了新的方法 <code>ByteBuf.capacity(int newCapacity)</code>所以<br>改变容量更容易。之所以说它安全， 是因为你可以设置一个最大容量，这样buffer就不会不限制的增长.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// No more dynamicBuffer() - use buffer().</span></div><div class="line">ByteBuf buf = Unpooled.buffer();</div><div class="line"></div><div class="line"><span class="comment">// Increase the capacity of the buffer.</span></div><div class="line">buf.capacity(<span class="number">1024</span>);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Decrease the capacity of the buffer (the last 512 bytes are deleted.)</span></div><div class="line">buf.capacity(<span class="number">512</span>);</div></pre></td></tr></table></figure>

<p>唯一的例外是那些使用wrappedBuffer方法包装的(wrapped)一个单一的buffer或者一个单一字节数组。你不能增加它的容量， 因为这样会使包装一个已有buffer的目的(节省内存复制)失去意义。<br>如果你想改变这样的buffer的容量, 你应该使用你需要的容量创建一个新的buffer， 然后将原来包装的buffer中的数据复制到这个新的buffer中.</p>
<h3 id="新的buffer类型:_CompositeByteBuf">新的buffer类型: <code>CompositeByteBuf</code></h3>
<p>一个名叫<code>CompositeByteBuf</code> 的buffer实现为composite buffer实现定义了多个高级操作。用户可以使用composite buffer节省大量的内存复制，只比随机访问buffer的代价大一点。<br>为了创建一个新的composite buffer, 可以像以前一样使用<code>Unpooled.wrappedBuffer(...)</code> ,  也可以使用<code>Unpooled.compositeBuffer(...)</code>, 或者 <code>ByteBufAllocator.compositeBuffer()</code>.</p>
<h3 id="可预知的NIO_buffer转型">可预知的NIO buffer转型</h3>
<p>在3.x中， <code>ChannelBuffer.toByteBuffer()</code> 以及它的变体所提供的约定并不那么明确。用户无法确定这些方法会返回一个拥有共享数据的视图buffer还是一个拥有独立数据的通过复制得到的buffer(a view buffer with shared data or a copied buffer with separate data)。<br> 4.0 中使用 <code>ByteBuf.nioBufferCount()</code>, <code>nioBuffer()</code>, 和 <code>nioBuffers()</code>代替<code>toByteBuffer()</code>.  如果<code>nioBufferCount()</code> 返回 <code>0</code>, 用户总是可以通过<code>copy().nioBuffer()</code>得到一个复制buffer.</p>
<h3 id="对小端序(Little_endian)支持的改变">对小端序(Little endian)支持的改变</h3>
<p>小端序(Little endian)的支持做了很大的改变。先前用户为了得到小端序buffer,可以通过 <code>LittleEndianHeapChannelBufferFactory</code> 或者按指定的字节序包装一个已有的buffer:<br>4.0 中增加了一个新的方法: <code>ByteBuf.order(ByteOrder)</code>， 它返回当前buffer对象的一个具有指定字节序的视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</div><div class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</div><div class="line"><span class="keyword">import</span> java.nio.ByteOrder;</div><div class="line"> </div><div class="line">ByteBuf buf = Unpooled.buffer(<span class="number">4</span>);</div><div class="line">buf.setInt(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line"><span class="comment">// Prints '00000001'</span></div><div class="line">System.out.format(<span class="string">"%08x%n"</span>, buf.getInt(<span class="number">0</span>)); </div><div class="line"> </div><div class="line">ByteBuf leBuf = buf.order(ByteOrder.LITTLE_ENDIAN);</div><div class="line"><span class="comment">// Prints '01000000'</span></div><div class="line">System.out.format(<span class="string">"%08x%n"</span>, leBuf.getInt(<span class="number">0</span>));</div><div class="line"> </div><div class="line"><span class="keyword">assert</span> buf != leBuf;</div><div class="line"><span class="keyword">assert</span> buf == buf.order(ByteOrder.BIG_ENDIAN);</div></pre></td></tr></table></figure>

<h3 id="池化buffer_Pooled_buffers">池化buffer Pooled buffers</h3>
<p>Netty 4引入了一个高性能的buffer池， 它是 <a href="http://www.canonware.com/jemalloc/" target="_blank" rel="external">jemalloc</a> 的变种， 组合了 <a href="http://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="external">buddy allocation</a> 和 <a href="http://en.wikipedia.org/wiki/Slab_allocation" target="_blank" rel="external">slab allocation</a>的功能.  有以下好处:<br>*减少了 GC 压力，因为使用unpooled buffer会带来频繁的内存分配和回收</p>
<ul>
<li>减少了内存的带宽消耗(memory bandwidth consumption) 因为新的内存不可避免地要用zero填充(初始化)</li>
<li>定时回收 direct buffers</li>
</ul>
<p>为了使用这个特性， 除非用户非要得到unpooled buffer, 他应该通过 <a href="http://netty.io/4.0/api/index.html?io/netty/buffer/AbstractByteBufAllocator.html" target="_blank" rel="external"><code>ByteBufAllocator</code></a>分配buffer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Channel channel = ...;</div><div class="line">ByteBufAllocator alloc = channel.alloc();</div><div class="line">ByteBuf buf = alloc.buffer(<span class="number">512</span>);</div><div class="line">....</div><div class="line">channel.write(buf);</div><div class="line"> </div><div class="line">ChannelHandlerContext ctx = ...</div><div class="line">ByteBuf buf2 = ctx.alloc().buffer(<span class="number">512</span>);</div><div class="line">....</div><div class="line">channel.write(buf2)</div></pre></td></tr></table></figure>

<p>一旦<code>ByteBuf</code> 被写入到远程端， 它立即自动地放回原来的buffer池中.</p>
<p>默认的 <code>ByteBufAllocator</code> 是 <code>PooledByteBufAllocator</code>. 如果你不想使用buffer池， 抑或你想使用自己的allocator, 使用 <code>Channel.config().setAllocator(...)</code> 设置可选的allocator， 比如 <code>UnpooledByteBufAllocator</code>.</p>
<p>注意: 当我们使用的默认allocator 是 <code>UnpooledByteBufAllocator</code>时， 一旦我们确保<code>PooledByteBufAllocator</code>没有内存泄漏的问题, 我们应该将默认的allocator换回<code>PooledByteBufAllocator</code>.</p>
<h4 id="ByteBuf_总是使用引用计数(reference_counted)"><code>ByteBuf</code> 总是使用引用计数(reference counted)</h4>
<p>为了精确的控制<code>ByteBuf</code>生命周期，Netty不再依赖垃圾回收器，而是使用一个显示的引用计数器.  基本规则如下:</p>
<ul>
<li>当 buffer 首次分配时, 它的初始引用计数为 1.</li>
<li>当buffer的引用计数降为0时，它被回收或者放回原始的buffer池中.</li>
<li>下面的动作会触发<code>IllegalReferenceCountException</code>异常:<ul>
<li>访问引用计数为0的buffer,</li>
<li>将引用计数降少为负数,</li>
<li>或者将引用计数的值超过 <code>Integer.MAX_VALUE</code>.</li>
</ul>
</li>
<li>衍生的buffers (比如 slices 和 duplicates) 和 交换的buffers (比如 little endian buffers) 和原buffer共享同一个引用计数器. 注意，当一个衍生的buffer创建时它的引用计数器不会改变.</li>
</ul>
<p>当 <code>ByteBuf</code> 在 <code>ChannelPipeline</code>中使用时,你需要注意一些额外的规则:</p>
<ul>
<li>管道中的每个 inbound (a.k.a. upstream) handler 必须release接收到的消息. Netty不会自动release 它们.<ul>
<li>注意 codec 框架的确自动 release消息， 用户如果想传递一个as-is message给下一个handler, 就不得不增加引用计数器 .</li>
</ul>
</li>
<li>当outbound (a.k.a. downstream) message 到达了管道的开始位置时，Netty会在写完它后 release it.</li>
</ul>
<h4 id="自动_buffer泄漏检查">自动 buffer泄漏检查</h4>
<p>尽管引用计数很强大，但却容易出错。为了帮助用户找到他们忘记release buffer的地方, 泄漏检查器会自动地将那些泄漏buffer分配时的堆栈信息输出到日志中.</p>
<p>因为泄漏检查器(leak detector)依靠<code>PhantomReference</code> 并且获取堆栈信息是一个花费很大的操作， 它只会采样大约1%的分配.  因此，最好运行应用程序相当长的时间来找到所有可能的泄漏是一个好主意.</p>
<p>只要所有的泄漏否被发现和修改， 你就可以将这个特性关闭， 通过<code>-Dio.netty.noResourceLeakDetection</code> JVM 参数. （译者: jinfo可以运行时修改jvm参数，但是不是所有的参数都能被它修改）</p>
<h2 id="io-netty-util-concurrent"><code>io.netty.util.concurrent</code></h2>
<p>除了 buffer API, 4.0还提供了写异步应用程序的一些通用的类，它们被放入包 <code>io.netty.util.concurrent</code>.  一些类如:</p>
<ul>
<li><code>Future</code> 和 <code>Promise</code> - 类似<code>ChannelFuture</code>, 但是不依赖 <code>Channel</code></li>
<li><code>EventExecutor</code> 和 <code>EventExecutorGroup</code> - 通用的 event loop API</li>
</ul>
<p>它们是channel API基础，文章后面会有解释.  例如, <code>ChannelFuture</code> 扩展 <code>io.netty.util.concurrent.Future</code> 而 <code>EventLoopGroup</code> 扩展 <code>EventExecutorGroup</code>.</p>
<p><img src="1.png" alt="Event loop type hierarchy diagram"></p>
<h2 id="Channel_API_的改变">Channel API 的改变</h2>
<p>在4.0中, 很多 <code>io.netty.channel</code> 包下的类都经历了大的整理 所以简单的文本搜索-替换不会将老的Netty 3.x 应用轻松迁移到 4.0.<br>这一节将尽量介绍这么大的变化背后的考量，而不是罗列所有的变化.</p>
<h3 id="改组_ChannelHandler_接口">改组 ChannelHandler 接口</h3>
<h4 id="Upstream_→_Inbound,_Downstream_→_Outbound">Upstream → Inbound, Downstream → Outbound</h4>
<p>术语 &#39;upstream&#39; 和 &#39;downstream&#39; 对新人来讲很让人困惑。 4.0 使用 &#39;inbound&#39; 和 &#39;outbound&#39; .</p>
<h4 id="新的_ChannelHandler_类型继承关系">新的 <code>ChannelHandler</code>  类型继承关系</h4>
<p>在3.x 中, <code>ChannelHandler</code> 只是一个 tag interface, 而 <code>ChannelUpstreamHandler</code>, <code>ChannelDownstreamHandler</code>, 和 <code>LifeCycleAwareChannelHandler</code> 定义了实际的 handler 方法.<br>在Netty 4中, <code>ChannelHandler</code> 合并了 <code>LifeCycleAwareChannelHandler</code> 连同许多新方法， 它们对inbound 和 outbound handler 很有用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>{</div><div class="line">    <span class="keyword">void</span> handlerAdded(ChannelHandlerContext ctx) <span class="keyword">throws</span> Exception;</div><div class="line">    <span class="keyword">void</span> handlerRemoved(ChannelHandlerContext ctx) <span class="keyword">throws</span> Exception;</div><div class="line">    <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) <span class="keyword">throws</span> Exception;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下图描绘了新的类型继承关系:</p>
<p><img src="2.png" alt="ChannelHandler type hierarchy diagram"></p>
<h4 id="ChannelHandler_不需要_event_object"><code>ChannelHandler</code>  不需要 event object</h4>
<p>在3.x中, 每个 I/O 操作都会创建安一个 <code>ChannelEvent</code> 对象.  对于每一次 read / write, 它都额外的创建一个新的 <code>ChannelBuffer</code>.<br>它极大地简化了Netty的内部处理，因为它代理了JVM的资源管理和buffer池.<br>然而，这经常也是Netty应用程序在高负载的情况下GC压力大的原因.</p>
<p>4.0完全移除了event object， 取而代之的是强类型的方法调用.  3.x 包含处理所有事件的handler method如 <code>handleUpstream()</code> 和 <code>handleDownstream()</code>, 但Netty 4.0中 每个 event 类型都有它自己的handler method:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Before:</span></div><div class="line"><span class="keyword">void</span> handleUpstream(ChannelHandlerContext ctx, ChannelEvent e);</div><div class="line"><span class="keyword">void</span> handleDownstream(ChannelHandlerContext ctx, ChannelEvent e);</div><div class="line"> </div><div class="line"><span class="comment">// After:</span></div><div class="line"><span class="keyword">void</span> channelRegistered(ChannelHandlerContext ctx);</div><div class="line"><span class="keyword">void</span> channelUnregistered(ChannelHandlerContext ctx);</div><div class="line"><span class="keyword">void</span> channelActive(ChannelHandlerContext ctx);</div><div class="line"><span class="keyword">void</span> channelInactive(ChannelHandlerContext ctx);</div><div class="line"><span class="keyword">void</span> channelRead(ChannelHandlerContext ctx, Object message);</div><div class="line"> </div><div class="line"><span class="keyword">void</span> bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise);</div><div class="line"><span class="keyword">void</span> connect(</div><div class="line">        ChannelHandlerContext ctx, SocketAddress remoteAddress,</div><div class="line">        SocketAddress localAddress, ChannelPromise promise);</div><div class="line"><span class="keyword">void</span> disconnect(ChannelHandlerContext ctx, ChannelPromise promise);</div><div class="line"><span class="keyword">void</span> close(ChannelHandlerContext ctx, ChannelPromise promise);</div><div class="line"><span class="keyword">void</span> deregister(ChannelHandlerContext ctx, ChannelPromise promise);</div><div class="line"><span class="keyword">void</span> write(ChannelHandlerContext ctx, Object message, ChannelPromise promise);</div><div class="line"><span class="keyword">void</span> flush(ChannelHandlerContext ctx);</div><div class="line"><span class="keyword">void</span> read(ChannelHandlerContext ctx);</div></pre></td></tr></table></figure>

<p><code>ChannelHandlerContext</code> 也根据上面改变而改变了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Before:</span></div><div class="line">ctx.sendUpstream(evt);</div><div class="line"> </div><div class="line"><span class="comment">// After:</span></div><div class="line">ctx.fireChannelRead(receivedMessage);</div></pre></td></tr></table></figure>

<p>所有这些改变意味着用户无法扩展一个不存在的 <code>ChannelEvent</code> 接口了.  然而用户怎么定义他自己的事件类型呢，比如 <code>IdleStateEvent</code>?<br>4.0的<code>ChannelInboundHandler</code> 有一个 <code>userEventTriggered()</code> handler method,可以用来处理这样的需求.</p>
<h4 id="简化channel_状态模型">简化channel 状态模型</h4>
<p>在3.x中，当一个新的Channel被创建并连接成功，至少三个ChannelStateEvent会被触发：channelOpen、channelBound以及channelConnected.当一个Channel关闭时，也至少有三个事件会被触发：channelDisconnected、channelUnbound以及channelClosed.<br><img src="3.png" alt="Netty 3 Channel state diagram"></p>
<p>但是，触发这么多事件的意义并不那么大。更有用的是当一个Channel进入可读或可写的状态时通知用户。<br><img src="4.png" alt="Netty 4 Channel state diagram"></p>
<p><code>channelOpen</code>, <code>channelBound</code>, 和 <code>channelConnected</code> 被合并到 <code>channelActive</code>.  <code>channelDisconnected</code>, <code>channelUnbound</code>, 和 <code>channelClosed</code> 被合并到 <code>channelInactive</code>.<br>同样 <code>Channel.isBound()</code> 和 <code>isConnected()</code> 也被合并为<code>isActive()</code>.</p>
<p>需要注意的是，<code>channelRegistered</code> and <code>channelUnregistered</code> 这两个事件与<code>channelOpen</code> and <code>channelClosed</code>并不等价。它们是在支持<code>Channel</code>的动态注册、注销以及再注册时被引入的新的状态，就像下图所示：<br><img src="5.png" alt="Netty 4 Channel state diagram for re-registration"></p>
<h4 id="write()_不会自动_flush"><code>write()</code> 不会自动 flush</h4>
<p>4.0 引入了新的操作 <code>flush()</code> 它可以显示地将<code>Channel</code>输出缓存输出. <code>write()</code>操作并不会自动 flush.  你可以把它想象成<code>java.io.BufferedOutputStream</code>, 除了 它工作于消息级这一点.<br>由于这个改变, 你必须万分小心，写入数据后不要忘了调用 <code>ctx.flush()</code> .  当然你也可以使用一个更直接的方法 <code>writeAndFlush()</code>.</p>
<h3 id="可知的和不易出错的入站流量挂起(暂停读取)">可知的和不易出错的入站流量挂起(暂停读取)</h3>
<p>(Sensible and less error-prone inbound traffic suspension)<br>3.x有一个由<code>Channel.setReadable(boolean)</code>提供的不是很明显的入站流量挂起机制。它在ChannelHandler之间带来了复杂的交互操作，同时handler由于不正确实现很容易互相干扰。</p>
<p>4.0里，增加了一个新的名为<code>read()</code> 的outbound操作。如果你使用<code>Channel.config().setAutoRead(false)</code>来关闭默认的auto-read标志，Netty不会读入任何东西，直到你显式地调用read()操作.<br>一旦你启动的<code>read()</code> 操作完成，同时channel再次停止读，一个名为<code>channelReadSuspended()</code>的inbound事件会被触发， 这样你就能够重新启动另一次的<code>read()</code> 操作。你同样也可以拦截<code>read()</code> 操作来执行更多高级的流量控制。</p>
<h4 id="暂停接受新的的连接">暂停接受新的的连接</h4>
<p>Netty 3.0 中用户没有办法停止接受新的连接， 除非使用阻塞的I/O线程或者关闭server socket.  4.0中 当auto-read没有设置时 <code>read()</code> 操作就像一个原始的channel.</p>
<h3 id="半关闭的socket">半关闭的socket</h3>
<p>TCP和SCTP允许用户关闭一个socket的outbound流量而不用完全关闭它。这样的socket被称为&quot;半关闭的socket&quot;,用户能够通过调用<code>SocketChannel.shutdownOutput()</code>方法来获取一个半关闭socket。如果一个远端关闭了outbound流量，<code>SocketChannel.read(..)</code>会返回-1，这看上去并没有和一个关闭了的连接有什么区别。</p>
<p>3.x没有 <code>shutdownOutput()</code> 操作。它总是在 <code>SocketChannel.read(..)</code> 返回-1的时候关闭连接。为了支持半关闭socket，4.0增加了<code>SocketChannel.shutdownOutput()</code> 方法，同时用户能设置<code>ALLOW_HALF_CLOSURE</code>的<code>ChannelOption</code> 来阻止Netty在<code>SocketChannel.read(..)</code> 返回-1的时候自动关闭连接. </p>
<h3 id="灵活的I/O线程分配">灵活的I/O线程分配</h3>
<p>在3.x里，一个 <code>Channel</code> 是由ChannelFactory创建的，同时新建的 <code>Channel</code> 会自动注册到一个隐藏的I/O线程。4.0使用新的名为 <code>EventLoopGroup</code> 的接口来替换<code>ChannelFactory</code> ，<code>EventLoopGroup</code>包含一个或多个<code>EventLoop</code>。一个新的<code>Channel</code> 也不会自动注册到<code>EventLoopGroup</code>，但用户可以显式调用<code>EventLoopGroup.register()</code> 来注册。</p>
<p>由于这个改变（例如，分离了<code>ChannelFactory</code>和I/O线程），用户可以注册不同的 <code>Channel</code>实现到同一个<code>EventLoopGroup</code>，或者同一个 <code>Channel</code>实现到不同的<code>EventLoopGroup</code>。<br>例如，你可以运行一个NIO server socket，NIO client socket，NIO UDP socket，以及虚拟机内的本地通道在同一个I/O线程里。在编写一个需要最小延迟的代理服务器时这确实很有用。 </p>
<h3 id="能够从一个已存在的jdk套接字上创建一个Channel">能够从一个已存在的jdk套接字上创建一个Channel</h3>
<p>3.x没有方法从已存在的jdk套接字（如<code>java.nio.channels.SocketChannel</code>. ）创建一个新的channel。4.0可以。 </p>
<h3 id="取消注册和重新注册一个Channel从/到一个I/O线程">取消注册和重新注册一个Channel从/到一个I/O线程</h3>
<p>3.x中一旦一个新的Channel被创建，它就完全绑定到一个单一的I/O线程上，直到它底层的socket关闭。在4.0中，用户能够从I/O线程里取消注册一个Channel来完全控制它底层jdk套接字。例如，你能够利用Netty提供的高层次非阻塞I/O的优势来解决复杂的协议，然后取消注册<code>Channel</code> 并且切换到阻塞模式来在可能的最大吞吐量下传输一个文件。当然，它能够再次注册已经取消了注册的<code>Channel</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">java.nio.channels.FileChannel myFile = ...;</div><div class="line">java.nio.channels.SocketChannel mySocket = java.nio.channels.SocketChannel.open();</div><div class="line"> </div><div class="line"><span class="comment">// Perform some blocking operation here.</span></div><div class="line">...</div><div class="line"> </div><div class="line"><span class="comment">// Netty takes over.</span></div><div class="line">SocketChannel ch = <span class="keyword">new</span> NioSocketChannel(mySocket);</div><div class="line">EventLoopGroup group = ...;</div><div class="line">group.register(ch);</div><div class="line">...</div><div class="line"> </div><div class="line"><span class="comment">// Deregister from Netty.</span></div><div class="line">ch.deregister().sync();</div><div class="line"> </div><div class="line"><span class="comment">// Perform some blocking operation here.</span></div><div class="line">mySocket.configureBlocking(<span class="keyword">true</span>);</div><div class="line">myFile.transferFrom(mySocket, ...);</div><div class="line"> </div><div class="line"><span class="comment">// Register back again to another event loop group.</span></div><div class="line">EventLoopGroup anotherGroup = ...;</div><div class="line">anotherGroup.register(ch);</div></pre></td></tr></table></figure>

<h3 id="调度任意的任务到I/O线程里运行">调度任意的任务到I/O线程里运行</h3>
<p>当一个<code>Channel</code>被注册到<code>EventLoopGroup</code>时，<code>Channel</code>实际上是注册到一个由<code>EventLoopGroup</code>管理 <code>EventLoop</code>中。<code>EventLoop</code>实现了 <code>java.util.concurrent.ScheduledExecutorService</code>接口。这意味着用户可以在一个用户channel归属的I/O线程里运行或调度一个任意的Runnable或Callable。使用良好设计的线程模型（稍后会介绍），编写一个线程安全的handler变得极其容易地。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>{</div><div class="line">    ...</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(ChannelHandlerContext ctx, Object msg, ChannelPromise p) {</div><div class="line">        ...</div><div class="line">        ctx.write(msg, p);</div><div class="line">        </div><div class="line">        <span class="comment">// Schedule a write timeout.</span></div><div class="line">        ctx.executor().schedule(<span class="keyword">new</span> MyWriteTimeoutTask(p), <span class="number">30</span>, TimeUnit.SECONDS);</div><div class="line">        ...</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="comment">// Run an arbitrary task from an I/O thread.</span></div><div class="line">        Channel ch = ...;</div><div class="line">        ch.executor().execute(<span class="keyword">new</span> Runnable() { ... });</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="简化shutdown">简化shutdown</h3>
<p><code>releaseExternalResources()</code>不再使用。你可以通过调用<code>EventLoopGroup.shutdownGracefully()</code>关闭所有打开的channel同时使所有I/O线程停止.</p>
<h3 id="类型安全的ChannelOption">类型安全的<code>ChannelOption</code></h3>
<p>有两种方法来配置Netty的<code>Channel</code>的socket参数。一种是明确地调用ChannelConfig的setter，例如<code>SocketChannelConfig.setTcpNoDelay(true)</code>.。这是最为类型安全的方法。另外一种是调用 <code>ChannelConfig.setOption()</code> 方法。有时候你不得不在运行时的时候socket决定要配置什么选项，这个方法就特别适合这样的情况。然而，在3.x里它是容易出错的，因为一个用户必需用一个字符串/对象对来指定选项。如果用户调用了错误的选项名或者值，他或她将会遇到一个<code>ClassCastException</code> 异常或指定的选项甚至可能会默默地忽视了。</p>
<p>4.0引入了名为<code>ChannelOption</code>的新的类型，它提供了类型安全地访问socket选项。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ChannelConfig cfg = ...;</div><div class="line"> </div><div class="line"><span class="comment">// Before:</span></div><div class="line">cfg.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</div><div class="line">cfg.setOption(<span class="string">"tcpNoDelay"</span>, <span class="number">0</span>);  <span class="comment">// Runtime ClassCastException</span></div><div class="line">cfg.setOption(<span class="string">"tcpNoDelays"</span>, <span class="keyword">true</span>); <span class="comment">// Typo in the option name - ignored silently</span></div><div class="line"> </div><div class="line"><span class="comment">// After:</span></div><div class="line">cfg.setOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</div><div class="line">cfg.setOption(ChannelOption.TCP_NODELAY, <span class="number">0</span>); <span class="comment">// Compile error</span></div></pre></td></tr></table></figure>

<h3 id="AttributeMap">AttributeMap</h3>
<p>在处理用户指令里，你可以附加任意的对象到<code>Channel</code>和<code>ChannelHandlerContext</code>。一个名为<code>AttributeMap</code>的新接口被加入了，它被<code>Channel</code>和<code>ChannelHandlerContext</code>继承。相反，<code>ChannelLocal</code>和<code>Channel.attachment</code>被移除。这些属性会在他们关联的<code>Channel</code> 垃圾回收的同时回收。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AttributeKey&lt;MyState&gt; STATE =</div><div class="line">            AttributeKey.valueOf(<span class="string">"MyHandler.state"</span>);</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span>(ChannelHandlerContext ctx) {</div><div class="line">        ctx.attr(STATE).set(<span class="keyword">new</span> MyState());</div><div class="line">        ctx.fireChannelRegistered();</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">        MyState state = ctx.attr(STATE).get();</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="新的_bootstrap_API">新的 bootstrap API</h3>
<p>bootstrap API已经被重写，尽管它的目的还是一样；它执行需要配置和运行服务器或客户端程序的典型步骤，通常能在样板代码里找到。<br>新的bootstrap同样采取了流式接口(fluent interface)。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">    <span class="comment">// Configure the server.</span></div><div class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">        b.group(bossGroup, workerGroup)</div><div class="line">         .channel(NioServerSocketChannel.class)</div><div class="line">         .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</div><div class="line">         .localAddress(<span class="number">8080</span>)</div><div class="line">         .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</div><div class="line">         .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</div><div class="line">             <span class="annotation">@Override</span></div><div class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span>(SocketChannel ch) <span class="keyword">throws</span> Exception {</div><div class="line">                 ch.pipeline().addLast(handler1, handler2, ...);</div><div class="line">             }</div><div class="line">         });</div><div class="line"> </div><div class="line">        <span class="comment">// Start the server.</span></div><div class="line">        ChannelFuture f = b.bind().sync();</div><div class="line"> </div><div class="line">        <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">        f.channel().closeFuture().sync();</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        <span class="comment">// Shut down all event loops to terminate all threads.</span></div><div class="line">        bossGroup.shutdownGracefully();</div><div class="line">        workerGroup.shutdownGracefully();</div><div class="line">        </div><div class="line">        <span class="comment">// Wait until all threads are terminated.</span></div><div class="line">        bossGroup.terminationFuture().sync();</div><div class="line">        workerGroup.terminationFuture().sync();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="ChannelPipelineFactory_→_ChannelInitializer"><code>ChannelPipelineFactory</code> → <code>ChannelInitializer</code></h4>
<p> 就像你在在上面的例子注意到的一样，<code>ChannelPipelineFactory</code> 不再存在了。而是由 <code>ChannelInitializer</code>来替换，它给予了<code>Channel</code> 和 <code>ChannelPipeline</code> 配置的更多控制。</p>
<p>请注意，你不能自己创建一个新的<code>ChannelPipeline</code>。通过观察目前为止的用例报告，Netty团队得到一个结论，让用户去创建自己的管道实现或者是继承默认的实现是没有好处的。因此，<code>ChannelPipeline</code> 不再让用户创建。<code>ChannelPipeline</code> 由 <code>Channel</code>自动创建。 </p>
<h3 id="ChannelFuture_→_ChannelFuture_和_ChannelPromise"><code>ChannelFuture</code> → <code>ChannelFuture</code> 和 <code>ChannelPromise</code></h3>
<p><code>ChannelFuture</code>已经被拆分为<code>ChannelFuture</code>和<code>ChannelPromise</code>。这不仅仅是让异步操作里的生产者和消费者间的约定更明显，同样也是得在使用从链中(如filtering)返回的<code>ChannelFuture</code>更加安全，因为<code>ChannelFuture</code>的状态是不能改变的。</p>
<p>由于这个改变，一些方法现在都采用<code>ChannelPromise</code> 而不是<code>ChannelFuture</code> 来改变它的状态。 </p>
<h2 id="良好定义的线程模型">良好定义的线程模型</h2>
<p>3.x中没有很好定义线程模型， 尽管3.5尝试修改它的不一致性。<br>4.0定义了一个严格的线程模型，可以帮助用户编写ChannelHandler， 而用户不必太担心线程安全.</p>
<ul>
<li>Netty 绝不会并发地调用 <code>ChannelHandler</code>&#39;的方法, 除非 <code>ChannelHandler</code> 被标记为 <code>@Sharable</code>. 这与handler方法的类型无关 - inbound, outbound,  life cycle event handler method.<ul>
<li>用户不必同步inbound or outbound event handler方法.</li>
<li>4.0 不允许增加 <code>ChannelHandler</code> 多次， 除非它被标记为 <code>@Sharable</code>.</li>
</ul>
</li>
<li>Netty 调用的<code>ChannelHandler</code>之间总是遵循 <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility" target="_blank" rel="external">happens-before</a> .<ul>
<li>用户不必定义<code>volatile</code>字段来保存 handler 的状态.</li>
</ul>
</li>
<li>用户往<code>ChannelPipeline</code>中增加handler时可以指定 <code>EventExecutor</code>.<ul>
<li>如果指定了一个<code>EventExecutor</code>, <code>ChannelHandler</code>的handler方法总是被这个指定的 <code>EventExecutor</code>执行.</li>
<li>如果没有指定, handler 方法总是被它的<code>Channel</code>注册的 <code>EventLoop</code> 执行.</li>
</ul>
</li>
<li>指派给handler或者channle的<code>EventExecutor</code> 和 <code>EventLoop</code> 总是单线程的.<ul>
<li>handler 方法总是被同一个线程调用.</li>
<li>如果使用多线程的<code>EventExecutor</code> 或 <code>EventLoop</code>, 首先会选择其中一个线程， 然后一直使用这个线程，直到取消注册（deregistration）.</li>
<li>如果在同意管道pipeline中的两个handler 被指派给不同的 <code>EventExecutor</code>, 它们可以被并发地调用.  如果它们访问共享数据， 用户必须小心线程安全 .</li>
</ul>
</li>
<li>增加到<code>ChannelFuture</code> 的<code>ChannelFutureListeners</code> 总是此<code>Channel</code>相关的<code>EventLoop</code> 执行.</li>
</ul>
<h3 id="没有_ExecutionHandler_了_-_它被放入核心代码中-">没有 <code>ExecutionHandler</code> 了 - 它被放入核心代码中.</h3>
<p>在你往<code>ChannelPipeline</code>增加<code>ChannelHandler</code> 时你可以指定一个<code>EventExecutor</code>, 这样管道总是使用这个<code>EventExecutor</code>来调用这个新增加的 <code>ChannelHandler</code>的handler方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Channel ch = ...;</div><div class="line">ChannelPipeline p = ch.pipeline();</div><div class="line">EventExecutor e1 = <span class="keyword">new</span> DefaultEventExecutor(<span class="number">16</span>);</div><div class="line">EventExecutor e2 = <span class="keyword">new</span> DefaultEventExecutor(<span class="number">8</span>);</div><div class="line"> </div><div class="line">p.addLast(<span class="keyword">new</span> MyProtocolCodec());</div><div class="line">p.addLast(e1, <span class="keyword">new</span> MyDatabaseAccessingHandler());</div><div class="line">p.addLast(e2, <span class="keyword">new</span> MyHardDiskAccessingHandler());</div></pre></td></tr></table></figure>

<h2 id="编解码框架的改变">编解码框架的改变</h2>
<p>编码解码器框架里有实质性的内部改变, 因为4.0需要一个handler来创建和管理它的buffer（看这篇文章的 Per-handler buffer章节）然而，从用户角度来看这些变化并不大。 </p>
<ul>
<li>核心编解码类移入到 <code>io.netty.handler.codec</code> 包下.</li>
<li><code>FrameDecoder</code> 被重新命名为 <code>ByteToMessageDecoder</code>.</li>
<li><code>OneToOneEncoder</code> 和 <code>OneToOneDecoder</code> 被<code>MessageToMessageEncoder</code> 和 <code>MessageToMessageDecoder</code> 取代.</li>
<li><code>decode()</code>, <code>decodeLast()</code>, <code>encode()</code> 的方法签名有些许改变以便支持泛型， 也移除了一些冗余的参数.</li>
</ul>
<h3 id="Codec_embedder_→_EmbeddedChannel">Codec embedder → <code>EmbeddedChannel</code></h3>
<p>Codec embedder 被 <code>io.netty.channel.embedded.EmbeddedChannel</code> 取代， 允许用户对任何包含编码解码器的管道进行测试.</p>
<h3 id="HTTP_codec">HTTP codec</h3>
<p>HTTP 解码器现在对每个HTTP消息中总是生成多个消息对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1       <span class="keyword">*</span> HttpRequest / HttpResponse</div><div class="line">0 - n   <span class="keyword">*</span> HttpContent</div><div class="line">1       <span class="keyword">*</span> LastHttpContent</div></pre></td></tr></table></figure>

<p>如果想了解更多的细节, 请参考最新的 <code>HttpSnoopServer</code> 例子.  如果你不想为每个HTTP消息生成多个消息, 你可以将一个 <code>HttpObjectAggregator</code> 加入到管道中.  <code>HttpObjectAggregator</code> 总是将多个消息转换成一个单一的<code>FullHttpRequest</code> 或者 <code>FullHttpResponse</code>.</p>
<h3 id="transport_实现的改变">transport 实现的改变</h3>
<p>新加了下面的 transports ：</p>
<ul>
<li>OIO SCTP transport</li>
<li>UDT transport</li>
</ul>
<h2 id="用例学习：迁移阶乘（Factorial）的例子">用例学习：迁移阶乘（Factorial）的例子</h2>
<p>这部分粗略地展示把阶乘例子从3.0迁移到4.0的步骤。阶乘例子已经移植到4.0了，它被放在io.netty.example.factorial包里。请浏览示例的源代码来看下每一处的变化。 </p>
<h3 id="迁移服务端">迁移服务端</h3>
<ol>
<li>使用新的bootstrap API重写 <code>FactorialServer.run()</code> 方法.<ol>
<li>不再使用 <code>ChannelFactory</code> .  初始化一个 <code>NioEventLoopGroup</code> (一个用来接受连接，其它的用来处理接受后的连接.</li>
</ol>
</li>
<li>重命名 <code>FactorialServerPipelineFactory</code> 为 <code>FactorialServerInitializer</code>.<ol>
<li>让它扩展 <code>ChannelInitializer&lt;Channel&gt;</code>.</li>
<li>不创建一个 <code>ChannelPipeline</code>, 而是通过 <code>Channel.pipeline()</code>得到它.</li>
</ol>
</li>
<li>让 <code>FactorialServerHandler</code> 扩展 <code>ChannelInboundHandlerAdapter</code>.<ol>
<li>用<code>channelInactive()</code>替换 <code>channelDisconnected()</code> .</li>
<li>不再使用handleUpstream().</li>
<li>将 <code>messageReceived()</code> 命名为 <code>channelRead()</code>， 并相应的调整方法签名.</li>
<li>用 <code>ctx.writeAndFlush()</code>替换 <code>ctx.write()</code> .</li>
</ol>
</li>
<li>让 <code>BigIntegerDecoder</code> 扩展 <code>ByteToMessageDecoder&lt;BigInteger&gt;</code>.</li>
<li>让 <code>NumberEncoder</code> 扩展 <code>MessageToByteEncoder&lt;Number&gt;</code>.<ol>
<li><code>encode()</code> 不再返回一个buffer.  由<code>ByteToMessageDecoder</code>负责将编码的数据填入到buffer中.</li>
</ol>
</li>
</ol>
<h3 id="迁移客户端">迁移客户端</h3>
<p>大部分和移植服务端差不多，但在编写一个潜在的大数据流时要注意。 </p>
<ol>
<li>使用新的 bootstrap API 重写 <code>FactorialClient.run()</code> 方法.</li>
<li>将 <code>FactorialClientPipelineFactory</code>  重命名为 <code>FactorialClientInitializer</code>.</li>
<li>让 <code>FactorialClientHandler</code> 扩展 <code>ChannelInboundHandlerAdapter</code></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自官方文档<a href="http://netty.io/wiki/new-and-noteworthy-in-4.0.html" target="_blank" rel="external">New and noteworthy in 4.0</a>，</p>
<p>本文带你了解Netty 4.0的值得注意的改变和新特性，帮助你将应用程序从老的Netty迁移到最新的版本上。<br>]]>
    
    </summary>
    
      <category term="Netty" scheme="http://colobu.com/tags/Netty/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty之Java堆外内存扫盲贴]]></title>
    <link href="http://colobu.com/2015/08/17/java-directbytebuffer/"/>
    <id>http://colobu.com/2015/08/17/java-directbytebuffer/</id>
    <published>2015-08-17T03:15:13.000Z</published>
    <updated>2015-08-20T01:10:23.640Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之Java堆外内存扫盲贴</a>, 作者: <a href="http://calvin1978.blogcn.com/" target="_blank" rel="external">江南白衣</a></p>
<p>Java的堆外内存本来是高贵而神秘的东西，只在一些缓存方案的收费企业版里出现。但自从用了Netty，就变成了天天打交道的事情，毕竟堆外内存能减少IO时的内存复制，不需要堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。</p>
<p>好在，Netty所用的堆外内存只是Java NIO的 DirectByteBuffer类，通读一次很快。还有一些sun.misc.*的类木有源码，要自己跑去<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/misc" target="_blank" rel="external">OpenJdk</a>那看个明白。</p>
<a id="more"></a>
<h2 id="堆外内存的创建">堆外内存的创建</h2>
<p>在DirectByteBuffer中，首先向Bits类申请额度，Bits类有一个全局的 totalCapacity变量，记录着全部DirectByteBuffer的总大小，每次申请，都先看看是否超限 -- 堆外内存的限额默认与堆内内存(由-XMX 设定)相仿，可用 -XX:MaxDirectMemorySize 重新设定。<br>如果已经超限，会主动执行Sytem.gc()，期待能主动回收一点堆外内存。然后休眠一百毫秒，看看totalCapacity降下来没有，如果内存还是不足，就抛出大家最头痛的OOM异常。<br>如果额度被批准，就调用大名鼎鼎的sun.misc.Unsafe去分配内存，返回内存基地址，Unsafe的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp#l583" target="_blank" rel="external">C++实现在此</a>，标准的malloc。然后再调一次Unsafe把这段内存给清零。跑个题，Unsafe的名字是提醒大家这个类只给Sun自家用的，你们别用，不然哪天Sun把它藏起来了你们就哭死。果然，<a href="http://www.infoq.com/cn/news/2015/08/Oracle-Carving-Unsafe-Strategy" target="_blank" rel="external">JDK9里就Oracle可能动手哦</a>。]<br>JDK7开始，DirectByteBuffer分配内存时默认已不做分页对齐，不会再每次分配并清零 实际需要＋分页大小(4k)的内存，这对性能应有较大提升，所以Oracle专门写在了<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/enhancements.html#jdk7" target="_blank" rel="external">Enhancements in Java I/O</a>里。<br>最后，创建一个Cleaner，并把代表清理动作的Deallocator类绑定 -- 降低Bits里的totalCapacity，并调用Unsafe调free去释放内存。Cleaner的触发机制后面再说。</p>
<h2 id="堆外内存基于GC的回收">堆外内存基于GC的回收</h2>
<p>存在于堆内的DirectByteBuffer对象很小，只存着基地址和大小等几个属性，和一个Cleaner，但它代表着后面所分配的一大段内存，是所谓的冰山对象。通过前面说的Cleaner，堆内的DirectByteBuffer对象被GC时，它背后的堆外内存也会被回收。<br>快速回顾一下堆内的GC机制，当新生代满了，就会发生young gc；如果此时对象还没失效，就不会被回收；撑过几次young gc后，对象被迁移到老生代；当老生代也满了，就会发生full gc。<br>这里可以看到一种尴尬的情况，因为DirectByteBuffer本身的个头很小，只要熬过了young gc，即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发full gc，如果没有别的大块头进入老生代触发full gc，就一直在那耗着，占着一大片堆外内存不释放。<br>这时，就只能靠前面提到的申请额度超限时触发的system.gc()来救场了。但这道最后的保险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果gc没在一百毫秒内完成，它仍然会无情的抛出OOM异常。还有，万一，万一大家迷信某个调优指南设置了-DisableExplicitGC禁止了system.gc()，那就不好玩了。<br>所以，堆外内存还是自己主动点回收更好，比如Netty就是这么做的。</p>
<h2 id="堆外内存的主动回收">堆外内存的主动回收</h2>
<p>对于Sun的JDK这其实很简单，只要从DirectByteBuffer里取出那个sun.misc.Cleaner，然后调用它的clean()就行。<br>前面说的，clean()执行时实际调用的是被绑定的Deallocator类，这个类可被重复执行，释放过了就不再释放。所以GC时再被动执行一次clean()也没所谓。<br>在Netty里，因为不确定跑在Sun的JDK里(比如安卓)，所以多废了些功夫来确定Cleaner的存在。</p>
<h2 id="Cleaner如何与GC相关联？">Cleaner如何与GC相关联？</h2>
<p>涨知识的时间到了，原来JDK除了StrongReference，SoftReference 和 WeakReference之外，还有一种PhantomReference，Phantom是幻影的意思，Cleaner就是PhantomReference的子类。<br>当GC时发现它除了PhantomReference外已不可达（持有它的DirectByteBuffer失效了），就会把它放进 Reference类pending list静态变量里。然后另有一条ReferenceHandler线程，名字叫 &quot;Reference Handler&quot;的，关注着这个pending list，如果看到有对象类型是Cleaner，就会执行它的clean()。</p>
<h2 id="其实">其实</h2>
<p>专家们说，OpenJDK没有接受<a href="https://www.owent.net/2013/07/ptmalloctcmalloc%E5%92%8Cjemalloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E7%A0%94%E7%A9%B6.html" target="_blank" rel="external">jemalloc</a>(redis们在用)的补丁，直接用malloc在OS里申请一段内存，比在已申请好的JVM堆内内存里划一块出来要慢，所以我们在Netty一般用池化的 PooledDirectByteBuf 对DirectByteBuffer进行重用 ，《Netty权威指南》说性能提升了23倍，所以基本不需要头痛堆外内存的释放。</p>
<p>文章持续修订，转载请保留原链接： <a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">http://calvin1978.blogcn.com/articles/directbytebuffer.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之Java堆外内存扫盲贴</a>, 作者: <a href="http://calvin1978.blogcn.com/" target="_blank" rel="external">江南白衣</a></p>
<p>Java的堆外内存本来是高贵而神秘的东西，只在一些缓存方案的收费企业版里出现。但自从用了Netty，就变成了天天打交道的事情，毕竟堆外内存能减少IO时的内存复制，不需要堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。</p>
<p>好在，Netty所用的堆外内存只是Java NIO的 DirectByteBuffer类，通读一次很快。还有一些sun.misc.*的类木有源码，要自己跑去<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/misc" target="_blank" rel="external">OpenJdk</a>那看个明白。</p>
]]>
    
    </summary>
    
      <category term="Netty" scheme="http://colobu.com/tags/Netty/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[雪球在股市风暴下的高可用架构改造分享]]></title>
    <link href="http://colobu.com/2015/08/17/snowball-arch/"/>
    <id>http://colobu.com/2015/08/17/snowball-arch/</id>
    <published>2015-08-17T02:30:27.000Z</published>
    <updated>2015-08-17T02:58:53.185Z</updated>
    <content type="html"><![CDATA[<p>本文根据唐福林老师在“高可用架构”微信群所做的《股市风暴下的雪球架构改造经验分享》整理而成，转发请注明来自微信公众号ArchNotes。</p>
<blockquote>
<p>唐福林，雪球首席架构师，负责雪球业务快速增长应对及服务性能与稳定架构优化工作。毕业于北京师范大学，硕士学位。之前曾任微博平台资深架构师，微博技术委员会成员。长期关注并从事互联网服务后端性能及稳定性架构优化工作。<br><a id="more"></a></p>
</blockquote>
<h2 id="雪球公司介绍">雪球公司介绍</h2>
<p>雪球 聪明的投资者都在这里。</p>
<ul>
<li>web 1.0：新闻资讯，股价信息，K线图</li>
<li>web 2.0：SNS 订阅，分享，聊天</li>
<li>web 3.0：移动 APP，交易闭环</li>
</ul>
<p>雪球现在员工数还不到<strong>100</strong>，其中技术人员占一半。去年9月C轮融资<strong>4kw刀</strong>。我们现在的技术栈由下列组件组成：<strong>Java，Scala，Akka，Finagle，Nodejs，Docker ，Hadoop</strong>。我们当前是租用IDC机房自建私有云，正在往“公私混合云”方向发展。<br>在雪球上，用户可以获取沪深港美2w+股票的新闻信息，股价变化情况，也可以获取债券，期货，基金，比特币，信托，理财，私募等等理财产品的各类信息，也可以关注雪球用户建立的百万组合，订阅它们的实时调仓信息，还可以关注雪球大V。雪球当前有百万日活跃用户，每天有4亿的API调用。App Store 财务免费榜第 18 名。历史上曾排到财务第二，总免费榜第 19。</p>
<h2 id="雪球当前总体架构">雪球当前总体架构</h2>
<p><img src="1.jpg" alt="雪球公司技术架构"><br>作为一个典型的移动互联网创业公司，雪球的总体架构也是非常典型的设计：</p>
<ul>
<li>最上层是三个端：web端，android端和iOS端。流量比例大约为 2：4：4 。web3.0 的交易功能，在 web 端并不提供。</li>
<li>接入层以及下面的几个层，都在我们的自建机房内部。雪球当前只部署了一个机房，还属于单机房时代。正在进行“私有云+公有云混合部署”方案推进过程中。</li>
<li>我们当前使用 nodejs 作为 web 端模板引擎。nodejs 模块与android 和 ios 的 app 模块一起属于大前端团队负责。</li>
<li>再往下是位于 nginx 后面的 api 模块。跟 linkedin 的 leo 和微博的 v4 一样，雪球也有一个遗留的大一统系统，名字就叫 snowball 。最初，所有的逻辑都在 snowball 中实现的。后来慢慢的拆出去了很多 rpc 服务，再后来慢慢的拆出去了一些 http api 做成了独立业务，但即便如此，snowball 仍然是雪球系统中最大的一个部署单元。</li>
<li>在需要性能的地方，我们使用 netty 搭建了一些独立的接口，比如 quoto server，是用来提供开盘期间每秒一次的股价查询服务，单机 qps 5w+，这个一会再细说；而 IM 服务，起初设计里是用来提供聊天服务，而现在，它最大的用途是提供一个可靠的 push 通道，提供 5w/s 的消息下发容量，这个也一会再细说。</li>
<li>雪球的服务化拆分及治理采用 twitter 开源的 finagle rpc 框架，并在上面进行了一些二次开发和定制。定制的功能主要集中在 access log 增强，和 fail fast，fail over 策略及降级开关等。 finagle 的实现比较复杂，debug 和二次开发的门槛较高，团队内部对此也进行了一些讨论。</li>
<li>雪球的业务比较复杂，在服务层中，大致可以分为几类：第一类是web1.0，2.0 及基础服务，我们称为社区，包括用户，帖子，新闻，股价，搜索等等，类比对象就是新浪财经门户+微博；第二类是组合及推荐，主要提供股票投资策略的展示和建议，类比对象是美国的motif；第三类是通道，类似股市中的“支付宝”，接入多家券商，提供瞬间开户，一键下单等等各种方便操作的功能。</li>
<li>雪球的业务实现中，包含很多异步计算逻辑，比如搜索建索引，比如股票涨跌停发通知，比如组合收益计算等等，为此，我们设计了一个独立的 Thread/Task 模块，方便管理所有的后台计算任务。但随着这些 task 越来越多，逻辑差异越来越大，一个统一的模块并不是总是最佳的方案，所以，我们又把它拆成了两大类：流式的，和批量式的。</li>
<li>雪球的推荐体系包括组合推荐“买什么”和个性化推荐。我们最近正在重新梳理我们的大数据体系，这个感兴趣的话可以单聊。</li>
<li>最下面是基础设施层。雪球基础设施层包括：redis，mysql，mq，zk，hdfs，以及容器 docker。</li>
<li>线上服务之外，我们的开发及后台设施也很典型：gitlab开发，jenkins打包，zabbix 监控系统向 openfalcon 迁移，redimine向confluence迁移，jira，以及内部开发的 skiing 后台管理系统。</li>
</ul>
<h2 id="雪球架构优化历程">雪球架构优化历程</h2>
<p>首先描述一下标题中的“股市动荡”定语修饰词吧：</p>
<ol>
<li>上证指数从年初的3000点半年时间涨到了5000多，6月12号达到最高点5200点，然后就急转直下，最大单日跌幅 8.48%，一路跌回4000点以下。最近一周都在3900多徘徊。</li>
<li>3月最后一周，A股开户 166万户，超过历史最高纪录 2007年5月第二周165万户。</li>
<li>4月份，证监会宣布A股支持单用户开设多账户。</li>
<li>6月底，证金公司代表国家队入场救市。</li>
<li>7月份，证监会宣布严打场外配资。<br><img src="2.jpg" alt="7月27号将近2000股跌停，IM推送消息数超过平时峰值300倍"></li>
</ol>
<p><img src="3.jpg" alt="外网带宽消耗，一年10倍的增长"></p>
<p><img src="4.jpg" alt="中国好声音广告第一晚，带来超过平时峰值200倍的注册量"></p>
<h3 id="挑战：小_VS_大">挑战：小 VS 大</h3>
<ul>
<li>小：小公司的体量，团队小，机器规模小</li>
<li>大：堪比大公司的业务线数量，业务复杂度，瞬间峰值冲击<br>雪球的业务线 = 1个新浪财经 + 1 个微博 + 1 个 motif + 1 个大智慧/同花顺。由于基数小，API调用瞬间峰值大约为平时峰值的 30+ 倍。</li>
</ul>
<h3 id="挑战：快速增长，移动互联网_+_金融，风口，A股大盘剧烈波动。">挑战：快速增长，移动互联网 + 金融，风口，A股大盘剧烈波动。</h3>
<p>首先，在app端，在我们核心业务从 web2.0 sns 向 3.0 移动交易闭环进化的过程中，我们开发了一个自己的 hybrid 框架：本地原生框架，加离线 h5 页面，以此来支撑我们的快速业务迭代。当前，雪球前端可以做到 2 周一个版本，且同时并行推进 3 个版本：一个在 app store 等待审核上线，一个在内测或公测，一个在开发。我们的前端架构师孟祥宇在今年的 wot 上有一个关于这方面的详细分享，有兴趣的可以稍后再深入了解。<br>雪球App实践—构建灵活、可靠的Hybrid框架 <a href="http://wot.51cto.com/2015mobile/" target="_blank" rel="external">http://wot.51cto.com/2015mobile/</a>      <a href="http://down.51cto.com/data/2080769" target="_blank" rel="external">http://down.51cto.com/data/2080769</a><br>另外，为了保障服务的可用性，我们做了一系列的“端到端服务质量监控”。感兴趣的可以搜索我今年4月份在环信SM meetup上做的分享《移动时代端到端的稳定性保障》。其中在 app 端，我们采用了一种代价最小的数据传输方案：对用户的网络流量，电池等额外消耗几乎为0</p>
<p>每个请求里带上前一个请求的结果</p>
<ul>
<li>succ or fail ： 1 char</li>
<li>失败原因：0 - 1 char</li>
<li>请求接口编号： 1 char</li>
<li>请求耗时：2 - 3 char</li>
<li>其它：网络制式，etc</li>
</ul>
<p>炒股的人大多都会盯盘：即在开盘期间，开着一个web页面或者app，实时的看股价的上下跳动。说到“实时”，美股港股当前都是流式的数据推送，但国内的A股，基本上都是每隔一段时间给出一份系统中所有股票现价的一个快照。这个时间间隔，理论上是3秒，实际上一般都在5秒左右。 交了钱签了合同，雪球作为合作方就可以从交易所下属的数据公司那里拿到数据了，然后提供给自己的用户使用。</p>
<p>刚才介绍总体架构图的时候有提到 quote server ，说到这是需要性能的地方。</p>
<p>业务场景是这样的，雪球上个人主页，开盘期间，每秒轮询一次当前用户关注的股票价格变动情况。在内部，所有的组合收益计算，每隔一段时间需要获取一下当前所有股票的实时价格。起初同时在线用户不多，这个接口就是一个部署在 snowball 中的普通接口，股价信息被实时写入 redis ，读取的时候就从 redis 中读。后来，A股大涨，snowball 抗不住了。于是我们就做了一个典型的优化：独立 server + 本地内存存储。开盘期间每次数据更新后，数据接收组件主动去更新 quote server 内存中的数据。 后续进一步优化方案是将这个接口以及相关的处理逻辑都迁移到公有云上去。</p>
<p>对于那些不盯盘的人，最实用的功能就是股价提醒了。在雪球上，你除了可以关注用户，还可以关注股票。如果你关注的某只股票涨了或跌了，我们都可以非常及时的通知你。雪球上热门股票拥有超过 50w 粉丝（招商银行，苏宁云商）粉丝可以设置：当这支股票涨幅或跌幅超过 x%（默认7%）时提醒我。曾经连续3天，每天超过1000股跌停，证监会开了一个会，于是接下来2天超过1000股涨停</p>
<p><strong>原来做法：</strong><br><em>股票涨（跌）x%，扫一遍粉丝列表，过滤出所有符合条件的粉丝，推送消息</em></p>
<p><strong>新做法：</strong><br>预先建立索引，开盘期间载入内存</p>
<ul>
<li>1%：uid1，uid2</li>
<li>2%：uid3，uid4，uid5</li>
<li>3%：uid6</li>
<li>问题：有时候嫌太及时了：频繁跌停，打开跌停，再跌停，再打开。。。的时候</li>
</ul>
<p>内部线上记录：</p>
<ul>
<li>4台机器。</li>
<li>单条消息延时 99% 小于 30秒。</li>
<li>下一步优化目标：99% 小于 10 秒</li>
</ul>
<h3 id="IM_系统最初的设计目标是为雪球上的用户提供一个聊天的功能">IM 系统最初的设计目标是为雪球上的用户提供一个聊天的功能</h3>
<ul>
<li>送达率第一</li>
<li>雪球IM：Netty + 自定义网络协议</li>
<li>Akka ： 每个在线client一个actor</li>
<li>推模式：client 在线情况下使用推模式</li>
<li>多端同步：单账号多端可登录，并保持各种状态同步</li>
</ul>
<p>移动互联网时代，除了微信qq以外的所有IM，都转型成了推送通道，核心指标变成了瞬间峰值性能。原有架构很多地方都不太合适了。</p>
<p>优化：</p>
<ul>
<li>分配更多资源：推送账号actor池</li>
<li>精简业务逻辑：重复消息只存id，实时提醒内容不推历史设备，不更新非活跃设备的session列表等等</li>
<li>本地缓存：拉黑等无法精简的业务逻辑迁移到本地缓存</li>
<li>优化代码：异步加密存储，去除不合理的 akka 使用</li>
</ul>
<p><em>akka这个解释一下：akka 有一个自己的 log adapter，内部使用一个 actor 来处理所有的 log event stream 。当瞬间峰值到来的时候，这个 event stream 一下子就堵了上百万条 log ，导致 gc 颠簸非常严重。最后的解决办法是，绕过 akka 的 log adapter，直接使用 logback 的 appender</em></p>
<p>线上记录：5w/s （主动限速）的推送持续 3 分钟，p99 性能指标无明显变化<br>7月10号我们在中国好声音上做了3期广告。在广告播出之前，我们针对广告可能带来的对系统的冲击进行了压力测试，主要是新用户注册模块，当时预估广告播出期间2小时新注册100万。<br>压测发现 DB 成为瓶颈：</p>
<ul>
<li>昵称检测 cache miss &gt; 40%</li>
<li>昵称禁用词 where like 模糊查询</li>
<li>手机号是否注册 cache miss &gt; 80%</li>
<li>注册新用户：5 insert</li>
</ul>
<p>优化：</p>
<ul>
<li>redis store：昵称，手机号</li>
<li>本地存储：昵称禁用词</li>
<li>业务流程优化：DB insert 操作同步改异步</li>
</ul>
<p>下一步优化计划：</p>
<ul>
<li>将 sns 系统中所有的上行操作都改成类似的异步模式</li>
<li>接口调用时中只更新缓存，而且主动设置5分钟过期，然后写一个消息到 mq 队列，队列处理程序拿到消息再做其它耗时操作。</li>
<li>为了支持失败重试，需要将主要的资源操作步骤都做成幂等。</li>
</ul>
<h3 id="前置模块HA">前置模块HA</h3>
<ul>
<li>合作方合规要求：业务单元部署到合作方内网，用户的敏感数据不允许离开进程内存</li>
<li>业务本身要求：业务单元本身为有状态服务，业务单元高可用</li>
</ul>
<p>解决方案：</p>
<ul>
<li>使用 Hazelcast In-Memory Data Grid 的 replication map 在多个 jvm 实例之间做数据同步。</li>
<li><p>java 启动参数加上 -XX:+DisableAttachMechanism -XX:-UsePerfData，禁止 jstack，jmap 等等 jdk 工具连接</p>
<p>  关于前置模块，其实还有很多很奇葩的故事，鉴于时间关系，这里就不展开讲了。以后有机会可以当笑话给大家讲。    </p>
</li>
</ul>
<h3 id="组合净值计算性能优化">组合净值计算性能优化</h3>
<ul>
<li>一支股票可能在超过20万个组合里（南车北车中车，暴风科技）</li>
<li>离线计算，存储计算后的结果</li>
<li>股价3秒变一次，涉及到这支股票的所有组合理论上也需要每 3 秒重新计算一次</li>
</ul>
<p>大家可能会问，为什么不用户请求时，实时计算呢？这是因为“组合净值”中还包括分红送配，分股，送股，拆股，合股，现金，红利等等，业务太过复杂，开发初期经常需要调整计算逻辑，所以就设计成后台离线计算模式了。当前正在改造，将分红送配逻辑做成离线计算，股价组成的净值实时计算。接口请求是，将实时计算部分和离线计算部分合并成最终结果。<br>实际上，我们的计算逻辑是比较低效的：循环遍历所有的组合，对每个组合，获取所有的价值数据，然后计算。完成一遍循环后，立即开始下一轮循环。</p>
<p>优化：</p>
<ul>
<li>分级：活跃用户的活跃组合，其它组合。</li>
<li>批量：拉取当前所有股票的现价到 JVM 内存里，这一轮的所有组合计算都用这一份股价快照。</li>
</ul>
<p>关于这个话题的更详细内容，感兴趣的可以参考雪球组合业务总监张岩枫在今年的 arch summit 深圳大会上的分享：构建高可用的雪球投资组合系统技术实践    <a href="http://sz2015.archsummit.com/speakers/201825" target="_blank" rel="external">http://sz2015.archsummit.com/speakers/201825</a></p>
<p>最后，我们还做了一些通用的架构和性能优化，包括jdk升级到8，开发了一个基于 zookeeper 的 config center 和开关降级系统</p>
<h2 id="聊聊关于架构优化的一些总结和感想">聊聊关于架构优化的一些总结和感想</h2>
<p>在各种场合经常听说的架构优化，一般都是优化某一个具体的业务模块，将性能优化到极致。而在雪球，我们做的架构优化更多的是从问题出发，解决实际问题，解决到可以接受的程度即可。可能大家看起来会觉得很凌乱，而且每个事情单独拎出来好像都不是什么大事。<br>我们在对一个大服务做架构优化时，一般是往深入的本质进行挖掘；当我们面对一堆架构各异的小服务时，“架构优化”的含义其实是有一些不一样的。大部分时候，我们并不需要（也没有办法）深入到小服务的最底层进行优化，而是去掉或者优化原来明显不合理的地方就可以了。<br>在快速迭代的创业公司，我们可能不会针对某一个服务做很完善的架构设计和代码实现，当出现各种问题时，也不会去追求极致的优化，而是以解决瓶颈问题为先。<br>即使我们经历过一回将 snowball 拆分服务化的过程，但当我们重新上一个新的业务时，我们依然选择将它做成一个大一统的服务。只是这一次，我们会提前定义好每个模块的 service 接口，为以后可能的服务化铺好路。<br>在创业公司里，重写是不能接受的；大的重构，从时间和人力投入上看，一般也是无法承担的。而“裱糊匠”式做法，哪里有性能问题就加机器，加缓存，加数据库，有可用性问题就加重试，加log，出故障就加流程，加测试，这也不是雪球团队工作方式。我们一般都采用最小改动的方式，即，准确定义问题，定位问题根源，找到问题本质，制定最佳方案，以最小的改动代价，将问题解决到可接受的范围内。<br>我们现在正在所有的地方强推3个数据指标：qps，p99，error rate。每个技术人员对自己负责的服务，一定要有最基本的数据指标意识。数字，是发现问题，定位根源，找到本质的最重要的依赖条件。没有之一。<br>我们的原则：保持技术栈的一致性和简单性，有节制的尝试新技术，保持所有线上服务依赖的技术可控，简单来说，能 hold 住。<br>能用cache的地方绝不用db，能异步的地方，绝不同步。俗称的：吃一堑，长一智。</p>
<p>特事特办：业务在发展，需求在变化，实现方式也需要跟着变化。简单的来说：遗留系统的优化，最佳方案就是砍需求，呵呵。<br>当前，雪球内部正在推行每个模块的方案和代码实现的 review，在 review 过程中，我一般是这样要求的：</p>
<p>技术方案：</p>
<ul>
<li>20倍设计，10倍实现，3倍部署</li>
<li>扩展性：凡事留一线，以后好相见</li>
</ul>
<p>技术实现：</p>
<ul>
<li>DevOps：上线后还是你自己维护的项目，实现的时候记得考虑各种出错的处理</li>
<li>用户投诉的时候需要你去解释，实现的时候注意各种边界和异常</li>
<li>快速实现，不是“随便实现”，万一火了呢：性能，方便扩容</li>
</ul>
<h2 id="Q&amp;A">Q&amp;A</h2>
<p><strong>Q1：im能详细讲下吗？</strong><br>关于雪球 im 和推模式，有群友问到了，我就再展开讲一下（其实下周我约了去给一家号称很文艺的公司内部交流IM实现）：雪球自己设计了一套 IM 协议，内部使用 netty 做网络层，akka 模式，即为每一个在线的 client new 一个 actor ，这个 actor 里面保持了这个在线 client 的所有状态和数据。如果有新消息给它，代码里只要把这个消息 tell 给这个 actor 即可。actor 里面会通过 netty 的 tcp 连接推给实际的 client。</p>
<p><strong>问一个小问题，App的接口可用上报里 如果是网络问题引起的故障 怎么兼容？</strong><br> app 如果发起一个请求，因为网络问题失败了（这其实是我们的上报体系设计时，最主要针对的场景），那么 app 会把这个失败的请求记录到本地内存，等下一次发请求时，把上次的这个失败请求结果及相关信息带上。如果连续多次失败，当前我们的做法是，只记录最后一次失败的请求结果，下次成功的请求里会带上它。</p>
<p><strong>监控系统为何从zabbix切换到openfalcon，原因是什么？</strong><br>简单来说，机器数上百之后，zabbix就会有很多问题，个人感受最大的问题是，新增 key 非常不方便。小米因为这些问题，自己做一个 falcon，然后开源了。我们碰到的问题很类似，看了看小米的，觉得可以不用自己再折腾了，就用它了。</p>
<p><strong>前置模块的Hazelcast In-Memory Data Grid 的稳定性怎么样，采用的考虑是什么呢？用sharding redis 怎么样呢？</strong><br>  稳定性不能算很好，只能说还好。因为上线几个月，已经出了一次故障了。采用它，主要是开发简单，因为它就只有一个 jar 包依赖，不像其它备选项，一个比一个大。至于为什么不用 redis，因为这是要部署到别人的内网的啊，更新很麻烦的啊，运维几乎没有的啊，各种悲剧啊。我们当前为了做到“一键更新”，把shell脚本和所有jar包都打成一个自解压的文件这事我会随便说吗？</p>
<p><strong>雪球im如何判断用户是否在线？要给给定的用户发消息，怎么找到对应的actor？不在线的时候消息如何存储？</strong><br>IM 用户在线判断（转化成指定的 actor 是否存在）和路由，这些都是 akka 内置提供的，感兴趣的，算了，我个人建议是不要去碰 akka 这货。用户不在线的时候，消息会进 mysql 和 redis</p>
<p><strong>大师，为了支持失败重试，需要将主要的资源操作步骤都做成幂等。这个怎么理解，具体怎么玩？</strong><br> 举个例子：用户发一个帖子，api调用的时候已经给用户返回成功了，但后端写 db 的时候超时了，怎么办？不能再告诉用户发帖失败了吧？那就重试重试再重试，直到写 db 成功。但万一重试的时候发现，上次写入超时，实际上是已经写成功了呢？那就需要把这个写入做成幂等，支持多次写入同一条记录。简单来说，db 层就是每个表都要有业务逻辑上的唯一性检查</p>
<p><strong>另外用户对应的Actor需不需要持久化呢？</strong><br>actor 不持久化。重启 server 的话，app 端会自动重连的</p>
<p><strong>基于zookeeper的config center设计有什么指导原则或遇到什么坑吗？如何方便业务开发修改又不影响到其他？</strong><br> 我们的 config center 有两个版本：一个是参考 netflix 的 archaius，另一个是纯粹的 zk style 。风格问题，我个人的回答是：大家喜欢就好。 config center 本来就不影响业务开发修改啊？没有太明白问题点，sorry</p>
<p><strong>刚才的追问下 如果只报最后一次故障 那么会不会不能准确评估影响？</strong><br> 不会的，因为这种情况一般都是用户进电梯或者进地铁了，呵呵</p>
<p><strong>rpc是怎么选的呢，比如为什么不用thrift呢？</strong><br>  finagle 底层就是 thrift 啊。就我个人而言，我个人对于任何需要预先定义 proto 的东西都深恶痛绝。所以现在我们也在尝试做一个基于 jsonrpc 的简单版本的 rpc 方案，作为我们后续微服务容器的默认 rpc</p>
<p><strong>实质上是用actor包住了netty的session吧？不建议用akka的原因是量大了后承载能力的问题吗？雪球im的dau约在50万左右吧？</strong><br>是的，actor 内部持有网络连接。不建议用 akka 的原因是：我个人的原则是，我 hold 不住的东西就不做推荐。就当前来说，我觉得我 hold 不住 akka：使用太简单太方便，但坑太多，不知道什么时候就踩上了，想用好太难了</p>
<p><strong>唐老师您好，雪球的架构中，rabbitmq 主要用在哪些场景，rabbit的 负载是通过哪些手段来做呢?</strong><br> 当前我们的 mq 功能都是有 rabbitmq 提供的，我们在内部封装了一个叫 event center 的模块，所有的跟 queue 打交道的地方，只需要调用 event center 提供的 api 即可。我们对于 rabbit 并没有做太多的调优，大约也是因为现在消息量不大的缘故。后续我们的大数据体系里，queue 的角色会由 kafka 来承担</p>
<p> <strong>唐大师，关于交易这块，能说下你们的账户体系吗？</strong><br>股票交易跟支付宝模式还是很大不一样的，本质上，雪球上只是一个纯粹的通道：钱和股票都不在雪球内部。所以，我们当前的账户体系就像我们页面上描述的那样：将用户的券商账号跟雪球id做绑定</p>
<p> <strong>性能规划上有什么经验或者推荐资料阅读吗？谢谢。</strong><br>通读 allthingsdistributed 上的精华文章 <a href="http://www.allthingsdistributed.com/" target="_blank" rel="external">http://www.allthingsdistributed.com/</a></p>
<p><strong>唐大师，雪球的docker是怎么用？怎么管理的？</strong><br>参考雪球sre高磊在 dockercn 上的分享</p>
<p><strong>追加一个问题：对业务合规要求的需求不是很了解，但是“-XX:+DisableAttachMechanism -XX:-UsePerfData”这样无法禁止“jstack -F”的吧，只是禁止了普通的jstack。</strong><br> 应该是可以禁止的，因为 jvm 内部所有挂载机制都没有启动，jstack 加 -f 也挂不上去。要不我一会测一下再给你确认？</p>
<p><strong>为什么用kafka替换rbt?</strong><br>因为 rbt 是 erlang 写的啊，我不会调优啊，出了问题我也不会排查啊。事实上，event center 模块极偶发的出现丢消息，但我们一直没有定位到根源。所以，只好换了</p>
<p><strong>请问百万活跃用户session是怎么存储的？怎么有效防止大面积退出登录？</strong><br>   用户登录 session 就存在 jvm 内部。因为是集群，只要不是集群突然全部挂，就不会出现大面积重新登录的</p>
<p><strong>每个请求里带上前一个请求的结果,这个得和用户请求绑定上吧？</strong><br>收集 app 端的访问结果，大部分情况下用于统计服务质量，偶尔也用于用户灵异问题的追逐</p>
<p><strong>akka的设计居然和Erlang的抢占式调度很像，也存在单进程瓶颈问题？</strong><br>可以这么说，主要是它的 log actor 是单个的</p>
<p><strong>集群环境下如何保存在jvm内部？各个jvm如何共享的？</strong><br> 我们的 im 系统其实分 2 层，前面有一层接入层，后面是集群。接入层到集群的链接是按 uid 一致性 hash。简单来说，一个用户就只连一个 jvm 服务节点。所以我们只在收盘后更新服务。在雪球，盘中严禁更新服务的</p>
<p> <strong>接入层的实现架构方便描述一下吗？</strong><br>  雪球IM的接入层分为2类：app接入层和web接入层。app接入层是一个 netty 的 server，开在 443 端口，但没有使用 ssl ，而是自己用 rsa 对消息体加密。netty 收到消息后，解包，根据包里的描述字段选择发往后端的业务节点。web 接入层是一个基于 play 的 webserver，实现了 http 和 websocket 接口，供 web 使用</p>
<p>雪球App是一款解决股票买什么好问题的手机炒股应用。因为独特的产品设计和运营策略，雪球App在市场上拥有领先的份额和影响力。雪球正在招聘，热招职位请参考 <a href="http://xueqiu.com/about/jobs" target="_blank" rel="external">http://xueqiu.com/about/jobs</a> (可点击阅读原文进入) 我们在望京 SOHO 等你！<br>本文策划 庆丰@微博, 内容由王杰编辑，庆丰校对与发布，Tim审校，其他多位志愿者对本文亦有贡献。读者可以通过搜索“ArchNotes”或长按下面图片，关注“高可用架构”公众号，查看更多架构方面内容，获取通往架构师之路的宝贵经验。转载请注明来自“高可用架构（ArchNotes）”公众号，敬请包含二维码！</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPoaibhicCyMkia552rIu4wAtUThl4HiaABoLpmOkKMHVKHnprghrbTXQia0zgJuNmlU5icoKflhYdhtqPQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文根据唐福林老师在“高可用架构”微信群所做的《股市风暴下的雪球架构改造经验分享》整理而成，转发请注明来自微信公众号ArchNotes。</p>
<blockquote>
<p>唐福林，雪球首席架构师，负责雪球业务快速增长应对及服务性能与稳定架构优化工作。毕业于北京师范大学，硕士学位。之前曾任微博平台资深架构师，微博技术委员会成员。长期关注并从事互联网服务后端性能及稳定性架构优化工作。<br>]]>
    
    </summary>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty Client重连实现]]></title>
    <link href="http://colobu.com/2015/08/14/netty-tcp-client-with-reconnect-handling/"/>
    <id>http://colobu.com/2015/08/14/netty-tcp-client-with-reconnect-handling/</id>
    <published>2015-08-14T08:36:09.000Z</published>
    <updated>2015-08-14T09:03:53.787Z</updated>
    <content type="html"><![CDATA[<p>当我们用Netty实现一个TCP client时，我们当然希望当连接断掉的时候Netty能够自动重连。<br>Netty Client有两种情况下需要重连：</p>
<ol>
<li>Netty Client启动的时候需要重连</li>
<li>在程序运行中连接断掉需要重连。</li>
</ol>
<p>对于第一种情况，Netty的作者在stackoverflow上给出了<a href="http://stackoverflow.com/questions/19739054/whats-the-best-way-to-reconnect-after-connection-closed-in-netty" target="_blank" rel="external">解决方案</a>，<br>对于第二种情况，Netty的例子uptime中实现了一种<a href="https://github.com/netty/netty/blob/master/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java" target="_blank" rel="external">解决方案</a>。</p>
<p> 而Thomas在他的<a href="http://tterm.blogspot.jp/2014/03/netty-tcp-client-with-reconnect-handling.html" target="_blank" rel="external">文章</a>中提供了这两种方式的实现的例子。</p>
<a id="more"></a>
<p>实现ChannelFutureListener 用来启动时监测是否连接成功，不成功的话重试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span>  </span></div><div class="line"> {  </div><div class="line">   <span class="keyword">private</span> EventLoopGroup loop = <span class="keyword">new</span> NioEventLoopGroup();  </div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>( String[] args )  </div><div class="line">   {  </div><div class="line">     <span class="keyword">new</span> Client().run();  </div><div class="line">   }  </div><div class="line">   <span class="keyword">public</span> Bootstrap <span class="title">createBootstrap</span>(Bootstrap bootstrap, EventLoopGroup eventLoop) {  </div><div class="line">     <span class="keyword">if</span> (bootstrap != <span class="keyword">null</span>) {  </div><div class="line">       <span class="keyword">final</span> MyInboundHandler handler = <span class="keyword">new</span> MyInboundHandler(<span class="keyword">this</span>);  </div><div class="line">       bootstrap.group(eventLoop);  </div><div class="line">       bootstrap.channel(NioSocketChannel.class);  </div><div class="line">       bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);  </div><div class="line">       bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {  </div><div class="line">         <span class="annotation">@Override</span>  </div><div class="line">         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span>(SocketChannel socketChannel) <span class="keyword">throws</span> Exception {  </div><div class="line">           socketChannel.pipeline().addLast(handler);  </div><div class="line">         }  </div><div class="line">       });  </div><div class="line">       bootstrap.remoteAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>);</div><div class="line">       bootstrap.connect().addListener(<span class="keyword">new</span> ConnectionListener(<span class="keyword">this</span>)); </div><div class="line">     }  </div><div class="line">     <span class="keyword">return</span> bootstrap;  </div><div class="line">   }  </div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {  </div><div class="line">     createBootstrap(<span class="keyword">new</span> Bootstrap(), loop);</div><div class="line">   }  </div><div class="line"> }</div></pre></td></tr></table></figure>

<p>ConnectionListener 负责重连：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionListener</span> <span class="keyword">implements</span> <span class="title">ChannelFutureListener</span> </span>{  </div><div class="line">  <span class="keyword">private</span> Client client;  </div><div class="line">  <span class="keyword">public</span> <span class="title">ConnectionListener</span>(Client client) {  </div><div class="line">    <span class="keyword">this</span>.client = client;  </div><div class="line">  }  </div><div class="line">  <span class="annotation">@Override</span>  </div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span>(ChannelFuture channelFuture) <span class="keyword">throws</span> Exception {  </div><div class="line">    <span class="keyword">if</span> (!channelFuture.isSuccess()) {  </div><div class="line">      System.out.println(<span class="string">"Reconnect"</span>);  </div><div class="line">      <span class="keyword">final</span> EventLoop loop = channelFuture.channel().eventLoop();  </div><div class="line">      loop.schedule(<span class="keyword">new</span> Runnable() {  </div><div class="line">        <span class="annotation">@Override</span>  </div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {  </div><div class="line">          client.createBootstrap(<span class="keyword">new</span> Bootstrap(), loop);  </div><div class="line">        }  </div><div class="line">      }, <span class="number">1</span>L, TimeUnit.SECONDS);  </div><div class="line">    }  </div><div class="line">  }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>同样在ChannelHandler监测连接是否断掉，断掉的话也要重连：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInboundHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span> </span>{  </div><div class="line">   <span class="keyword">private</span> Client client;  </div><div class="line">   <span class="keyword">public</span> <span class="title">MyInboundHandler</span>(Client client) {  </div><div class="line">     <span class="keyword">this</span>.client = client;  </div><div class="line">   }  </div><div class="line">   <span class="annotation">@Override</span>  </div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span>(ChannelHandlerContext ctx) <span class="keyword">throws</span> Exception {  </div><div class="line">     <span class="keyword">final</span> EventLoop eventLoop = ctx.channel().eventLoop();  </div><div class="line">     eventLoop.schedule(<span class="keyword">new</span> Runnable() {  </div><div class="line">       <span class="annotation">@Override</span>  </div><div class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {  </div><div class="line">         client.createBootstrap(<span class="keyword">new</span> Bootstrap(), eventLoop);  </div><div class="line">       }  </div><div class="line">     }, <span class="number">1</span>L, TimeUnit.SECONDS);  </div><div class="line">     <span class="keyword">super</span>.channelInactive(ctx);  </div><div class="line">   }  </div><div class="line"> }</div></pre></td></tr></table></figure>

<h4 id="参考文档">参考文档</h4>
<ol>
<li><a href="http://stackoverflow.com/questions/19739054/whats-the-best-way-to-reconnect-after-connection-closed-in-netty" target="_blank" rel="external">http://stackoverflow.com/questions/19739054/whats-the-best-way-to-reconnect-after-connection-closed-in-netty</a></li>
<li><a href="https://github.com/netty/netty/blob/master/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java" target="_blank" rel="external">https://github.com/netty/netty/blob/master/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java</a></li>
<li><a href="http://tterm.blogspot.jp/2014/03/netty-tcp-client-with-reconnect-handling.html" target="_blank" rel="external">http://tterm.blogspot.jp/2014/03/netty-tcp-client-with-reconnect-handling.html</a></li>
<li><a href="http://stackoverflow.com/questions/21240981/in-netty-4-whats-the-difference-between-ctx-close-and-ctx-channel-close" target="_blank" rel="external">ctx.close vs ctx.channel().close</a></li>
<li><a href="http://stackoverflow.com/questions/20366418/any-difference-between-ctx-write-and-ctx-channel-write-in-netty" target="_blank" rel="external">ctx.write vs ctx.channel().write</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我们用Netty实现一个TCP client时，我们当然希望当连接断掉的时候Netty能够自动重连。<br>Netty Client有两种情况下需要重连：</p>
<ol>
<li>Netty Client启动的时候需要重连</li>
<li>在程序运行中连接断掉需要重连。</li>
</ol>
<p>对于第一种情况，Netty的作者在stackoverflow上给出了<a href="http://stackoverflow.com/questions/19739054/whats-the-best-way-to-reconnect-after-connection-closed-in-netty" target="_blank" rel="external">解决方案</a>，<br>对于第二种情况，Netty的例子uptime中实现了一种<a href="https://github.com/netty/netty/blob/master/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java" target="_blank" rel="external">解决方案</a>。</p>
<p> 而Thomas在他的<a href="http://tterm.blogspot.jp/2014/03/netty-tcp-client-with-reconnect-handling.html" target="_blank" rel="external">文章</a>中提供了这两种方式的实现的例子。</p>
]]>
    
    </summary>
    
      <category term="Netty" scheme="http://colobu.com/tags/Netty/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在命令行中使用Eclipse MAT工具]]></title>
    <link href="http://colobu.com/2015/08/12/using-Eclipse-Memory-Analyzer-by-the-command-line/"/>
    <id>http://colobu.com/2015/08/12/using-Eclipse-Memory-Analyzer-by-the-command-line/</id>
    <published>2015-08-12T07:16:18.000Z</published>
    <updated>2015-08-12T07:57:10.413Z</updated>
    <content type="html"><![CDATA[<p>最近应用在测试中出现Out Of Memory的问题， 通过jmap查看，发现JVM heap全用满了。<br>有很多工具可以查看JVM堆的信息， 收费的比如JProfiler， YourKit，免费的如Oracle JDK自带的visualvm, jhat和Eclipse MAT。<br>这个应用安装在一台AWS上，没有图形界面， 内存也比较小，想通过VNC远程桌面启动visualvm或者MAT不可能，通过jhat分析dump出来的snapshot(大约4.3G)也很慢，半天没有分析完毕，这种办法也放弃。<br>最后通过MAT的命令行工具分析了dump出来的snapshot,查找到OOM的元凶。</p>
<a id="more"></a>
<h4 id="使用MAT命令行工具">使用MAT命令行工具</h4>
<p>首先通过jstat或者jmap查看heap信息,比如通过jmap查看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> JVM version is <span class="number">25.31</span>-b07</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC <span class="keyword">with</span> <span class="number">4</span> thread(s)</div><div class="line"></div><div class="line">Heap Configuration:</div><div class="line">   <span class="variable">MinHeapFreeRatio         =</span> <span class="number">0</span></div><div class="line">   <span class="variable">MaxHeapFreeRatio         =</span> <span class="number">100</span></div><div class="line">   <span class="variable">MaxHeapSize              =</span> <span class="number">4294967296</span> (<span class="number">4096.0</span>MB)</div><div class="line">   <span class="variable">NewSize                  =</span> <span class="number">1431306240</span> (<span class="number">1365.0</span>MB)</div><div class="line">   <span class="variable">MaxNewSize               =</span> <span class="number">1431306240</span> (<span class="number">1365.0</span>MB)</div><div class="line">   <span class="variable">OldSize                  =</span> <span class="number">2863661056</span> (<span class="number">2731.0</span>MB)</div><div class="line">   <span class="variable">NewRatio                 =</span> <span class="number">2</span></div><div class="line">   <span class="variable">SurvivorRatio            =</span> <span class="number">8</span></div><div class="line">   <span class="variable">MetaspaceSize            =</span> <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</div><div class="line">   <span class="variable">CompressedClassSpaceSize =</span> <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</div><div class="line">   <span class="variable">MaxMetaspaceSize         =</span> <span class="number">17592186044415</span> MB</div><div class="line">   <span class="variable">G1HeapRegionSize         =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line"></div><div class="line">Heap Usage:</div><div class="line">PS Young Generation</div><div class="line">Eden Space:</div><div class="line">   <span class="variable">capacity =</span> <span class="number">482344960</span> (<span class="number">460.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">468288384</span> (<span class="number">446.5946044921875</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">14056576</span> (<span class="number">13.4053955078125</span>MB)</div><div class="line">   <span class="number">97.08578358525816</span>% used</div><div class="line">From Space:</div><div class="line">   <span class="variable">capacity =</span> <span class="number">278921216</span> (<span class="number">266.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">278921216</span> (<span class="number">266.0</span>MB)</div><div class="line">   <span class="number">0.0</span>% used</div><div class="line">To Space:</div><div class="line">   <span class="variable">capacity =</span> <span class="number">477102080</span> (<span class="number">455.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">477102080</span> (<span class="number">455.0</span>MB)</div><div class="line">   <span class="number">0.0</span>% used</div><div class="line">PS Old Generation</div><div class="line">   <span class="variable">capacity =</span> <span class="number">2863661056</span> (<span class="number">2731.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">2863365080</span> (<span class="number">2730.7177352905273</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">295976</span> (<span class="number">0.28226470947265625</span>MB)</div><div class="line">   <span class="number">99.98966441927965</span>% used</div><div class="line"></div><div class="line"><span class="number">12340</span> interned Strings occupying <span class="number">1051736</span> bytes.</div></pre></td></tr></table></figure>

<p>最多的类的实例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="header">num     #instances         #bytes  class name</span></div><div class="line">----------------------------------------------</div><div class="line"><span class="code">   1:      21606534     1530253752  [C</span></div><div class="line"><span class="code">   2:      21606239      518549736  java.lang.String</span></div><div class="line"><span class="code">   3:      19198980      460775520  scala.collection.immutable.ListSet$Node</span></div><div class="line"><span class="code">   4:       4568546      109645104  scala.collection.immutable.HashSet$HashSetCollision1</span></div><div class="line"><span class="code">   5:        103739       63212992  [B</span></div><div class="line"><span class="code">   6:       1487034       53464560  [Lscala.collection.immutable.HashSet;</span></div><div class="line"><span class="code">   7:       1487034       35688816  scala.collection.immutable.HashSet$HashTrieSet</span></div><div class="line"><span class="code">   8:       1350368       32408832  scala.collection.immutable.$colon$colon</span></div><div class="line"><span class="code">   9:       1090897       26181528  scala.collection.immutable.HashSet$HashSet1</span></div><div class="line"><span class="code">  10:        200035       17603080  akka.actor.ActorCell</span></div><div class="line"><span class="code">  11:        100536        8042880  java.lang.reflect.Constructor</span></div><div class="line"><span class="code">  12:        500026        8000416  scala.runtime.ObjectRef</span></div></pre></td></tr></table></figure>

<p>从分析来看猜测是akka actor mailbox里面的字符串消息太多了。</p>
<p>既然没有办法图形化启动visualvm和MAT,那么就使用MAT文件夹下的<code>ParseHeapDump.sh</code>, 特别适合分析大堆的信息。<br>首先你需要修改MemoryAnalyzer.ini中的Xmx值，确保有充足的硬盘空间(至少dump文件的两倍)。<br>然后运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ParseHeapDump.sh heap.bin org.eclipse.mat.api:suspects org.eclipse.mat.api:overview org.eclipse.mat.api:top_components</div></pre></td></tr></table></figure>

<p>会得到suspects, overview和top_components三个视图的信息。<br><img src="oom.png" alt="有问题的对象"><br>可以看到<code>akka.dispatch.Dispatcher$$anon$1</code>一个实例占用了2.4GB的内存，这就是罪魁祸首。这其实是akka dispatcher的mailbox中的java.util.concurrent.ConcurrentLinkedQueue，每个Node占用了81M的内存，<br>消息体太大了。</p>
<h4 id="编写程序得到所需信息">编写程序得到所需信息</h4>
<p>你也可以引用MAT的类，得到heap dump中的信息， 因为MAT使用Eclipse RCP框架， 基于osgi架构，使用起来不太方便，所以你可以别人抽取出来的MAT库，如<code>https://bitbucket.org/joebowbeer/andromat</code>,<br>然后实现一个命令行程序,比如下面的例子就是输出所有的字符串的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.colobu.mat;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.eclipse.mat.SnapshotException;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.parser.model.PrimitiveArrayImpl;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.snapshot.ISnapshot;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.parser.internal.SnapshotFactory;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.snapshot.model.IClass;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.snapshot.model.IObject;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.util.ConsoleProgressListener;</div><div class="line"><span class="keyword">import</span> org.eclipse.mat.util.IProgressListener;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> SnapshotException, IOException {</div><div class="line">            String arg = args[args.length - <span class="number">1</span>];</div><div class="line">        String fileName = arg;</div><div class="line">        IProgressListener listener = <span class="keyword">new</span> ConsoleProgressListener(System.out);</div><div class="line">        SnapshotFactory sf = <span class="keyword">new</span> SnapshotFactory();</div><div class="line">        ISnapshot snapshot = sf.openSnapshot(<span class="keyword">new</span> File(fileName),</div><div class="line">                <span class="keyword">new</span> HashMap&lt;String, String&gt;(), listener);</div><div class="line">        System.out.println(snapshot.getSnapshotInfo());</div><div class="line">        System.out.println();</div><div class="line">        String[] classNames = {<span class="string">"java.lang.String"</span>};</div><div class="line">        <span class="keyword">for</span> (String name : classNames) {</div><div class="line">            Collection&lt;IClass&gt; classes = snapshot.getClassesByName(name, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span> || classes.isEmpty()) {</div><div class="line">                System.out.println(String.format(<span class="string">"Cannot find class %s in heap dump"</span>, name));</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">assert</span> classes.size() == <span class="number">1</span>;</div><div class="line">            IClass clazz = classes.iterator().next();</div><div class="line">            <span class="keyword">int</span>[] objIds = clazz.getObjectIds();</div><div class="line">            <span class="keyword">long</span> minRetainedSize = snapshot.getMinRetainedSize(objIds, listener);</div><div class="line">            System.out.println(String.format(<span class="string">"%s instances = %d, retained size &gt;= %d"</span>, clazz.getName(), objIds.length, minRetainedSize));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objIds.length; i++) {</div><div class="line">                IObject str = snapshot.getObject(objIds[i]);</div><div class="line">                String address = Long.toHexString(snapshot.mapIdToAddress(objIds[i]));</div><div class="line"></div><div class="line">                PrimitiveArrayImpl chars = (PrimitiveArrayImpl) str.resolveValue(<span class="string">"value"</span>);</div><div class="line">                String value = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) chars.getValueArray());</div><div class="line"></div><div class="line">                System.out.println(String.format(<span class="string">"id=%d, address=%s, value=%s"</span>, objIds[i], address, value));</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>基本上使用<code>ParseHeapDump.sh</code>已经得到了我所需要的结果，优化akka actor消息的内容解决了我的问题。</p>
<h4 id="参考文档">参考文档</h4>
<ol>
<li><a href="https://wiki.eclipse.org/MemoryAnalyzer/Extending_Memory_Analyzer" target="_blank" rel="external">https://wiki.eclipse.org/MemoryAnalyzer/Extending_Memory_Analyzer</a></li>
<li><a href="http://javaforu.blogspot.jp/2013/11/analyzing-large-java-heap-dumps-when.html" target="_blank" rel="external">http://javaforu.blogspot.jp/2013/11/analyzing-large-java-heap-dumps-when.html</a></li>
<li><a href="http://dr-brenschede.de/bheapsampler/" target="_blank" rel="external">http://dr-brenschede.de/bheapsampler/</a></li>
<li><a href="http://www.techpaste.com/2015/07/how-to-analyse-large-heap-dumps/" target="_blank" rel="external">http://www.techpaste.com/2015/07/how-to-analyse-large-heap-dumps/</a></li>
<li><a href="http://stackoverflow.com/questions/15977723/analyse-a-hprof-memory-dump-file-from-command-line-programmically" target="_blank" rel="external">http://stackoverflow.com/questions/15977723/analyse-a-hprof-memory-dump-file-from-command-line-programmically</a></li>
<li><a href="http://wangjunyan.github.io/2014/12/02/export-android-bitmap-from-dump-file/" target="_blank" rel="external">http://wangjunyan.github.io/2014/12/02/export-android-bitmap-from-dump-file/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近应用在测试中出现Out Of Memory的问题， 通过jmap查看，发现JVM heap全用满了。<br>有很多工具可以查看JVM堆的信息， 收费的比如JProfiler， YourKit，免费的如Oracle JDK自带的visualvm, jhat和Eclipse MAT。<br>这个应用安装在一台AWS上，没有图形界面， 内存也比较小，想通过VNC远程桌面启动visualvm或者MAT不可能，通过jhat分析dump出来的snapshot(大约4.3G)也很慢，半天没有分析完毕，这种办法也放弃。<br>最后通过MAT的命令行工具分析了dump出来的snapshot,查找到OOM的元凶。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[G1垃圾回收器中的字符串去重(Java 8 Update 20)]]></title>
    <link href="http://colobu.com/2015/08/10/java-string-deduplication/"/>
    <id>http://colobu.com/2015/08/10/java-string-deduplication/</id>
    <published>2015-08-10T07:41:42.000Z</published>
    <updated>2015-08-10T07:46:15.530Z</updated>
    <content type="html"><![CDATA[<p>从平均情况来看，应用程序中String对象会消耗大量的内存。这里面有一部分可能是重复(冗余)的－同样的字符串存在多个不同的实例(a!=b，但a.equals(b))。在实践中，许多字符串由于各种原因造成重复。<br>起初，JDK提供String.intern()方法处理字符串重复的问题。该方法的缺点是你需要找出哪些字符串需要驻留(interned)。这通常需要一个具备重复字符串查找功能的堆分析工具，比如<a href="http://www.yourkit.com/features/" target="_blank" rel="external">YourKit profiler</a>。尽管如此，如果使用恰当，字符串驻留会是一个强大的节省内存的工具－它允许你重用整个String对象（每个对象会在底层char[]的基础上增加24字节的额外开销）。<br>从Java 7 update 6开始，每个String对象都有自己私有的底层char[]。这样允许JVM做自动优化－如果底层的char[]数组从没有暴露给客户端，那么JVM就能去判断两个字符串的内容是否一致，进而将一个字符串底层的char[]替换成另一个字符串的底层char[]数组。<br>Java 8 update 20中引入的字符串去重特性就是用来做这个的，下面是它的工作原理：<br><a id="more"></a></p>
<ol>
<li>你需要使用G1垃圾收集器并启用该特性：-XX:+UseG1GC -XX:+UseStringDeduplication。这个特性是作为G1垃圾收集器的一个可选的步骤来实现的，如果使用其他垃圾收集器则不能使用该特性。</li>
<li>这个特性可能会在G1收集器的minor GC阶段执行。根据我的观察看，它是否执行取决于空闲CPU周期的利用率。所以，不要指望它在一个处理本地数据的数据分析器中会被执行。另一方面，WEB服务器中倒是很可能会执行这个优化。</li>
<li>字符串去重会查找那些未被处理的字符串，计算它们的hash值(如果先前没有被应用代码计算过的话)，然后查找是否有其他具有相同hash值且相等的底层char[]的字符串。如果找到－它会用新字符串的char[]替换掉现有的这个字符串的char[]。</li>
<li>字符串去重只会处理那些经历过几次垃圾收集仍然存活的字符串，这确保多数生命周期很短的字符串不会被处理。字符串的这个最小存活年龄是通过JVM参数-XX:StringDeduplicationAgeThreshole=3管理的(３是该参数的默认值)。</li>
</ol>
<p>下面是关于这个实现的一些重要结论：</p>
<ul>
<li>没错，如果你想享受字符串去重特性这份免费午餐的话，你需要使用G1收集器。你不能使用并行GC，通常对于追求高吞吐量胜于低延迟的应用这可能是更好的选择。</li>
<li>字符串去重无法在一个已加载完的系统中运行。为了检验它是否执行过，可以使用-XX:+PrintStringDeduplicationStatistics参数运行JVM，并观察控制台输出。</li>
<li>如果需要节省内存，并且你可以在应用中驻留字符串－就这样做，不要依赖字符串去重的功能。你需要时刻注意的是字符串去重会处理所有或至少大部分字符串－也就是说尽管你知道某个给定的字符串内容是唯一的，比如GUID，但JVM不知道这些，它仍会尝试将这个字符串和其它字符串进行匹配。结果，字符串去重产生的CPU开销既取决于堆中字符串的数量(新的字符串会与它们中的一些进行比较)，也取决于你在字符串去重期间创建的字符串数量(这些字符串需要和堆中的字符串比较)。在拥有好几个G的堆上，可以通过-XX:+PrintStringDeduplicationStatistics JVM选项检查这个特性的影响。</li>
<li>另一方面， 字符串去重基本是以非阻塞的方式完成的，如果你的服务器有足够多的空闲CPU，那为什么不用呢？</li>
<li>最后，请记住String.intern允许你只针对应用程序中那些已知的会产冗余的字符串进行驻留，通常它只需要跟一个很小的字符串驻留池比较即可，这样能更有效的利用CPU。此外，你可以驻留整个String对象，这样每个字符串可以额外节省24字节。</li>
</ul>
<p>###特性测试<br>这是我用来试验这一特性的一个测试类，这３个测试都需要运行到JVM抛出OOM，所以需要单独运行。<br>第一个测试会创建内容不同的字符串，如果你想模拟当堆中有大量字符串时，字符串去重花费的时间，那这个测试是非常有用的。尽量为第一个测试分配尽可能多的内存－创建的字符串越多，去重效果越好。<br>第二个和第三个测试用于比较字符串去重(第二个测试)和驻留(第三个测试)间的差别。你需要使用相同的(identical)Xmx设置来运行它们。在程序中，我把这个常量设为Xmx256M，你可以多分配些。然而，你会发现在迭代几次后去重测试将先失败，然后是驻留测试。这是为什么？因为，在这些测试中我们只有100个不同的字符串，因此对它们进行驻留意味着你用到的内存就只是存储这些字符串所需要的空间。而字符串去重的话，会产生不同的字符串对象，它仅会共享底层的char[]数组。</p>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * String deduplication vs interning test</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDedupTest</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_EXPECTED_ITERS = <span class="number">300</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULL_ITER_SIZE = <span class="number">100</span> * <span class="number">1000</span>;</div><div class="line"></div><div class="line">    <span class="comment">//30M entries = 120M RAM (for 300 iters)</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; LIST = <span class="keyword">new</span> ArrayList&lt;&gt;( MAX_EXPECTED_ITERS * FULL_ITER_SIZE );</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {</div><div class="line">        <span class="comment">//24+24 bytes per String (24 String shallow, 24 char[])</span></div><div class="line">        <span class="comment">//136M left for Strings</span></div><div class="line"></div><div class="line">        <span class="comment">//Unique, dedup</span></div><div class="line">        <span class="comment">//136M / 2.9M strings = 48 bytes (exactly String size)</span></div><div class="line"></div><div class="line">        <span class="comment">//Non unique, dedup</span></div><div class="line">        <span class="comment">//4.9M Strings, 100 char[]</span></div><div class="line">        <span class="comment">//136M / 4.9M strings = 27.75 bytes (close to 24 bytes per String + small overhead</span></div><div class="line"></div><div class="line">        <span class="comment">//Non unique, intern</span></div><div class="line">        <span class="comment">//We use 120M (+small overhead for 100 strings) until very late, but can't extend ArrayList 3 times - we don't have 360M</span></div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">          Run it with: -XX:+UseG1GC -XX:+UseStringDeduplication -XX:+PrintStringDeduplicationStatistics</div><div class="line">          Give as much Xmx as you can on your box. This test will show you how long does it take to</div><div class="line">          run a single deduplication and if it is run at all.</div><div class="line">          To test when deduplication is run, try changing a parameter of Thread.sleep or comment it out.</div><div class="line">          You may want to print garbage collection information using -XX:+PrintGCDetails -XX:+PrintGCTimestamps</div><div class="line">        */</div><div class="line"></div><div class="line">        <span class="comment">//Xmx256M - 29 iterations</span></div><div class="line">        fillUnique();</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         This couple of tests compare string deduplication (first test) with string interning.</div><div class="line">         Both tests should be run with the identical Xmx setting. I have tuned the constants in the program</div><div class="line">         for Xmx256M, but any higher value is also good enough.</div><div class="line">         The point of this tests is to show that string deduplication still leaves you with distinct String</div><div class="line">         objects, each of those requiring 24 bytes. Interning, on the other hand, return you existing String</div><div class="line">         objects, so the only memory you spend is for the LIST object.</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="comment">//Xmx256M - 49 iterations (100 unique strings)</span></div><div class="line">        <span class="comment">//fillNonUnique( false );</span></div><div class="line"></div><div class="line">        <span class="comment">//Xmx256M - 299 iterations (100 unique strings)</span></div><div class="line">        <span class="comment">//fillNonUnique( true );</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillUnique</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">        <span class="keyword">int</span> iters = <span class="number">0</span>;</div><div class="line">        <span class="keyword">final</span> UniqueStringGenerator gen = <span class="keyword">new</span> UniqueStringGenerator();</div><div class="line">        <span class="keyword">while</span> ( <span class="keyword">true</span> )</div><div class="line">        {</div><div class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FULL_ITER_SIZE; ++i )</div><div class="line">                LIST.add( gen.nextUnique() );</div><div class="line">            Thread.sleep( <span class="number">300</span> );</div><div class="line">            System.out.println( <span class="string">"Iteration "</span> + (iters++) + <span class="string">" finished"</span> );</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillNonUnique</span>( <span class="keyword">final</span> <span class="keyword">boolean</span> intern ) <span class="keyword">throws</span> InterruptedException {</div><div class="line">        <span class="keyword">int</span> iters = <span class="number">0</span>;</div><div class="line">        <span class="keyword">final</span> UniqueStringGenerator gen = <span class="keyword">new</span> UniqueStringGenerator();</div><div class="line">        <span class="keyword">while</span> ( <span class="keyword">true</span> )</div><div class="line">        {</div><div class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FULL_ITER_SIZE; ++i )</div><div class="line">                LIST.add( intern ? gen.nextNonUnique().intern() : gen.nextNonUnique() );</div><div class="line">            Thread.sleep( <span class="number">300</span> );</div><div class="line">            System.out.println( <span class="string">"Iteration "</span> + (iters++) + <span class="string">" finished"</span> );</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueStringGenerator</span></span></div><div class="line">    {</div><div class="line">        <span class="keyword">private</span> <span class="keyword">char</span> upper = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">char</span> lower = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> String <span class="title">nextUnique</span>()</div><div class="line">        {</div><div class="line">            <span class="keyword">final</span> String res = String.valueOf( upper ) + lower;</div><div class="line">            <span class="keyword">if</span> ( lower &lt; Character.MAX_VALUE )</div><div class="line">                lower++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            {</div><div class="line">                upper++;</div><div class="line">                lower = <span class="number">0</span>;</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> String <span class="title">nextNonUnique</span>()</div><div class="line">        {</div><div class="line">            <span class="keyword">final</span> String res = <span class="string">"a"</span> + lower;</div><div class="line">            <span class="keyword">if</span> ( lower &lt; <span class="number">100</span> )</div><div class="line">                lower++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                lower = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>###总结</p>
<ul>
<li>字符串去重是Java 8 update 20添加的新特性。它是G1垃圾回收器的一部分，因此你必须使用G1回收器才能启用它：-XX:+UseG1GC -XX:+UseStringDeduplication。</li>
<li>字符串去重是G1的一个可选阶段，它取决于当前系统的负载。</li>
<li>字符串去重会查询内容相同的字符串，并统一底层存储字符的char[]数组。使用此特性你不需要编写任何代码，不过这意味着你最后得到的是不同的String对象，每个对象占用24字节。有时候，显式的调用String.intern方法进行字符串驻留还是有必要的。</li>
<li>字符串去重不会处理太年轻的字符串。处理字符串的最小年龄是通过JVM参数：-XX:StringDeduplicationAgeThreshold=3来管理的(3是这个参数的默认值)。</li>
</ul>
<p>###See also<br><a href="http://openjdk.java.net/jeps/192" target="_blank" rel="external">JEP 192 - a formal description of String deduplication</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从平均情况来看，应用程序中String对象会消耗大量的内存。这里面有一部分可能是重复(冗余)的－同样的字符串存在多个不同的实例(a!=b，但a.equals(b))。在实践中，许多字符串由于各种原因造成重复。<br>起初，JDK提供String.intern()方法处理字符串重复的问题。该方法的缺点是你需要找出哪些字符串需要驻留(interned)。这通常需要一个具备重复字符串查找功能的堆分析工具，比如<a href="http://www.yourkit.com/features/" target="_blank" rel="external">YourKit profiler</a>。尽管如此，如果使用恰当，字符串驻留会是一个强大的节省内存的工具－它允许你重用整个String对象（每个对象会在底层char[]的基础上增加24字节的额外开销）。<br>从Java 7 update 6开始，每个String对象都有自己私有的底层char[]。这样允许JVM做自动优化－如果底层的char[]数组从没有暴露给客户端，那么JVM就能去判断两个字符串的内容是否一致，进而将一个字符串底层的char[]替换成另一个字符串的底层char[]数组。<br>Java 8 update 20中引入的字符串去重特性就是用来做这个的，下面是它的工作原理：<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/tags/Java/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些 REST 最佳实践]]></title>
    <link href="http://colobu.com/2015/08/10/some-REST-best-practices/"/>
    <id>http://colobu.com/2015/08/10/some-REST-best-practices/</id>
    <published>2015-08-10T05:23:16.000Z</published>
    <updated>2015-08-10T05:51:42.883Z</updated>
    <content type="html"><![CDATA[<p>原文： <a href="https://bourgeois.me/rest/" target="_blank" rel="external">Some REST best practices</a>, 作者：<a href="https://bourgeois.me/" target="_blank" rel="external">Pierre-Olivier Bourgeois</a>。<br>译文： <a href="http://weibo.com/p/1001603873537160306692" target="_blank" rel="external">一些REST最佳实践</a>, 译者： <a href="http://weibo.com/uc34333168" target="_blank" rel="external">yongx</a></p>
<p>如今，REST APIs 已经非常普遍，几乎所有WEB应用都用到了它们。提供简单，一致，实用的API是种义务，方便其它人很容易的使用。即使下面的这些规范，在你看来很正常，我经常看到人们不遵守它。这是我写这篇文章的原因。<br>当你设计 RESTful API 时，下面是一些应该牢记的最佳规范。<br>免责声明：下面的这些规范是根据过去的经验，我认为最好的。如果你有别的想法，咱们邮件讨论。</p>
<a id="more"></a>
<h2 id="给API加上版本">给API加上版本</h2>
<p>API版本应该是必备的。这样API不会随时间过时。一种方法是把版本放到URL里（<code>/api/v1...</code>)</p>
<p>另一个巧妙的花招是使用 <code>Accept</code> HTTP header，来传递需要的版本，正如<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="external">github所做的</a>。<br>（备注：Github 的格式是，application/vnd.github[.version].param[+json]，version指定版本，param是想要的格式，txt，html等。从评论看似乎Github的方式更完美）</p>
<p>通过版本，你可以改变API的结构，而不用担心老版客户端的兼容问题。（备注：API提供者默默承受维护多套API的痛苦）</p>
<h2 id="使用名词，而不是动词">使用名词，而不是动词</h2>
<p>我经常看到有人使用动词而不是名词来表示资源名称，例如下面这些：</p>
<ul>
<li><em>/getProducts</em></li>
<li><em>/listOrders</em></li>
<li><em>/retreiveClientByOrder?orderId=1</em></li>
</ul>
<p>从结构整洁和一致角度考虑，你应该总是使用名词。而且，巧妙使用 HTTP 方法（GET，POST）可以把想要的操作从资源名称上去除。如下面的例子：</p>
<ul>
<li><em>GET  /products</em>      返回所有产品列表</li>
<li><em>POST /products</em>      添加产品到产品列表</li>
<li><em>GET  /products/4</em>    提取Id为4的产品</li>
<li><em>PATCH/PUT /products/4</em> 更新Id为4的产品</li>
</ul>
<h2 id="使用复数形式">使用复数形式</h2>
<p>在我看来，同一资源命名，混合使用单数和复数形式不是好主意。很快就会混淆，带来不一致。<br>即使对 <code>show/delete/update</code> 操作，使用 <code>/artists</code> 而不是 <code>/artist</code> 也更好点。</p>
<h2 id="GET_和_HEAD_操作应该是安全的（无副作用）">GET 和 HEAD 操作应该是安全的（无副作用）</h2>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">RFC2616</a> 明确规定 <code>HEAD</code> 和 <code>GET</code> 必须是安全的（不能改变资源状态）<br>右边是一个不好的例子： <code>GET /deleteProduct?id=1</code><br>如果搜索引擎检索了那个页面，画面太美我不敢看（备注：实践中对删除操作都有权限验证，就算操作引擎抓取也没啥破坏）<br>（备注：<code>POST</code>和<code>PUT</code>的区别，<code>POST</code>是不幂等的，<code>PUT</code>是幂等的。如果多次调用URL得到的结果都一样，那就是幂等的。例如，发评论，如果评论ID在提交评论前已经生成，那么无论点多少次提交，看到的都是一条评论。如果评论ID在提交评论后生成，点多少次提交就看到多少条评论。）</p>
<h2 id="使用嵌套资源">使用嵌套资源</h2>
<p>如果想获取全部的子集，使用嵌套路由来让风格简洁。例如想从所有唱片中选取特定的，使用 <code>GET /artists/8/albums</code>（备注：这里8就是所谓嵌套路由，指导选取哪个唱片）</p>
<h2 id="分页">分页</h2>
<p>通过 HTTP 返回超大结果集不是好主意。序列化大的JSON数据很慢，这会导致性能问题。<br>通常的做法是分页，Facebook，Twitter，Github都是这么做的。提取少里数据更快，就算需要多次调用，也比一次提取很大（但执行很慢）的数据更高效。<br>如果想分页，一个好的方法是通过<code>Link</code> HTTP header，来提示前一页和后一页。正如 <a href="https://developer.github.com/guides/traversing-with-pagination/" target="_blank" rel="external">Github 做的那样</a>。<br>（备注：<code>Link</code>的用法 Link: <a href="http://next_url" target="_blank" rel="external">http://next_url</a>; rel=&quot;next&quot;, <a href="http://last_url" target="_blank" rel="external">http://last_url</a>; rel=&quot;last&quot;, <a href="http://first_url" target="_blank" rel="external">http://first_url</a>; rel=&quot;first&quot;, <a href="http://prev_url" target="_blank" rel="external">http://prev_url</a>; rel=&quot;prev&quot;）</p>
<h2 id="使用合适的_HTTP_状态码">使用合适的 HTTP 状态码</h2>
<p>请求返回时，无论请求成功与否，总是使用正确的返回码。下面是一些可能用到的状态码。</p>
<h3 id="成功状态码（2XX系列）">成功状态码（2XX系列）</h3>
<ul>
<li><code>201 Created</code> 当成功创建资源时（INSERT）</li>
<li><code>202 Accepted</code> 当请求被接受，并放到后台执行时（异步任务）</li>
<li><code>204 No Content</code> 当请求成功，但是没有内容返回时（例如 DELETE 时）</li>
</ul>
<h3 id="客户端错误（4xx系列）">客户端错误（4xx系列）</h3>
<ul>
<li><code>400 Bad Request</code> 当处理querystring或http body时出错（例如非法JSON）</li>
<li><code>401 Unauthorized</code> 认证失败</li>
<li><code>403 Forbidden</code> 认证成功时，操作或请求的资源不被允许</li>
<li><code>406 Not Acceptable</code> 请求格式不被接受（例如试图请求JSON数据，但服务器只提供XML）</li>
<li><code>410 Gone</code> 请求的资源被永久删除（备注：咋判断是不存在还是被永久删除了）</li>
<li><code>422 Unprocessable entity</code> 当创建对象时发生可用性错误</li>
</ul>
<p>完整的状态码请参照<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">RFC2616</a></p>
<h2 id="总是返回一致的错误内容">总是返回一致的错误内容</h2>
<p>当发生错误时，总是返回一致的错误描述。错误结构总是相同，这样更容易解析错误信息。<br>如下描述，清晰，简单，自说明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">401</span> Unauthorized</div><div class="line">{</div><div class="line">    <span class="string">"status"</span>: <span class="string">"Unauthorized"</span>,</div><div class="line">    <span class="string">"message"</span>: <span class="string">"No access token provided."</span>,</div><div class="line">    <span class="string">"request_id"</span>: <span class="string">"594600f4-7eec-47ca-8012-02e7b89859ce"</span></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>原文： <a href="https://bourgeois.me/rest/" target="_blank" rel="external">Some REST best practices</a>, 作者：<a href="https://bourgeois.me/" target="_blank" rel="external">Pierre-Olivier Bourgeois</a>。<br>译文： <a href="http://weibo.com/p/1001603873537160306692" target="_blank" rel="external">一些REST最佳实践</a>, 译者： <a href="http://weibo.com/uc34333168" target="_blank" rel="external">yongx</a></p>
<p>如今，REST APIs 已经非常普遍，几乎所有WEB应用都用到了它们。提供简单，一致，实用的API是种义务，方便其它人很容易的使用。即使下面的这些规范，在你看来很正常，我经常看到人们不遵守它。这是我写这篇文章的原因。<br>当你设计 RESTful API 时，下面是一些应该牢记的最佳规范。<br>免责声明：下面的这些规范是根据过去的经验，我认为最好的。如果你有别的想法，咱们邮件讨论。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala编程的蛋糕模式和依赖注入]]></title>
    <link href="http://colobu.com/2015/07/28/Scala-Cake-pattern-and-Dependency-Injection/"/>
    <id>http://colobu.com/2015/07/28/Scala-Cake-pattern-and-Dependency-Injection/</id>
    <published>2015-07-28T05:58:41.000Z</published>
    <updated>2015-09-03T06:09:12.116Z</updated>
    <content type="html"><![CDATA[<p> 如果你是一个Java开发者，熟悉 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">依赖注入</a> 模式, 深度依赖Spring框架的话，在使用Scala做开发时，会问一个问题，在Scala世界里，如何实现类似Spring框架的依赖注入呢？</p>
<p>尽管函数式编程的信徒认为他们不需要DI框架，高阶(high-order)函数足够了。但是对于同时支持面向对象的编程和函数式编程的Scala来说，依赖注入是很好的实现应用的一种设计模式。<br>蛋糕模式(Cake pattern)是Scala实现依赖注入的方式之一。<br>蛋糕模式是 Scala 之父 Martin Odersky 在其论文 <a href="http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf" target="_blank" rel="external">Scalable Component Abstractions</a> 中首先提到。</p>
<p>什么是蛋糕模式呢? 一个非正式的但是很形象的解释是：</p>
<ul>
<li>蛋糕有很多风味， 你可以根据你的需要增加相应的风味。依赖注入就是增加调料。</li>
<li>蛋糕有很多层 (layer)。如果你想要一个更大的蛋糕你就可以增加更多的层。</li>
</ul>
<p>我们先以Spring常用的User数据库读取的实现为例，看看Scala 风格的依赖注入(蛋糕模式)是如何实现的。<br><a id="more"></a></p>
<h3 id="Java/Spring风格的依赖注入实现">Java/Spring风格的依赖注入实现</h3>
<p>一个传统的Spring实现是将程序划分为&quot;Repository&quot;层(DAO layer) 和Service层。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">User</span><span class="params">(name:String)</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UserRepository</span> </span>{</div><div class="line">  <span class="keyword">def</span> create(user: User)</div><div class="line">  <span class="keyword">def</span> find(name: String)</div><div class="line">  <span class="keyword">def</span> update(user: User)</div><div class="line">  <span class="keyword">def</span> delete(user: User)</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockUserRepository</span> <span class="keyword">extends</span> <span class="title">UserRepository</span> </span>{</div><div class="line">  <span class="keyword">def</span> create(user: User) = println(<span class="string">"creating user: "</span> + user)</div><div class="line">  <span class="keyword">def</span> find(name: String) = println(<span class="string">"finding user: "</span> + name)</div><div class="line">  <span class="keyword">def</span> update(user: User) = println(<span class="string">"udating user: "</span> + user)</div><div class="line">  <span class="keyword">def</span> delete(user: User) = println(<span class="string">"deleting user: "</span> + user)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>{</div><div class="line">  <span class="annotation">@Resource</span></div><div class="line">  <span class="keyword">var</span> userRepository: UserRepository = _</div><div class="line"></div><div class="line">  <span class="keyword">def</span> create(user: User) = userRepository.create(user)</div><div class="line"></div><div class="line">  <span class="keyword">def</span> find(name: String) = userRepository.find(name)</div><div class="line"></div><div class="line">  <span class="keyword">def</span> update(user: User) = userRepository.update(user)</div><div class="line"></div><div class="line">  <span class="keyword">def</span> delete(user: User) = userRepository.delete(user)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可能有多个UserRepository的实现， 比如JPA, JDBC, Hibernate, iBATIS 等，然后将具体的实现通过Spring注入到 UserService中。<br>这里我们用一个Mock来简单这些这个Trait, 然后模拟Spring注入，(Spring会根据配置和Reflect自动实现实例化和注入，这里我们只是模拟其原理，并没有使用Spring框架)： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> service = <span class="keyword">new</span> UserService()</div><div class="line">  <span class="keyword">val</span> userRepository = <span class="keyword">new</span> MockUserRepository()</div><div class="line">  service.userRepository = userRepository <span class="comment">// inject userRepository into userService</span></div><div class="line">  service.create(User(<span class="string">"user"</span>)) </div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Scala/Cake_pattern实现依赖注入">Scala/Cake pattern实现依赖注入</h3>
<p> 和上面的代码类似，我们有三个class/trait: <code>UserRepository</code> , <code>MockUserRepository</code> 和 <code>UserService</code> ， 其中 <code>MockUserRepository</code> 是 <code>UserRepository</code> 的具体实现，<br>现在我们想把 <code>MockUserRepository</code> 注入到 <code>UserService</code> 。注意 <code>UserService</code> 和 <code>UserRepository</code> 目前没有任何依赖关系。</p>
<p>Scala的蛋糕模式中我们需要声明几个 Component ： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UserRepositoryComponent</span> </span>{</div><div class="line">  <span class="keyword">val</span> userRepository:UserRepository</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UserServiceComponent</span> </span>{</div><div class="line">  <span class="keyword">this</span>: UserRepositoryComponent =&gt;</div><div class="line">  <span class="keyword">val</span> userService: UserService</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里使用 <a href="http://www.scala-lang.org/node/124" target="_blank" rel="external">self-type annotation</a> 声明 <code>UserServiceComponent</code> 需要 <code>UserRepositoryComponent</code> ( <code>this: UserRepositoryComponent =&gt;</code> )。 如果需要多个依赖，可以使用下面的格式: </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>: Foo <span class="keyword">with</span> Bar <span class="keyword">with</span> Baz =&gt;</div></pre></td></tr></table></figure>

<p>剩下的就是注入了，生成一个 <code>ComponentRegistry</code> 对象： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ComponentRegistry</span> <span class="keyword">extends</span> <span class="title">UserServiceComponent</span> <span class="keyword">with</span> <span class="title">UserRepositoryComponent</span> </span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">val</span> userRepository: UserRepository = <span class="keyword">new</span> MockUserRepository</div><div class="line">  <span class="keyword">override</span> <span class="keyword">val</span> userService: UserService = <span class="keyword">new</span> UserService(userRepository)</div><div class="line">}</div></pre></td></tr></table></figure>

<p> 挺漂亮的实现， 如果相应的依赖没有提供，或者拼写错误等，编译时能立刻提示我们。<br>这还有一个好处就是所有的对象都是 val 类型的。</p>
<p>这样你就可以通过 <code>ComponentRegistry.userService</code> 来使用顶层的组件了。</p>
<p>这样我们可以实现一种&quot;干净&quot;的方式实现不同的组件注入，比如我们想单元测试 userService ，其中它的依赖 userRepository 通过mock的方式提供： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.scalatest.mock.MockitoSugar</div><div class="line"><span class="keyword">import</span> org.mockito.Matchers._</div><div class="line"><span class="keyword">import</span> org.mockito.Mockito._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TestEnvironment</span> <span class="keyword">extends</span> <span class="title">UserServiceComponent</span> <span class="keyword">with</span> <span class="title">UserRepositoryComponent</span> </span>{</div><div class="line">  <span class="keyword">val</span> userRepository = MockitoSugar.mock[UserRepository]</div><div class="line">  <span class="keyword">val</span> userService = <span class="keyword">new</span> UserService(userRepository)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> <span class="keyword">with</span> <span class="title">TestEnvironment</span></span>{</div><div class="line">  <span class="keyword">val</span> user = User(<span class="string">"user"</span>)</div><div class="line">  userService.create(user)</div><div class="line">  verify(userRepository, times(<span class="number">1</span>)).create(any[User])</div><div class="line">}</div></pre></td></tr></table></figure>

<p> 可以很方便的为测试实现新的依赖注入，其中 userRepository 由mock实现。</p>
<p>这就是蛋糕模式的实现。通过 component trait 抽象接口和依赖，最后在一个 <code>ComponentRegistry</code> 注入各个具体的实现。 </p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf" target="_blank" rel="external">Scalable Component Abstractions</a></li>
<li><a href="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di/" target="_blank" rel="external">Real-World Scala: Dependency Injection (DI)</a></li>
<li><a href="http://www.warski.org/blog/2011/04/di-in-scala-cake-pattern-pros-cons/" target="_blank" rel="external">DI in Scala: Cake Pattern pros &amp; cons</a></li>
<li><a href="http://www.cakesolutions.net/teamblogs/2011/12/15/dependency-injection-vs-cake-pattern" target="_blank" rel="external">Dependency injection vs. Cake pattern</a></li>
<li><a href="http://www.cakesolutions.net/teamblogs/2011/12/19/cake-pattern-in-depth" target="_blank" rel="external">Cake pattern in depth</a></li>
<li><a href="https://coderwall.com/p/t_rapw/cake-pattern-in-scala-self-type-annotations-explicitly-typed-self-references-explained" target="_blank" rel="external">Cake Pattern in Scala / Self type annotations / Explicitly Typed Self References - explained</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p> 如果你是一个Java开发者，熟悉 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">依赖注入</a> 模式, 深度依赖Spring框架的话，在使用Scala做开发时，会问一个问题，在Scala世界里，如何实现类似Spring框架的依赖注入呢？</p>
<p>尽管函数式编程的信徒认为他们不需要DI框架，高阶(high-order)函数足够了。但是对于同时支持面向对象的编程和函数式编程的Scala来说，依赖注入是很好的实现应用的一种设计模式。<br>蛋糕模式(Cake pattern)是Scala实现依赖注入的方式之一。<br>蛋糕模式是 Scala 之父 Martin Odersky 在其论文 <a href="http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf" target="_blank" rel="external">Scalable Component Abstractions</a> 中首先提到。</p>
<p>什么是蛋糕模式呢? 一个非正式的但是很形象的解释是：</p>
<ul>
<li>蛋糕有很多风味， 你可以根据你的需要增加相应的风味。依赖注入就是增加调料。</li>
<li>蛋糕有很多层 (layer)。如果你想要一个更大的蛋糕你就可以增加更多的层。</li>
</ul>
<p>我们先以Spring常用的User数据库读取的实现为例，看看Scala 风格的依赖注入(蛋糕模式)是如何实现的。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大型网站系统架构的演化]]></title>
    <link href="http://colobu.com/2015/07/27/architecture-evolution-of-large-sites/"/>
    <id>http://colobu.com/2015/07/27/architecture-evolution-of-large-sites/</id>
    <published>2015-07-27T01:43:28.000Z</published>
    <updated>2015-07-31T13:28:02.589Z</updated>
    <content type="html"><![CDATA[<p>原文： <a href="http://www.cnblogs.com/leefreeman/p/3993449.html" target="_blank" rel="external">大型网站系统架构的演化</a>, 作者：<a href="http://www.cnblogs.com/leefreeman/" target="_blank" rel="external">李平</a></p>
<p>一个成熟的大型网站（如淘宝、京东等）的系统架构并不是开始设计就具备完整的高性能、高可用、安全等特性，它总是随着用户量的增加，业务功能的扩展逐渐演变完善的，在这个过程中，开发模式、技术架构、设计思想也发生了很大的变化，就连技术人员也从几个人发展到一个部门甚至一条产品线。所以成熟的系统架构是随业务扩展而完善出来的，并不是一蹴而就；不同业务特征的系统，会有各自的侧重点，例如淘宝，要解决海量的商品信息的搜索、下单、支付，例如腾讯，要解决数亿的用户实时消息传输，百度它要处理海量的搜索请求，他们都有各自的业务特性，系统架构也有所不同。尽管如此我们也可以从这些不同的网站背景下，找出其中共用的技术，这些技术和手段可以广泛运行在大型网站系统的架构中，下面就通过介绍大型网站系统的演化过程，来认识这些技术和手段。<br><a id="more"></a></p>
<h2 id="一、最开始的网站架构">一、最开始的网站架构</h2>
<p>最初的架构，应用程序、数据库、文件都部署在一台服务器上，如图：<br><img src="1.png" alt=""></p>
<h2 id="二、应用、数据、文件分离">二、应用、数据、文件分离</h2>
<p>随着业务的扩展，一台服务器已经不能满足性能需求，故将应用程序、数据库、文件各自部署在独立的服务器上，并且根据服务器的用途配置不同的硬件，达到最佳的性能效果。<br><img src="2.png" alt=""></p>
<h2 id="三、利用缓存改善网站性能">三、利用缓存改善网站性能</h2>
<p>在硬件优化性能的同时，同时也通过软件进行性能优化，在大部分的网站系统中，都会利用缓存技术改善系统的性能，使用缓存主要源于热点数据的存在，大部分网站访问都遵循28原则（即80%的访问请求，最终落在20%的数据上），所以我们可以对热点数据进行缓存，减少这些数据的访问路径，提高用户体验。<br><img src="3.png" alt=""><br>缓存实现常见的方式是本地缓存、分布式缓存。当然还有CDN、反向代理等，这个后面再讲。本地缓存，顾名思义是将数据缓存在应用服务器本地，可以存在内存中，也可以存在文件，OSCache就是常用的本地缓存组件。本地缓存的特点是速度快，但因为本地空间有限所以缓存数据量也有限。分布式缓存的特点是，可以缓存海量的数据，并且扩展非常容易，在门户类网站中常常被使用，速度按理没有本地缓存快，常用的分布式缓存是Memcached、Redis。</p>
<h2 id="四、使用集群改善应用服务器性能">四、使用集群改善应用服务器性能</h2>
<p>应用服务器作为网站的入口，会承担大量的请求，我们往往通过应用服务器集群来分担请求数。应用服务器前面部署负载均衡服务器调度用户请求，根据分发策略将请求分发到多个应用服务器节点。<br><img src="4.png" alt=""><br>常用的负载均衡技术硬件的有F5，价格比较贵，软件的有LVS、Nginx、HAProxy。LVS是四层负载均衡，根据目标地址和端口选择内部服务器，Nginx是七层负载均衡和HAProxy支持四层、七层负载均衡，可以根据报文内容选择内部服务器，因此LVS分发路径优于Nginx和HAProxy，性能要高些，而Nginx和HAProxy则更具配置性，如可以用来做动静分离（根据请求报文特征，选择静态资源服务器还是应用服务器）。</p>
<h2 id="五、数据库读写分离和分库分表">五、数据库读写分离和分库分表</h2>
<p>随着用户量的增加，数据库成为最大的瓶颈，改善数据库性能常用的手段是进行读写分离以及分表，读写分离顾名思义就是将数据库分为读库和写库，通过主备功能实现数据同步。分库分表则分为水平切分和垂直切分，水平切换则是对一个数据库特大的表进行拆分，例如用户表。垂直切分则是根据业务不同来切换，如用户业务、商品业务相关的表放在不同的数据库中。<br><img src="5.png" alt=""></p>
<h2 id="六、使用CDN和反向代理提高网站性能">六、使用CDN和反向代理提高网站性能</h2>
<p>假如我们的服务器都部署在成都的机房，对于四川的用户来说访问是较快的，而对于北京的用户访问是较慢的，这是由于四川和北京分别属于电信和联通的不同发达地区，北京用户访问需要通过互联路由器经过较长的路径才能访问到成都的服务器，返回路径也一样，所以数据传输时间比较长。对于这种情况，常常使用CDN解决，CDN将数据内容缓存到运营商的机房，用户访问时先从最近的运营商获取数据，这样大大减少了网络访问的路径。比较专业的CDN运营商有蓝汛、网宿。</p>
<p>而反向代理，则是部署在网站的机房，当用户请求达到时首先访问反向代理服务器，反向代理服务器将缓存的数据返回给用户，如果没有没有缓存数据才会继续走应用服务器获取，也减少了获取数据的成本。反向代理有Squid，Nginx。</p>
<p><img src="6.png" alt=""></p>
<h2 id="七、使用分布式文件系统">七、使用分布式文件系统</h2>
<p>用户一天天增加，业务量越来越大，产生的文件越来越多，单台的文件服务器已经不能满足需求。需要分布式的文件系统支撑。常用的分布式文件系统有NFS。<br><img src="7.png" alt=""></p>
<h2 id="八、使用NoSql和搜索引擎">八、使用NoSql和搜索引擎</h2>
<p>对于海量数据的查询，我们使用nosql数据库加上搜索引擎可以达到更好的性能。并不是所有的数据都要放在关系型数据中。常用的NOSQL有mongodb和redis，搜索引擎有lucene。<br><img src="8.png" alt=""></p>
<h2 id="九、将应用服务器进行业务拆分">九、将应用服务器进行业务拆分</h2>
<p>随着业务进一步扩展，应用程序变得非常臃肿，这时我们需要将应用程序进行业务拆分，如百度分为新闻、网页、图片等业务。每个业务应用负责相对独立的业务运作。业务之间通过消息进行通信或者同享数据库来实现。<br><img src="9.png" alt=""></p>
<h2 id="十、搭建分布式服务">十、搭建分布式服务</h2>
<p>这时我们发现各个业务应用都会使用到一些基本的业务服务，例如用户服务、订单服务、支付服务、安全服务，这些服务是支撑各业务应用的基本要素。我们将这些服务抽取出来利用分部式服务框架搭建分布式服务。淘宝的Dubbo是一个不错的选择。<br><img src="10.png" alt=""></p>
<h2 id="小结">小结</h2>
<p>大型网站的架构是根据业务需求不断完善的，根据不同的业务特征会做特定的设计和考虑，本文只是讲述一个常规大型网站会涉及的一些技术和手段。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="external">《大型网站技术架构》 ——李智慧</a></li>
<li><a href="https://book.douban.com/subject/25790111/" target="_blank" rel="external">《海量运维运营规划》 ——唐文</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文： <a href="http://www.cnblogs.com/leefreeman/p/3993449.html" target="_blank" rel="external">大型网站系统架构的演化</a>, 作者：<a href="http://www.cnblogs.com/leefreeman/" target="_blank" rel="external">李平</a></p>
<p>一个成熟的大型网站（如淘宝、京东等）的系统架构并不是开始设计就具备完整的高性能、高可用、安全等特性，它总是随着用户量的增加，业务功能的扩展逐渐演变完善的，在这个过程中，开发模式、技术架构、设计思想也发生了很大的变化，就连技术人员也从几个人发展到一个部门甚至一条产品线。所以成熟的系统架构是随业务扩展而完善出来的，并不是一蹴而就；不同业务特征的系统，会有各自的侧重点，例如淘宝，要解决海量的商品信息的搜索、下单、支付，例如腾讯，要解决数亿的用户实时消息传输，百度它要处理海量的搜索请求，他们都有各自的业务特性，系统架构也有所不同。尽管如此我们也可以从这些不同的网站背景下，找出其中共用的技术，这些技术和手段可以广泛运行在大型网站系统的架构中，下面就通过介绍大型网站系统的演化过程，来认识这些技术和手段。<br>]]>
    
    </summary>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LinkedIn架构这十年]]></title>
    <link href="http://colobu.com/2015/07/24/brief-history-scaling-linkedin/"/>
    <id>http://colobu.com/2015/07/24/brief-history-scaling-linkedin/</id>
    <published>2015-07-24T02:15:04.000Z</published>
    <updated>2015-07-31T13:28:02.635Z</updated>
    <content type="html"><![CDATA[<p>原文： <a href="http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin" target="_blank" rel="external">A Brief History of Scaling LinkedIn</a></p>
<blockquote>
<p><a href="https://www.linkedin.com/in/joshclemm" target="_blank" rel="external">Josh Clemm</a>是LinkedIn的高级工程经理，自2011年加入LinkedIn。他最近(2015/07/20)写了一篇文章，介绍了LinkedIn针对用户规模急速扩大带来的架构方面的变革。<br>文章有点像子柳写的<a href="https://book.douban.com/subject/24335672/" target="_blank" rel="external">淘宝技术这十年</a></p>
</blockquote>
<p>2003年是LinkedIn元年，公司成立的目标是连接你的个人人脉以获得更好的的工作机会。上线第一周才有2700个会员注册，时光飞梭，LinkedIn的产品、会员数量、服务器负载都极大的增长了。<br>今天，LinkedIn全球用户已经超过3.5亿。我们每秒有数十万个页面被访问，移动端流量已占到50%以上 (<a href="http://blog.linkedin.com/2014/04/18/the-next-three-billion/" target="_blank" rel="external">mobile moment</a>)。所有这些请求都从后台获取数据，而我们的后台系统可以处理每秒上百万次查询。</p>
<p>问题来了： <strong>所有这些是怎么做到的呢？</strong></p>
<a id="more"></a>
<h2 id="早期">早期</h2>
<h3 id="Leo">Leo</h3>
<p>和现在很多站点开始的时候一样， LinkedIn使用一个应用程序做所有的工作。 这个应用程序被称之为 &quot;Leo&quot;。它包含所有的Java Servlet页面， 处理业务逻辑， 连接少量的LinkedIn数据库。<br><img src="leo_arch.png" alt="*哈!早年网站的样式-简单实用*"></p>
<h3 id="Member_Graph_(会员关系图)">Member Graph (会员关系图)</h3>
<p>开始的工作之一就是管理会员之间关系的社交网络。我们需要一个系统通过图遍历(graph traversals)的方式来查询关系数据， 同时需要将数据驻留内存以便获得高效和性能。从这个不同的使用特征来看， 很明显这需要一个独立于Leo的系统以方便扩大规模，于是一个叫做&quot;Clould&quot;专门用于会员关系图(member graph)的独立系统诞生了。这是LinkedIn的第一个服务系统。为了和Leo系统分离，我们使用Java RPC来进行通讯。</p>
<p>也大约在此期间我们需要增加搜索服务的能力。我们的会员关系图服务也提供数据给一个基于<a href="https://lucene.apache.org/" target="_blank" rel="external">Lucene</a>的搜索服务。</p>
<h3 id="Replica_read_DBs_(多个只读数据库副本)">Replica read DBs (多个只读数据库副本)</h3>
<p>随着站点的增长， Leo系统也在扩大， 增加了更多的角色和职能， 也更加复杂。 通过负载均衡可以运行多个Leo实例，但是新增的负载也影响到LinkedIn的最关键系统-会员信息数据库。</p>
<p>一个最容易的解决方案就是垂直扩展 - 在其上增加更多的CPU和内存。这虽然可以支撑一段时间，但是将来我们还是会遇到规模扩展的问题。会员信息数据库既处理读又处理写。 为了扩展，我们引入了复制从库(replica slave DB)。 复制数据库是会员数据库的一个拷贝， 使用 <a href="http://data.linkedin.com/blog/2012/10/driving-the-databus" target="_blank" rel="external">databus</a> (现已开源)的最早版本来进行同步。这些复制从库处理所有的读请求， 并且增加了保证主库和从库数据一致性的逻辑。</p>
<p><img src="arch_master_slave_0.png" alt="*主从读写分离的方案之后，我们转向了数据库分区的解决方案*"></p>
<p>当站点遇到越来越多的流量时，单一的Leo系统经常宕机，而且很难排查和恢复， 发布新代码也很困难。 高可用性对LinkedIn至关重要， 很明显我们需要&quot;干掉&quot; Leo， 把它分解成多个小的功能模块和无状态的服务。<br><img src="leo-poster.jpg" alt="*&quot;Kill Leo&quot;这个咒语在内部传颂了好多年*"></p>
<h3 id="Service_Oriented_Architecture_(面向服务的架构)">Service Oriented Architecture (面向服务的架构)</h3>
<p>工程师开始抽取出一些微服务， 这些微服务提供API和一些业务逻辑， 如搜索，会员信息， 通讯和群组平台。接着我们的表现层也被抽取出来了，比如招聘产品和公共信息页。新产品，新服务都独立于Leo。 不久，各个功能区的垂直栈完成了。<br>我们构建了前端服务器， 可以从不同的域获取数据，处理展示逻辑以及生成HTML (通过JSP)。我们还构建了中间层服务提供API接口访问数据模型以及提供数据库一致性访问后端数据服务。到2010年，我们已经有超过150个独立的服务，而今天，我们已经有超过750个服务。<br><img src="arch_soa_0.png" alt=""><br>因为无状态， 规模扩展可以通过堆叠任意服务的新实例以及在它们之间进行负载均衡来完成。我们给每个服务设定了警戒红线， 知道它的负载能力， 提供早期预警和性能监控。</p>
<h3 id="cache_(缓存)">cache (缓存)</h3>
<p>LinkedIn可预见的增长促使我们要进一步的扩展。我们知道通过添加更多的缓存层以减少负载压力。很多应用开始引入中间缓存层如 <a href="https://en.wikipedia.org/wiki/Memcached" target="_blank" rel="external">memecached</a> 或者 <a href="https://en.wikipedia.org/wiki/Couchbase_Server" target="_blank" rel="external">couchbase</a>。 我们还在数据层增加了缓存， 并且在适当的时候使用 <a href="http://engineering.linkedin.com/tags/voldemort" target="_blank" rel="external">Voldemort</a> 提供预先计算的结果。</p>
<p>之后，我们实际上去掉了中间缓存层。中间缓存层存储来自多个域的数据。虽然开始时缓存看起来是减少压力的一种简单方式，但是缓存数据失效的复杂性和调用图(call graph)变得无法控制。将缓存更可能地接近数据层可以降低延迟， 使我们可以水平扩展，降低可知的负载(cognitive load)。</p>
<h3 id="Kafka">Kafka</h3>
<p>为了收集日益增长的数据，LinkedIn开发了很多定制的数据通道来流水化和队列化数据(streaming and queueing)。 比如， 我们需要将数据放入数据仓库，我们需要将一批数据放入Hadoop工作流以便分析，我们从每个服务中中聚合了大量日志， 我们收集了很多用户追踪事件如页面点击， 我们需要队列化inMail消息系统中的数据， 我们需要保证用户更新完个人信息后搜索数据也是最新的等等。<br>随着网站还在壮大，更多的定制管道出现了。 因为网站规模需要扩展，每一个独立的管道也需要扩展， 有些东西不得不放弃。 结果就是Kafka开发出来了， 它是我们的分布式的发布订阅消息系统。Kafka成为一个统一的管道， 根据<a href="http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="external">commit log</a>的概念构建, 特别注重速度和扩展性。 它可以接近实时的访问数据源，驱动Hadoop任务， 允许我们构建实时的分析，广泛地提升了我们的站点监控和报警能力， 也使我们能够可视化和跟踪调用图(call graph)。 今天， Kafka<br>每天处理超过<a href="http://engineering.linkedin.com/kafka/kafka-linkedin-current-and-future" target="_blank" rel="external">5千亿的事件</a>。<br><img src="kafka.png" alt=""></p>
<h3 id="Inversion(反转)">Inversion(反转)</h3>
<p>扩展可以从很多维度来衡量，包括组织结构。 在2011年底， LinkedIn开始了一个内部创新，叫 “反转” (<a href="http://www.bloomberg.com/bw/articles/2013-04-10/inside-operation-inversion-the-code-freeze-that-saved-linkedin" target="_blank" rel="external">Inversion</a>)。我们暂停了新功能的开发， 允许整个工程部门专注于提升工具，部署，基础架构和开发者生产力上。它成功地使我们可以敏捷地建立可扩展性新产品。</p>
<h2 id="近几年">近几年</h2>
<h3 id="Rest-li">Rest.li</h3>
<p>当我们从Leao转向面向服务的架构后，之前抽取的基于Java RPC的API, 在团队中开始变得不一致了，和表现层耦合太紧，这只会变得更糟。为了解决这个问题， 我们开发了一个新的API模型，叫做 <a href="http://engineering.linkedin.com/architecture/restli-restful-service-architecture-scale" target="_blank" rel="external">Rest.li</a>. Rest.li 符合我们面向数据模型的架构， 确保在整个公司提供一致性的无状态的Restful API模型。<br>基于HTTP的JSON数据， 我们新的API最终很容易地编写非Java的客户端。 LinkedIn今天仍然主要使用Java栈，但是也有很多使用Python, Ruby, Node.js 和 C++的客户端，可能是自己开发的或者收购过来的。  脱离了RPC也让我们将变现层和后端兼容型的问题中挣脱出来。另外， 使用Dynamic Discovery (D2)的Rest.li, 我们可以得到自动的基于负载均衡，服务发现和可扩展的API客户端。<br>今天， LinkedIn有975 个Rest.li资源， 所有的数据中心每天有超过一千亿级Rest.li调用。<br><img src="RestLiClientServerFlow_0_0.png" alt="Rest.li R2/D2 技术站"></p>
<h3 id="Super_Blocks_(超级块)">Super Blocks (超级块)</h3>
<p>面向服务的架构很好的解耦了域之间的联系和可以独立地扩展服务。但是也有缺点， 很多应用获取各种类型的不同的数据， f(call graph)或者叫做&quot;扇出&quot; (fanout)。例如， 任意一次个人信息页的请求就会获取照片，会员关系， 组，订阅信息， 关注，博客，人脉，推荐等信息。 这个调用图很难管理，而且越来越难控制。<br>我们引入了超级块的概念。 为一组后台服务提供一个单一的访问API。这样我们就可以有一个team专门优化这个块，同时保证每个客户端的调用图可控。</p>
<h3 id="Multi-Data_Center_(多数据中心)">Multi-Data Center (多数据中心)</h3>
<p>作为一个会员快速增长的全球化公司，我们需要从一个数据中心进行扩展，我们通过几年的努力来解决这个问题，首先，从两个数据中心（洛杉矶 和 芝加哥）提供了公共个人信息，证明可行后，我们开始增强服务来处理数据复制、不同源的调用、单向数据复制事件、将用户分配到地理位置更近的数据中心。<br>我们大多的数据库运行在<a href="http://engineering.linkedin.com/espresso/introducing-espresso-linkedins-hot-new-distributed-document-store" target="_blank" rel="external">Espresso</a>（一个新的内部多用户数据仓库）上。<br>Espresso支持多个数据中心，提供了 主-主 的支持，及支持很难的数据复制。</p>
<p>多个数据中心对于高可用性具有不可思议的重要性，你要避免的单点故障不仅仅是某个服务失效，更要担心整个站点失效。今天，LinkedIn运行了3个主数据中心，同时还有全球化的<a href="http://engineering.linkedin.com/performance/how-linkedin-used-pops-and-rum-make-dynamic-content-download-25-faster" target="_blank" rel="external">PoPs</a>服务。<br><img src="data_centers_pops_0.png" alt="LinkedIn&#39;s operational setup as of 2015 (circles represent data centers, diamonds represent PoPs)"></p>
<h3 id="我们还做了哪些工作？">我们还做了哪些工作？</h3>
<p>当然，我们的扩展故事永远不会这么简单。我们的工程和运维团队这些年做了不计其数的工作，主要包括这些大的创新：<br>这些年很多最关键系统都有自己丰富的扩展演化历史，包括会员图服务（Leo之外的第一个服务），搜索（第二个服务），新闻种子，通讯平台及会员信息后台。</p>
<p>我们还构建了数据基础平台支持长期的增长，这是Databus和Kafka的第一次实战，后来用Samza做数据流服务，Espresso和Voldemort作存储解决方案，Pinot用来分析系统，以及其它自定义解决方案。另外，我们的工具也得到了提升，这样工程师就可以自动化布署这些基础架构。</p>
<p>我们还使用Hadoop和Voldemort数据开发了大量的离线工作流，用以智能分析，如“你可能认识的人”，“相似经历”，“感觉兴趣的校友”及“个人简历浏览地图”。</p>
<p>我们重新考虑了前端的实现，增加客户端模板到混合页面（个人中心、我的大学页面），这样应用可以更加可交互，只要我们的服务器发送JSON或部分JSON数据。此外，模板页面通过CDN和浏览器缓存。我们也开始使用了BigPipe和Play框架，把我们的模型从线程化的服务器变成非阻塞异步的服务器。</p>
<p>除了代码，我们使用了Apache Traffic Server做多层代理和用HAProxy做负载均衡，数据中心，安全，智能路由，服务端渲染等等。</p>
<p>最后，我们继续提升服务器的性能，包含优化硬件，内存和系统的高级优化，使用更新的JRE。</p>
<h3 id="下一步">下一步</h3>
<p>LinkedIn今天仍在快速增长，仍有大量值得提升的工作要做，我们正在解决一些问题，看起来只解决了一部分 - <a href="https://www.linkedin.com/company/linkedin/careers?trk=eng-blog" target="_blank" rel="external">快来加入我们吧！</a></p>
<p>感谢Steve, Swee, Venkat, Eran, Ram, Brandon, Mammad, 和 Nick的审阅和帮助</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文： <a href="http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin" target="_blank" rel="external">A Brief History of Scaling LinkedIn</a></p>
<blockquote>
<p><a href="https://www.linkedin.com/in/joshclemm" target="_blank" rel="external">Josh Clemm</a>是LinkedIn的高级工程经理，自2011年加入LinkedIn。他最近(2015/07/20)写了一篇文章，介绍了LinkedIn针对用户规模急速扩大带来的架构方面的变革。<br>文章有点像子柳写的<a href="https://book.douban.com/subject/24335672/" target="_blank" rel="external">淘宝技术这十年</a></p>
</blockquote>
<p>2003年是LinkedIn元年，公司成立的目标是连接你的个人人脉以获得更好的的工作机会。上线第一周才有2700个会员注册，时光飞梭，LinkedIn的产品、会员数量、服务器负载都极大的增长了。<br>今天，LinkedIn全球用户已经超过3.5亿。我们每秒有数十万个页面被访问，移动端流量已占到50%以上 (<a href="http://blog.linkedin.com/2014/04/18/the-next-three-billion/" target="_blank" rel="external">mobile moment</a>)。所有这些请求都从后台获取数据，而我们的后台系统可以处理每秒上百万次查询。</p>
<p>问题来了： <strong>所有这些是怎么做到的呢？</strong></p>
]]>
    
    </summary>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用cgroups限制MongoDB的内存使用]]></title>
    <link href="http://colobu.com/2015/07/23/Using-Cgroups-to-Limit-MongoDB-memory-usage/"/>
    <id>http://colobu.com/2015/07/23/Using-Cgroups-to-Limit-MongoDB-memory-usage/</id>
    <published>2015-07-23T01:16:30.000Z</published>
    <updated>2015-07-31T13:28:02.510Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt" target="_blank" rel="external">cgroups</a>，其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。</p>
<p>这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词有许多不同的意义，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。自那以后，又添加了很多功能。</p>
<p>使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。<br>在实践中，系统管理员一般会利用cgroup做下面这些事：</p>
<ul>
<li>隔离一个进程组（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li>
<li>为这组进程 分配其足够使用的内存</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制</li>
<li>限制访问某些设备（通过设置设备的白名单）</li>
</ul>
<a id="more"></a>
<h2 id="cgroups相关概念">cgroups相关概念</h2>
<ol>
<li>任务（<strong>task</strong>）。在cgroups中，任务就是系统的一个进程。</li>
<li>控制组群（<strong>control group</strong>）。控制组群就是一组按照某种标准划分的进程。cgroups中的资源控制都是以控制组群为单位实现。一个进程可以加入到某个控制组群，也从一个进程组迁移到另一个控制组群。一个进程组的进程可以使用cgroups以控制组群为单位分配的资源，同时受到cgroups以控制组群为单位设定的限制。</li>
<li>层级（<strong>hierarchy</strong>）。控制组群可以组织成hierarchical的形式，既一颗控制组群树。控制组群树上的子节点控制组群是父节点控制组群的孩子，继承父控制组群的特定的属性。</li>
<li>子系统（<strong>subsystem</strong>）。一个子系统就是一个资源控制器，比如cpu子系统就是控制cpu时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制组群都受到这个子系统的控制。</li>
</ol>
<p>当前的cgroup有一下规则：<br>1.每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 root cgroup ，此cgroup在创建层级时自动创建，后面在该层级中创建的cgroup都是此cgroup的后代）的初始成员。<br>2.一个子系统最多只能附加到一个层级。 (一个层级不会附加两个同样的子系统)<br>3.一个层级可以附加多个子系统<br>4.一个任务可以是多个cgroup的成员，但是这些cgroup必须在不同的层级。<br>5.系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup 的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的cgroup。</p>
<h2 id="cgroup子系统">cgroup子系统</h2>
<p>cgroups为每种可以控制的资源定义了一个子系统。典型的子系统介绍如下：</p>
<ol>
<li><strong>cpu</strong> 子系统，主要限制进程的 cpu 使用率。</li>
<li><strong>cpuacct</strong> 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li><strong>cpuset</strong> 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li>
<li><strong>memory</strong> 子系统，可以限制进程的 memory 使用量。</li>
<li><strong>blkio</strong> 子系统，可以限制进程的块设备 io。</li>
<li><strong>devices</strong> 子系统，可以控制进程能够访问某些设备。</li>
<li><strong>net_cls</strong> 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li>
<li><strong>freezer</strong> 子系统，可以挂起或者恢复 cgroups 中的进程。</li>
<li><strong>ns</strong> 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。</li>
</ol>
<h2 id="cgroups安装">cgroups安装</h2>
<p>如果系统还没有安装cgroups,可以通过下面的命令进行安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install libcgroup</div></pre></td></tr></table></figure>

<p>启动和查看服务状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service cgconfig start</div><div class="line">service cgconfig status</div></pre></td></tr></table></figure>

<p>Linux把cgroups实现成一个文件系统，各个子系统的挂载点配置在<code>/etc/cgconfig.conf</code>文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="title">mount</span> {</div><div class="line">        <span class="title">cpuset</span>  = /cgroup/cpuset;</div><div class="line">        <span class="title">cpu</span>     = /cgroup/cpu;</div><div class="line">        <span class="title">cpuacct</span> = /cgroup/cpuacct;</div><div class="line">        <span class="title">memory</span>  = /cgroup/memory;</div><div class="line">        <span class="title">devices</span> = /cgroup/devices;</div><div class="line">        <span class="title">freezer</span> = /cgroup/freezer;</div><div class="line">        <span class="title">net_cls</span> = /cgroup/net_cls;</div><div class="line">        <span class="title">blkio</span>   = /cgroup/blkio;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者也可以通过命令<code>lssubsys -m</code>或者<code>mount -t cgroup</code>挂载。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># lssubsys -m            </span></div><div class="line">cpuset /cgroup/cpuset</div><div class="line">cpu /cgroup/cpu</div><div class="line">cpuacct /cgroup/cpuacct</div><div class="line">memory /cgroup/memory</div><div class="line">devices /cgroup/devices</div><div class="line">freezer /cgroup/freezer</div><div class="line">net_cls /cgroup/net_cls</div><div class="line">blkio /cgroup/blkio</div></pre></td></tr></table></figure>

<p>或者你单独挂载某几个子系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t cgroup -o remount,cpu,cpuset,memory cpu_and_mem /cgroup/cpu_and_mem</div></pre></td></tr></table></figure>

<h2 id="cgroups使用">cgroups使用</h2>
<p>挂载某一个 cgroups 子系统到挂载点之后，就可以通过在挂载点下面建立文件夹或者使用<code>cgcreate</code>命令的方法创建 cgroups 层级结构中的节点。比如通过命令<code>cgcreate -g cpu:test</code>就可以在 cpu 子系统下建立一个名为 test 的节点。结果如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cgcreate -g cpu:test</span></div><div class="line"><span class="comment"># ls /cgroup/cpu</span></div><div class="line">cgroup.event_control  cpu.cfs_quota_us   cpu.shares         release_agent</div><div class="line">cgroup.procs          cpu.rt_period_us   cpu.stat           tasks</div><div class="line">cpu.cfs_period_us     cpu.rt_runtime_us  notify_on_release  test</div></pre></td></tr></table></figure>

<p>然后可以通过写入需要的值到 test 下面的不同文件，来配置需要限制的资源。每个子系统下面都可以进行多种不同的配置，需要配置的参数各不相同，详细的参数设置需要参考 cgroups 手册。使用 <code>cgset</code> 命令也可以设置 cgroups 子系统的参数，格式为 <code>cgset -r parameter=value path_to_cgroup</code>。<br>比如：<code>cgset -r cfs_quota_us=50000 test</code>限制进程组 test 使用50%的CPU。<br>或者直接写文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">echo 50000 &gt;</span> /cgroup/cpu/test/cpu.cfs_quota_us</span></div></pre></td></tr></table></figure>

<p>命令可以参考redhat的文档： <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/Setting_Parameters.html" target="_blank" rel="external">Setting Parameters</a></p>
<p>当需要删除某一个 cgroups 节点的时候，可以使用 <code>cgdelete</code> 命令，比如要删除上述的 <em>test</em> 节点，可以使用 <code>cgdelete -r cpu:test</code>命令进行删除。</p>
<p>把进程加入到 cgroups 子节点也有多种方法，可以直接把 pid 写入到子节点下面的 task 文件中。也可以通过 <code>cgclassify</code> 添加进程，格式为 <code>cgclassify -g subsystems:path_to_cgroup pidlist</code>，也可以直接使用 <code>cgexec</code> 在某一个 cgroups 下启动进程，格式为<code>cgexec -g subsystems:path_to_cgroup command arguments</code>.</p>
<p>也可以在<code>/etc/cgconfig.conf</code>文件中定义group,格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">group <span class="tag">&lt;<span class="title">name</span>&gt;</span> {</div><div class="line">    [<span class="tag">&lt;<span class="title">permissions</span>&gt;</span>]</div><div class="line">    <span class="tag">&lt;<span class="title">controller</span>&gt;</span> {</div><div class="line">        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>&gt;</span> = <span class="tag">&lt;<span class="title">param</span> <span class="attribute">value</span>&gt;</span>;</div><div class="line">        …</div><div class="line">    }</div><div class="line">    …</div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">mount {</div><div class="line">		<span class="variable">cpuset  =</span> /cgroup/cpuset;</div><div class="line">		<span class="variable">cpu     =</span> /cgroup/cpu;</div><div class="line">		<span class="variable">cpuacct =</span> /cgroup/cpuacct;</div><div class="line">		<span class="variable">memory  =</span> /cgroup/memory;</div><div class="line">		<span class="variable">devices =</span> /cgroup/devices;</div><div class="line">		<span class="variable">freezer =</span> /cgroup/freezer;</div><div class="line">		<span class="variable">net_cls =</span> /cgroup/net_cls;</div><div class="line">		<span class="variable">blkio   =</span> /cgroup/blkio;</div><div class="line">}</div><div class="line">     </div><div class="line">   group mysql_g1 {    </div><div class="line">       cpu {  </div><div class="line">               cpu.<span class="variable">cfs_quota_us =</span> <span class="number">50000</span>;  </div><div class="line">               cpu.<span class="variable">cfs_period_us =</span> <span class="number">100000</span>;  </div><div class="line">       }  </div><div class="line">       cpuset {    </div><div class="line">               cpuset.<span class="variable">cpus =</span> <span class="string">"3"</span>;    </div><div class="line">               cpuset.<span class="variable">mems =</span> <span class="string">"0"</span>;    </div><div class="line">       }    </div><div class="line">       cpuacct{  </div><div class="line">     </div><div class="line">       }  </div><div class="line">       memory {    </div><div class="line">               memory.<span class="variable">limit_in_bytes=</span><span class="number">104857600</span>;  </div><div class="line">               memory.<span class="variable">swappiness=</span><span class="number">0</span>;  </div><div class="line">               <span class="comment"># memory.max_usage_in_bytes=104857600;  </span></div><div class="line">               <span class="comment"># memory.oom_control=0;  </span></div><div class="line">       }   </div><div class="line">       blkio  {  </div><div class="line">              blkio.throttle.<span class="variable">read_bps_device=</span><span class="string">"8:0 524288"</span>;  </div><div class="line">              blkio.throttle.<span class="variable">write_bps_device=</span><span class="string">"8:0 524288"</span>;  </div><div class="line">       }   </div><div class="line">   }</div></pre></td></tr></table></figure>

<p>还可以让一个服务Service启动的时候加入进程组，具体文档请参考： <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/Starting_a_Process.html#Starting_a_Service" target="_blank" rel="external">Starting_a_Service</a></p>
<p>Redhat的文档详细的介绍了cgroups的配置和使用方法，是很好的一个参考资料。</p>
<h2 id="实践，限制MongoDB的内存使用">实践，限制MongoDB的内存使用</h2>
<p>MongoDB是个吃内存的大户，它会尽可能的使用服务器的内存。在数据量巨大的时候，内存很快会被吃光，导致服务器上其它进程无法分配内存。<br>我们可以使用cgroups来限制MongoDB的内存使用。实际上，在参考文档2中 Vadim Tkachenko 就介绍了他的实际方法。</p>
<p>配置有几个步骤：</p>
<ol>
<li>创建一个控制组群：<code>cgcreate -g memory:DBLimitedGroup</code></li>
<li>指定可用的最大内存16G: <code>echo 16G &gt; /sys/fs/cgroup/memory/DBLimitedGroup/memory.limit_in_bytes</code></li>
<li>将缓存页丢掉 (flush and drop): <code>sync; echo 3 &gt; /proc/sys/vm/drop_caches</code></li>
<li>将mongodb的进程加入控制组：<code>cgclassify -g memory:DBLimitedGroup</code>pid of mongod``</li>
</ol>
<p>基本上就完成了任务，这样此MongoDB最多可以使用16G的内存。<br>为了处理机器重启还得手工添加的问题，你可以按照上面的文档将Mongo服务加入到控制组中。</p>
<p>除此之外，作者还提到了 dirty cache flush的问题， 注意两个参数：<code>/proc/sys/vm/dirty_background_ratio</code>和<code>/proc/sys/vm/dirty_ratio</code>。</p>
<p>这里有一篇关于调整磁盘缓冲参数的介绍：<br><strong>1)  /proc/sys/vm/dirty_ratio  </strong><br>这个参数控制文件系统的文件系统写缓冲区的大小，单位是百分比，表示系统内存的百分比，表示当写缓冲使用到系统内存多少的时候，开始向磁盘写出数据。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时，应该降低其数值，：<br><code>echo &#39;1&#39; &gt; /proc/sys/vm/dirty_ratio</code></p>
<p><strong>2)  /proc/sys/vm/dirty_background_ratio  </strong><br>这个参数控制文件系统的pdflush进程，在何时刷新磁盘。单位是百分比，表示系统内存的百分比，意思是当写缓冲使用到系统内存多少的时候，pdflush开始向磁盘写出数据。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时，应该降低其数值，：  </p>
<p><code>echo &#39;1&#39; &gt; /proc/sys/vm/dirty_background_ratio</code>  </p>
<p><strong>3)  /proc/sys/vm/dirty_writeback_centisecs  </strong><br>这个参数控制内核的脏数据刷新进程pdflush的运行间隔。单位是 1/100 秒。缺省数值是500，也就是 5 秒。如果你的系统是持续地写入动作，那么实际上还是降低这个数值比较好，这样可以把尖峰的写操作削平成多次写操作。设置方法如下：  </p>
<p><code>echo &quot;100&quot; &gt; /proc/sys/vm/dirty_writeback_centisecs</code><br>如果你的系统是短期地尖峰式的写操作，并且写入数据不大（几十M/次）且内存有比较多富裕，那么应该增大此数值：  </p>
<p><code>echo &quot;1000&quot; &gt; /proc/sys/vm/dirty_writeback_centisecs</code> </p>
<p><strong>4)  /proc/sys/vm/dirty_expire_centisecs  </strong><br>这个参数声明Linux内核写缓冲区里面的数据多“旧”了之后，pdflush进程就开始考虑写到磁盘中去。单位是 1/100秒。缺省是 30000，也就是 30 秒的数据就算旧了，将会刷新磁盘。对于特别重载的写操作来说，这个值适当缩小也是好的，但也不能缩小太多，因为缩小太多也会导致IO提高太快。  </p>
<p><code>echo &quot;100&quot; &gt; /proc/sys/vm/dirty_expire_centisecs</code><br>当然，如果你的系统内存比较大，并且写入模式是间歇式的，并且每次写入的数据不大（比如几十M），那么这个值还是大些的好。  </p>
<p><strong>5) /proc/sys/vm/vfs_cache_pressure  </strong><br>该文件表示内核回收用于directory和inode   cache内存的倾向；缺省值100表示内核将根据pagecache和swapcache，把directory和inode   cache保持在一个合理的百分比；降低该值低于100，将导致内核倾向于保留directory和inode   cache；增加该值超过100，将导致内核倾向于回收directory和inode   cache  </p>
<p>缺省设置：100  </p>
<p><strong>6) /proc/sys/vm/min_free_kbytes  </strong><br>该文件表示强制Linux   VM最低保留多少空闲内存（Kbytes）。<br>缺省设置：724（512M物理内存）  </p>
<p><strong>7) /proc/sys/vm/nr_pdflush_threads  </strong><br>该文件表示当前正在运行的pdflush进程数量，在I/O负载高的情况下，内核会自动增加更多的pdflush进程。<br>缺省设置：2（只读）  </p>
<p><strong>8) /proc/sys/vm/overcommit_memory  </strong><br>该文件指定了内核针对内存分配的策略，其值可以是0、1、2。<br>0，   表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br>1，   表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2，   表示内核允许分配超过所有物理内存和交换空间总和的内存（参照overcommit_ratio）。  </p>
<p>缺省设置：0  </p>
<p><strong>9) /proc/sys/vm/overcommit_ratio  </strong><br>该文件表示，如果overcommit_memory=2，可以过载内存的百分比，通过以下公式来计算系统整体可用内存。<br>系统可分配内存=交换空间+物理内存*overcommit_ratio/100 </p>
<p><strong>10) /proc/sys/vm/page-cluster  </strong><br>该文件表示在写一次到swap区的时候写入的页面数量，0表示1页，1表示2页，2表示4页。<br>缺省设置：3（2的3次方，8页）  </p>
<p><strong>11)   /proc/sys/vm/swapiness  </strong><br>该文件表示系统进行交换行为的程度，数值（0-100）越高，越可能发生磁盘交换。</p>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt" target="_blank" rel="external">https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt</a></li>
<li><a href="https://www.percona.com/blog/2015/07/01/using-cgroups-to-limit-mysql-and-mongodb-memory-usage/" target="_blank" rel="external">Using Cgroups to Limit MySQL and MongoDB memory usage</a></li>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/index.html" target="_blank" rel="external">Red Hat Enterprise Linux 6 Resource Management Guide</a></li>
<li><a href="http://blog.csdn.net/JesseYoung/article/details/39077829" target="_blank" rel="external">cgroups介绍及安装配置使用详解</a></li>
<li><a href="http://tech.meituan.com/cgroups.html" target="_blank" rel="external">美团 Linux资源管理之cgroups简介</a></li>
<li><a href="http://coolshell.cn/articles/17049.html" target="_blank" rel="external">Docker基础技术：Linux CGroup</a></li>
<li><a href="http://nannan408.iteye.com/blog/2097679" target="_blank" rel="external">linux集群之--设置磁盘缓冲参数</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt" target="_blank" rel="external">cgroups</a>，其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。</p>
<p>这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词有许多不同的意义，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。自那以后，又添加了很多功能。</p>
<p>使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。<br>在实践中，系统管理员一般会利用cgroup做下面这些事：</p>
<ul>
<li>隔离一个进程组（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li>
<li>为这组进程 分配其足够使用的内存</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制</li>
<li>限制访问某些设备（通过设置设备的白名单）</li>
</ul>
]]>
    
    </summary>
    
      <category term="cgroups" scheme="http://colobu.com/tags/cgroups/"/>
    
      <category term="Linux" scheme="http://colobu.com/categories/Linux/"/>
    
  </entry>
  
</feed>
