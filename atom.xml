<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2016-02-16T03:34:21.376Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Scala Async 库]]></title>
    <link href="http://colobu.com/2016/02/15/Scala-Async/"/>
    <id>http://colobu.com/2016/02/15/Scala-Async/</id>
    <published>2016-02-15T08:07:38.000Z</published>
    <updated>2016-02-15T08:45:46.094Z</updated>
    <content type="html"><![CDATA[<p>在我以前的文章中，我介绍了<a href="http://colobu.com/2015/06/11/Scala-Future-and-Promise/" target="_blank" rel="external">Scala Future and Promise</a>。<code>Future</code>代表一个异步计算，你可以设置你的回调函数或者利用<code>Await.result</code>等待获取异步计算的结果,你还可以组合多个<code>future</code>为一个新的<code>future</code>。<code>Promise</code>让你可以控制是否完成计算还是抛出异常，它的<code>future</code>方法返回一个<code>Future</code>对象，<code>complete</code>、<code>success</code>和<code>failure</code>允许你完成计算。如果想要同步操作，可以使用<code>Await.result</code>等待<code>Future</code>完成或者超时，对于没有实现<code>Awaitable</code>的代码块，可以使用<code>blocking</code>方法实现同步执行。<br><a id="more"></a></p>
<p>以上是对上一篇文章的总结。Scala官方还提供了一个<code>Async</code>库，用来简化Scala异步操作，尽管这个库还没有正式加入到Scala的标准库中。它是通过Scala <code>macro</code>特性实现的。</p>
<p><code>async</code>用来标记一块异步执行的代码，通常这块代码中包含包含一个或者多个<code>await</code>调用。如果没有<code>await</code>调用，我们用<code>future</code>方法就可以了。<br>这样,对于复杂的异步代码，你不必使用<code>map</code>、<code>flatMap</code>或者回调来实现复杂的多层的调用嵌套。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ExecutionContext.Implicits.global</div><div class="line"><span class="keyword">import</span> scala.async.Async.{async, await}</div><div class="line"></div><div class="line"><span class="keyword">val</span> future = async {</div><div class="line">  <span class="keyword">val</span> f1 = async { ...; <span class="keyword">true</span> }</div><div class="line">  <span class="keyword">val</span> f2 = async { ...; <span class="number">42</span> }</div><div class="line">  <span class="keyword">if</span> (await(f1)) await(f2) <span class="keyword">else</span> <span class="number">0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如下面的代码，我们使用纯<code>future</code>实现：</p>
<figure class="highlight scaladef"><figcaption><span>slowCalcFuture: Future[Int] = ...</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val future1 = slowCalcFuture</div><div class="line">val future2 = slowCalcFuture</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">combined</span>:</span> Future[Int] = <span class="keyword">for</span> {</div><div class="line">  r1 &lt;- future1</div><div class="line">  r2 &lt;- future2</div><div class="line">} <span class="keyword">yield</span> r1 + r2</div></pre></td></tr></table></figure>

<p>如果使用<code>async/await</code>，代码将得到简化。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> combined: Future[Int] = async {</div><div class="line">  <span class="keyword">val</span> future1 = slowCalcFuture</div><div class="line">  <span class="keyword">val</span> future2 = slowCalcFuture</div><div class="line">  await(future1) + await(future2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>事实上，这个框架是<a href="http://docs.scala-lang.org/sips/pending/async.html" target="_blank" rel="external">SIP-22 - Async</a>的参考实现。这个Scala特性提议发布于2013年。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我以前的文章中，我介绍了<a href="http://colobu.com/2015/06/11/Scala-Future-and-Promise/" target="_blank" rel="external">Scala Future and Promise</a>。<code>Future</code>代表一个异步计算，你可以设置你的回调函数或者利用<code>Await.result</code>等待获取异步计算的结果,你还可以组合多个<code>future</code>为一个新的<code>future</code>。<code>Promise</code>让你可以控制是否完成计算还是抛出异常，它的<code>future</code>方法返回一个<code>Future</code>对象，<code>complete</code>、<code>success</code>和<code>failure</code>允许你完成计算。如果想要同步操作，可以使用<code>Await.result</code>等待<code>Future</code>完成或者超时，对于没有实现<code>Awaitable</code>的代码块，可以使用<code>blocking</code>方法实现同步执行。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/tags/Scala/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala 魔法函数]]></title>
    <link href="http://colobu.com/2016/01/04/Scala-magic-functions/"/>
    <id>http://colobu.com/2016/01/04/Scala-magic-functions/</id>
    <published>2016-01-04T02:18:16.000Z</published>
    <updated>2016-01-04T07:44:14.182Z</updated>
    <content type="html"><![CDATA[<p>Scala有一些语法糖，让一些特定名称的函数拥有一些特殊的能力。这些语法糖并没有专门的文档介绍，只是散落在不同的文章和教程中。本文整理里这些魔法函数，并通过例子演示它们的功能。<br><a id="more"></a></p>
<h2 id="apply,_unapply">apply, unapply</h2>
<p>当类或对象有一个主要用途的时候，<code>apply</code>方法为你提供了一个很好的语法糖。比如<code>a</code>是一个对象， <code>a.apply(x)</code>则可以简化为<code>a(x)</code><br><code>unapply</code>方法是抽取器(Extractor)，有人也翻译成提取器，经常用在模式匹配上。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = Foo(<span class="number">1</span>)</div><div class="line">foo <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> Foo(x) =&gt; println(x)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(val x: Int)</span> </span>{}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Foo</span> </span>{</div><div class="line">  <span class="keyword">def</span> apply(x: Int) = <span class="keyword">new</span> Foo(x)</div><div class="line">  <span class="keyword">def</span> unapply(f: Foo) = Some(f.x)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们一般都在伴生对象内定义<code>apply</code>,<code>unapply</code>方法，但是<code>Trait</code>,<code>class</code>内都可以定义这些方法。</p>
<h2 id="update">update</h2>
<p>与<code>apply</code>方法类似，<code>update</code>也是一个魔法方法。对于一个实例<code>a</code>, Scala可以将<code>a.update(x,y)</code>简化为<code>a(x)=y</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bar = Bar(<span class="number">10</span>)</div><div class="line">bar(<span class="number">0</span>) = <span class="number">1</span></div><div class="line">println(bar(<span class="number">0</span>))</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(n :Int)</span> </span>{</div><div class="line">  <span class="keyword">val</span> a = Array[Int](n)</div><div class="line"></div><div class="line">  <span class="keyword">def</span> apply(n :Int) = a(n)</div><div class="line">  <span class="keyword">def</span> update(n:Int, v:Int) = a(n) = v</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bar</span> </span>{</div><div class="line">  <span class="keyword">def</span> apply(n :Int) = <span class="keyword">new</span> Bar(n)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>val bar = Bar(10)</code>调用伴生对象的<code>apply</code>方法生成一个<code>Bar</code>的实例。<code>bar(0) = 1</code>等价于<code>bar.update(0,1)</code>。<code>println(bar(0))</code>等价于<code>println(bar.apply(0))</code>,也就是<code>class Bar</code>中定义的<code>apply</code>方法。</p>
<h2 id="unapplySeq">unapplySeq</h2>
<p>类似<code>unapply</code>,用来从对象中抽取序列，常用在模式匹配上：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> m = M(<span class="number">1</span>)</div><div class="line"></div><div class="line">m <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> M(n1,others@_*) =&gt; println(others)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span> </span>{}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">M</span> </span>{</div><div class="line">  <span class="keyword">def</span> apply(a: Int*): M = <span class="keyword">new</span> M</div><div class="line">  <span class="keyword">def</span> unapplySeq(m: M): Option[Seq[Int]] = Some(<span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: Nil)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="identifier_=">identifier_=</h2>
<p>如果你只是简单的字段操作，只需定义一个<code>var</code>类型的属性即可。但是如果你在set的时候执行额外的逻辑，比如参数检查等，你就可能需要<code>setter</code>符号。<br>Scala为setter提供了特殊的语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> obj = <span class="keyword">new</span> X</div><div class="line">obj.x = -<span class="number">1</span></div><div class="line">println(obj.x)</div><div class="line">obj.x = <span class="number">10</span></div><div class="line">println(obj.x)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>{</div><div class="line">  <span class="keyword">var</span> _x = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="comment">//setter</span></div><div class="line">  <span class="keyword">def</span> x_=(n: Int) {</div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) _x = <span class="number">0</span> <span class="keyword">else</span> _x = n</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//getter</span></div><div class="line">  <span class="keyword">def</span> x = _x</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的例子中<code>x_=</code>就是<code>x</code>的setter。</p>
<h2 id="一元操作符">一元操作符</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function_or_atom">unary_</span>+</div><div class="line"><span class="function_or_atom">unary_</span>-</div><div class="line"><span class="function_or_atom">unary_</span><span class="exclamation_mark">!</span></div><div class="line"><span class="function_or_atom">unary_</span>~</div></pre></td></tr></table></figure>

<p>如果你想重载/实现一元操作符(+,-,!,~)，可以定义上面的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> X('小')</div><div class="line">println(!x)</div><div class="line">x.s = '黑'</div><div class="line">println(!x)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(var s: Char)</span> </span>{</div><div class="line">  <span class="keyword">val</span> s1 = <span class="string">"大小多少长短胖瘦高矮黑白冷暖"</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> unary_! = {</div><div class="line">    <span class="keyword">var</span> i = s1 indexOf s</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) i = i + <span class="number">1</span> <span class="keyword">else</span> i = i - <span class="number">1</span></div><div class="line">    <span class="keyword">new</span> X(s1(i))</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"X("</span> + s + <span class="string">")"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="op=">op=</h2>
<p>如果你定义了一个操作符<code>op</code>,那么<code>A &lt;op&gt;= B</code>能自动转换为<code>A = A &lt;op&gt; B</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> X(<span class="string">"abc"</span>)</div><div class="line">s ::/ <span class="number">1</span></div><div class="line">println(s)</div><div class="line">s ::/= <span class="number">1</span></div><div class="line">println(s)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(var s: String)</span> </span>{</div><div class="line">  <span class="keyword">def</span> ::/(n:Int) = {</div><div class="line">    <span class="keyword">new</span> X(s + n)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"X("</span> + s + <span class="string">")"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>操作符不能是字母和数字(alphanumeric)，也不能是!=, ==, &lt;= 或者 &gt;=。</p>
<h2 id="Dynamic">Dynamic</h2>
<p>Dynamic对象可以调用不存在的字段或者方法，Scala将它们转换为下面的四个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">selectDynamic</span></div><div class="line">updateDynamic</div><div class="line">applyDynamic </div><div class="line">applyDynamicNamed</div></pre></td></tr></table></figure>

<p>这有点动态语言的风格。</p>
<p>例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> d = <span class="keyword">new</span> DynImpl</div><div class="line">  println(d.foo)</div><div class="line">  d.foo = <span class="number">10</span></div><div class="line">  println(d.ints(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</div><div class="line">  println(d.ints(i1 = <span class="number">1</span>, i2 = <span class="number">2</span>, <span class="number">3</span>))</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DynImpl</span> <span class="keyword">extends</span> <span class="title">Dynamic</span> </span>{</div><div class="line">    <span class="keyword">var</span> map = Map.empty[String, Any]</div><div class="line"></div><div class="line">    <span class="keyword">def</span> selectDynamic(name: String) = name</div><div class="line"></div><div class="line">    <span class="keyword">def</span> updateDynamic(name: String)(value: Any) {</div><div class="line">      map += name -&gt; value</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">def</span> applyDynamic(name: String)(args: Any*) = s<span class="string">"method '$name' called with arguments ${args.mkString("</span>'<span class="string">", "</span>', '<span class="string">", "</span>'<span class="string">")}"</span></div><div class="line"></div><div class="line">    <span class="keyword">def</span> applyDynamicNamed(name: String)(args: (String, Any)*) = s<span class="string">"method '$name' called with arguments ${args.mkString("</span>'<span class="string">", "</span>', '<span class="string">", "</span>'<span class="string">")}"</span></div><div class="line">  }</div></pre></td></tr></table></figure>

<h2 id="_*">_*</h2>
<p><code>_*</code>可以用作模式匹配任意数量的参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">A</span><span class="params">(n: Int*)</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> a = A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">a <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> A(<span class="number">1</span>, <span class="number">2</span>, _*) =&gt;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以将可变参数绑定到一个值上：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> A(<span class="number">1</span>, <span class="number">2</span>, as @_*) =&gt; println(as)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外<code>_*</code>还可以作为辅助类型描述：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = <span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: Nil</div><div class="line"><span class="keyword">val</span> a2 = A(l :_*)</div></pre></td></tr></table></figure>

<p>这里<code>:_*</code>用来将集合作为可变参数传递。</p>
<h2 id="@_Pattern_Binders"><code>@</code> Pattern Binders</h2>
<p>Scala规范8.1.3定义了模式绑定的定义。上面的例子<code>as @_*</code>也演示了这个功能。下面再看个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Number</span><span class="params">(num: Double)</span> <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">UnOp</span><span class="params">(operator: String, arg: Expr)</span> <span class="keyword">extends</span> <span class="title">Expr</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> expr = UnOp(<span class="string">"abs"</span>, Number(-<span class="number">1</span>))</div><div class="line">expr <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> UnOp(<span class="string">"abs"</span>, e @ Number(_)) =&gt; println(e)</div><div class="line">  <span class="keyword">case</span> _ =&gt;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://stackoverflow.com/questions/1483212/list-of-scalas-magic-functions" target="_blank" rel="external">http://stackoverflow.com/questions/1483212/list-of-scalas-magic-functions</a></li>
<li><a href="http://stackoverflow.com/questions/15799811/how-does-type-dynamic-work-and-how-to-use-it" target="_blank" rel="external">http://stackoverflow.com/questions/15799811/how-does-type-dynamic-work-and-how-to-use-it</a></li>
<li><a href="http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html#pattern-binders" target="_blank" rel="external">http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html#pattern-binders</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Scala有一些语法糖，让一些特定名称的函数拥有一些特殊的能力。这些语法糖并没有专门的文档介绍，只是散落在不同的文章和教程中。本文整理里这些魔法函数，并通过例子演示它们的功能。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka 0.9 发布]]></title>
    <link href="http://colobu.com/2015/12/04/Kafka-0-9-is-released/"/>
    <id>http://colobu.com/2015/12/04/Kafka-0-9-is-released/</id>
    <published>2015-12-04T02:00:55.000Z</published>
    <updated>2015-12-04T03:29:19.166Z</updated>
    <content type="html"><![CDATA[<p>confluent的CTO Neha Narkhede女士在11月24日宣布 <a href="http://www.confluent.io/blog/apache-kafka-0.9-is-released" target="_blank" rel="external">Apache Kafka 发布0.9版本</a>。confluent是由apache kafka的创建者也就是LinkedIn开发Kafka的那个team成立的一家公司。这个版本提供了相当多的Feature和bug fix,具体的改动可以参看 <a href="https://people.apache.org/~junrao/kafka-0.9.0.0-candidate4/RELEASE_NOTES.html" target="_blank" rel="external">523 JIRA</a><br>以下是0.9的主要的改动:<br><a id="more"></a></p>
<h3 id="安全">安全</h3>
<p>这次Kafka提供了三个安全特性。一是提供Kerberos 和 TLS 身份认证。而是提供了类似Unix-like权限系统，控制哪些用户可以访问数据。三是提供数据传输加密。<br>当然只有新的producer，consumer API和0.9的consumer实现才能使用这些安全特性。很抱歉的是老的API还是没有这些安全方面的控制。<br>当然这些安全特性实现了向下兼容的方式，不启动安全特性的用户不必担心性能的降低。<br>这只是第一版的安全特性，更多的安全控制会在将来的版本中提供。</p>
<h3 id="Kafka_Connect">Kafka Connect</h3>
<p>Kafka成为一个非常流行的实时数据流系统。社区也写了很多的connector 比如 <a href="https://github.com/linkedin/camus" target="_blank" rel="external">Camus</a>,mongo-connector-kafka-doc-manager,couchbase-kafka-connector<br>等，但是由于各个厂家/社区/个人实现的项目，不统一，学习起来也有曲线,所以Kafka 0.9提供了一个新的Feature:Kafka Connect (Copycat)。<br><img src="Kafka_Connect_graphic.png" alt=""></p>
<p>Kafka Connect可以方便地在Kafka上进行大规模的数据导入导出。</p>
<h3 id="为用户定义配额">为用户定义配额</h3>
<p>一个大的Kafka集群可能有多个用户。0.9以前，consumer 如果处理的消息非常快，可能会垄断整个boker的网络资源，producer也是如此。现在Kafka 0.9提供了基于client的用户配额控制。对于Producer可以控制每个client的每秒写的字节数，对于Consumer控制每个client的每秒读的字节。</p>
<h3 id="新的Consumer">新的Consumer</h3>
<p>Kafka 0.8.2, Producer被重新设计， Kafka 0.9则重新设计了Consumer接口。它不再区分high-level consumer API和low-level consumer API，而是提供了一个统一的consumer API。<br>Kafka本身可以维护offset,consumer的position,也可以自己维护。这样consumer可以不借助ZooKeeper，而是使用自己的系统来保持自己的读取位置。</p>
<p>Kafka 0.9不再支持 Java 6和Scala 2.9。</p>
<p>贡献者应该有10个左右的中国人或者华人，挺不错。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="http://www.confluent.io/blog/apache-kafka-0.9-is-released" target="_blank" rel="external">http://www.confluent.io/blog/apache-kafka-0.9-is-released</a></li>
<li><a href="http://hadoop1989.com/2015/12/03/Kafka-0.9-Feature/" target="_blank" rel="external">http://hadoop1989.com/2015/12/03/Kafka-0.9-Feature/</a></li>
<li><a href="http://kafka.apache.org/090/documentation.html" target="_blank" rel="external">http://kafka.apache.org/090/documentation.html</a></li>
<li><a href="https://people.apache.org/~junrao/kafka-0.9.0.0-candidate4/RELEASE_NOTES.html" target="_blank" rel="external">https://people.apache.org/~junrao/kafka-0.9.0.0-candidate4/RELEASE_NOTES.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>confluent的CTO Neha Narkhede女士在11月24日宣布 <a href="http://www.confluent.io/blog/apache-kafka-0.9-is-released" target="_blank" rel="external">Apache Kafka 发布0.9版本</a>。confluent是由apache kafka的创建者也就是LinkedIn开发Kafka的那个team成立的一家公司。这个版本提供了相当多的Feature和bug fix,具体的改动可以参看 <a href="https://people.apache.org/~junrao/kafka-0.9.0.0-candidate4/RELEASE_NOTES.html" target="_blank" rel="external">523 JIRA</a><br>以下是0.9的主要的改动:<br>]]>
    
    </summary>
    
      <category term="kafka" scheme="http://colobu.com/tags/kafka/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为豆瓣电影实现Item-based协同过滤的推荐系统]]></title>
    <link href="http://colobu.com/2015/12/03/item-based-recommender-for-douban-movies/"/>
    <id>http://colobu.com/2015/12/03/item-based-recommender-for-douban-movies/</id>
    <published>2015-12-03T03:00:03.000Z</published>
    <updated>2015-12-03T03:22:44.629Z</updated>
    <content type="html"><![CDATA[<p>前面的两篇文章分别使用Spark mllib ALS实现了Model-based协同过滤推荐系统和使用Mahout实现了User-based的协同过滤推荐系统。<br>我们再来回顾一下item-base CF算法的特点：</p>
<ul>
<li>物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大</li>
<li>适合长尾物品丰富，用户个性化需求强的领域</li>
<li>对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性</li>
<li>利用用户历史行为做推荐解释，比较令用户信服</li>
</ul>
<p>所以item-base挺适合做电影的推荐。当用户浏览某个电影的时候，我们可以推荐给他类似的电影，或者根据用户以前的观影记录，推荐他感兴趣的电影。<br>本文还是以mahout 非分布式计算的方式实现。因为电影的记录比较少(166条),计算量不是很大。<br><a id="more"></a><br>代码也非常的简单，我们还是以皮尔逊算法计算相似度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubanItemBasedRecommender</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        String base = args[<span class="number">0</span>];</div><div class="line">        File file = <span class="keyword">new</span> File(base + <span class="string">"user_movies.csv"</span>);</div><div class="line">        DoubanFileDataModel model = <span class="keyword">new</span> DoubanFileDataModel(file);</div><div class="line">        ItemSimilarity similarity = <span class="keyword">new</span> PearsonCorrelationSimilarity(model);</div><div class="line">        ItemBasedRecommender recommender = <span class="keyword">new</span> GenericItemBasedRecommender(model, similarity);</div><div class="line">        BatchItemSimilarities batch = <span class="keyword">new</span> MultithreadedBatchItemSimilarities(recommender, <span class="number">5</span>);</div><div class="line">        <span class="keyword">int</span> numSimilarities = batch.computeItemSimilarities(Runtime.getRuntime().availableProcessors(), <span class="number">1</span>, <span class="keyword">new</span> FileSimilarItemsWriter(<span class="keyword">new</span> File(base + <span class="string">"item_result.csv"</span>)));</div><div class="line">        System.out.println(<span class="string">"Computed "</span> + numSimilarities + <span class="string">" similarities for "</span> + model.getNumItems() + <span class="string">" items "</span> + <span class="string">"and saved them to file "</span> + base + <span class="string">"item_result.csv"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第<strong>8</strong>行和第<strong>9</strong>行使用多线程批处理的方式，把计算结果写入到一个文件中。<br>生成的文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="code">......</span></div><div class="line">25821461,26253733,0.8279288411140442</div><div class="line">25821461,26252196,0.819756031036377</div><div class="line">25821461,26366634,0.8181818127632141</div><div class="line">25821461,25919385,0.7033082246780396</div><div class="line">25821585,26328118,0.794719398021698</div><div class="line">25821585,22556810,0.7655318379402161</div><div class="line">25821585,1972724,0.6770924925804138</div><div class="line">25821585,25809260,0.6347297430038452</div><div class="line">......</div></pre></td></tr></table></figure>

<p>电影 25821461 (旅程终点) 的信息如下：<br><a href="http://movie.douban.com/subject/25821461/" title="" target="_blank"><img src="25821461.jpg" style="display:inline;margin-right:20px;" alt=""></a></p>
<p>和它相似度比较高的电影如下：<br><a href="http://movie.douban.com/subject/26253733/" title="" target="_blank"><img src="26253733.jpg" style="display:inline;margin-right:20px;" alt=""></a><a href="http://movie.douban.com/subject/26252196/" title="" target="_blank"><img src="26252196.jpg" style="display:inline;margin-right:20px;" alt=""></a><a href="http://movie.douban.com/subject/26366634/" title="" target="_blank"><img src="26366634.jpg" style="display:inline;margin-right:20px;" alt=""></a><a href="http://movie.douban.com/subject/25919385/" title="" target="_blank"><img src="25919385.jpg" style="display:inline;margin-right:20px;" alt=""></a></p>
<p>推荐还不错，基本都属于剧情，喜剧类型，而且都是国外的，没有推荐战争，科幻或者武侠类的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面的两篇文章分别使用Spark mllib ALS实现了Model-based协同过滤推荐系统和使用Mahout实现了User-based的协同过滤推荐系统。<br>我们再来回顾一下item-base CF算法的特点：</p>
<ul>
<li>物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大</li>
<li>适合长尾物品丰富，用户个性化需求强的领域</li>
<li>对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性</li>
<li>利用用户历史行为做推荐解释，比较令用户信服</li>
</ul>
<p>所以item-base挺适合做电影的推荐。当用户浏览某个电影的时候，我们可以推荐给他类似的电影，或者根据用户以前的观影记录，推荐他感兴趣的电影。<br>本文还是以mahout 非分布式计算的方式实现。因为电影的记录比较少(166条),计算量不是很大。<br>]]>
    
    </summary>
    
      <category term="推荐系统" scheme="http://colobu.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="协同过滤，mahout" scheme="http://colobu.com/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%8Cmahout/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为豆瓣电影实现User-based协同过滤的推荐系统]]></title>
    <link href="http://colobu.com/2015/12/02/user-based-recommender-for-douban-movies/"/>
    <id>http://colobu.com/2015/12/02/user-based-recommender-for-douban-movies/</id>
    <published>2015-12-02T05:48:36.000Z</published>
    <updated>2015-12-03T03:20:49.372Z</updated>
    <content type="html"><![CDATA[<p>协同过滤（Collaborative Filtering），简单来说是利用某兴趣相投、拥有共同经验之群体的喜好来推荐使用者感兴趣的信息，个人透过合作的机制给予信息相当程度的反馈（如评分）并记录下来以达到过滤的目的进而帮助别人筛选信息，反馈不一定局限于特别感兴趣的，特别不感兴趣信息的纪录也相当重要，比如浏览信息，收藏，分享，点击等。<br><a id="more"></a><br>在前一篇文章 <a href="http://colobu.com/2015/11/30/movie-recommendation-for-douban-users-by-spark-mllib/" target="_blank" rel="external">使用Spark MLlib给豆瓣用户推荐电影 </a>中，在那篇文章我我介绍了使用Spark MLlib实现了model-based 的系统过滤之推荐系统。但是Spark并没有提供user-based, item-based这两种memory-based传统的协同过滤算法，所以接下来的这两篇文章我会介绍使用<a href="http://mahout.apache.org/" target="_blank" rel="external">Mahout</a>实现user-based和item-based的电影推荐系统，数据还是基于豆瓣用户对电影的评论数据集。</p>
<p>Mahout是Apache的实现大规模的高性能的机器学习框架。它提供了很多的机器学习的算法和工具，以及利用Hadoop实现分布式的计算，本文将使用它的协同过滤算法(CF)实现非分布式的单机程序。</p>
<p>user-based协同过滤推荐算法就是通过不同用户对item的评分来评测用户之间的相似性，基于用户之间的相似性做出推荐。<br>下一篇文章中介绍item-based协同过滤推荐算法是通过用户对不同item的评分来评测item之间的相似性，基于item之间的相似性做出推荐。</p>
<p><strong>User-based 优点</strong>：</p>
<ul>
<li>能够过滤机器难以自动内容分析的信息，如艺术品，音乐等。</li>
<li>共用其他人的经验，避免了内容分析的不完全或不精确，并且能够基于一些复杂的，难以表述的概念（如信息质量、个人品味）进行过滤。</li>
<li>有推荐新信息的能力。可以发现内容上完全不相似的信息，使用者对推荐信息的内容事先是预料不到的。可以发现使用者潜在的但自己尚未发现的兴趣偏好。</li>
<li>推荐个性化、自动化程度高。能够有效的利用其他相似使用者的反馈信息。加快个性化学习的速度。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>新使用者问题(New User Problem) 系统开始时推荐质量较差</li>
<li>新项目问题(New Item Problem) 质量取决于历史资料集</li>
<li>稀疏性问题（Sparsity）</li>
<li>系统延伸性问题（Scalability）。</li>
</ul>
<p>下面根据代码介绍具体的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubanUserBasedRecommender</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Long, String&gt; <span class="title">getMovies</span>(String base) {</div><div class="line">        Map&lt;Long, String&gt; movies = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            File file = <span class="keyword">new</span> File(base + <span class="string">"hot_movies.csv"</span>);</div><div class="line">            FileLineIterator iterator = <span class="keyword">new</span> FileLineIterator(file, <span class="keyword">false</span>);</div><div class="line">            String line = iterator.next();</div><div class="line">            <span class="keyword">while</span> (!line.isEmpty()) {</div><div class="line">                String[] m = line.split(<span class="string">","</span>);</div><div class="line">                movies.put(Long.parseLong(m[<span class="number">0</span>]), m[<span class="number">2</span>]);</div><div class="line">                line = iterator.next();</div><div class="line">            }</div><div class="line">            Closeables.close(iterator, <span class="keyword">true</span>);</div><div class="line">        } <span class="keyword">catch</span> (Exception ex) {</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> movies;</div><div class="line">    }</div><div class="line">	......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面一段代码是生成电影ID和名称的字典，这个文件的每一行代表一条热门电影，如<code>20645098,8.2,小王子</code>。这样在我们输出结果的时候，可以方便的查看电影名，因为电影名比ID更有意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubanUserBasedRecommender</span> </span>{</div><div class="line">	......</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        String base = args[<span class="number">0</span>];</div><div class="line">        File file = <span class="keyword">new</span> File(base + <span class="string">"user_movies.csv"</span>);</div><div class="line">        DoubanFileDataModel model = <span class="keyword">new</span> DoubanFileDataModel(file);</div><div class="line">		<span class="comment">//皮尔逊相似度</span></div><div class="line">        UserSimilarity similarity = <span class="keyword">new</span> PearsonCorrelationSimilarity(model);</div><div class="line">        UserNeighborhood neighborhood = <span class="keyword">new</span> NearestNUserNeighborhood(<span class="number">2</span>, similarity, model);</div><div class="line">        Recommender recommender = <span class="keyword">new</span> GenericUserBasedRecommender(model, neighborhood, similarity);</div><div class="line">        Recommender cachingRecommender = <span class="keyword">new</span> CachingRecommender(recommender);</div><div class="line">		<span class="comment">//查看一些结果</span></div><div class="line">		Map&lt;Long, String&gt; movies = getMovies(base);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> userID = <span class="number">0</span>; userID &lt; <span class="number">100</span>; userID++) {</div><div class="line">            String userName = model.userIDAndNameMapping.get(userID);</div><div class="line">            List&lt;RecommendedItem&gt; recommendations = cachingRecommender.recommend(userID, <span class="number">2</span>);</div><div class="line">            System.out.print(<span class="string">"为用户 "</span> + userName + <span class="string">" 推荐电影:"</span>);</div><div class="line">            <span class="keyword">for</span> (RecommendedItem recommendation : recommendations) {</div><div class="line">                System.out.print(recommendation.getItemID() + <span class="string">","</span> + movies.get(recommendation.getItemID()) + <span class="string">" "</span>);</div><div class="line">            }</div><div class="line">            System.out.println();</div><div class="line">        }</div><div class="line">		<span class="comment">//输出结果到文件</span></div><div class="line">		PrintWriter writer = <span class="keyword">new</span> PrintWriter(base + <span class="string">"result.csv"</span>, <span class="string">"UTF-8"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> userID = <span class="number">0</span>; userID &lt; model.userIDAndNameMapping.size(); userID++) {</div><div class="line">            String userName = model.userIDAndNameMapping.get(userID);</div><div class="line">            List&lt;RecommendedItem&gt; recommendations = cachingRecommender.recommend(userID, <span class="number">5</span>);</div><div class="line">            <span class="keyword">if</span> (recommendations.size() &gt; <span class="number">0</span>) {</div><div class="line">                String line = userName + <span class="string">","</span>;</div><div class="line">                <span class="keyword">for</span> (RecommendedItem recommendation : recommendations) {</div><div class="line">                    line += recommendation.getItemID() + <span class="string">":"</span> + movies.get(recommendation.getItemID()) + <span class="string">","</span>;</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (line.endsWith(<span class="string">","</span>))</div><div class="line">                    line = line.substring(<span class="number">0</span>, line.length() - <span class="number">1</span>);</div><div class="line">                writer.println(line);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        writer.close();</div></pre></td></tr></table></figure>

<p>第<strong>6</strong>行读入数据模型，因为我们的数据文件中用户的id是字符串类型的，我们需要将它转换成一个Long类型的数据，所以实现了一个定制的类<code>DoubanFileDataModel</code>。<br>第<strong>8</strong>行我们使用<code>PearsonCorrelationSimilarity</code>计算相似度，Mahout还提供了其它的计算相似度的算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//曼哈顿相似度</span></div><div class="line">      <span class="comment">//UserSimilarity similarity = new org.apache.mahout.cf.taste.impl.similarity.CityBlockSimilarity(model);</span></div><div class="line">      <span class="comment">//欧几里德相似度</span></div><div class="line">      <span class="comment">//UserSimilarity similarity = new org.apache.mahout.cf.taste.impl.similarity.EuclideanDistanceSimilarity(model);</span></div><div class="line">      <span class="comment">//对数似然相似度</span></div><div class="line">      <span class="comment">//UserSimilarity similarity = new org.apache.mahout.cf.taste.impl.similarity.LogLikelihoodSimilarity(model);</span></div><div class="line">      <span class="comment">//斯皮尔曼相似度</span></div><div class="line">      <span class="comment">//UserSimilarity similarity = new org.apache.mahout.cf.taste.impl.similarity.SpearmanCorrelationSimilarity(model);</span></div><div class="line">      <span class="comment">//Tanimoto 相似度</span></div><div class="line">      <span class="comment">//UserSimilarity similarity = new org.apache.mahout.cf.taste.impl.similarity.TanimotoCoefficientSimilarity(model)</span></div><div class="line">      <span class="comment">//Cosine相似度</span></div><div class="line">      <span class="comment">//UserSimilarity similarity = new org.apache.mahout.cf.taste.impl.similarity.UncenteredCosineSimilarity();</span></div></pre></td></tr></table></figure>

<p>第<strong>10</strong>生成UserBased Recommender类。<br>第<strong>13</strong>行到第<strong>22</strong>行我们为前100个用户生成推荐结果，并输出到终端窗口，这样我们可以先检查一下推荐的结果。<br>因为矩阵是很稀疏的，这种user-based算法可能没有提供给用户推荐的电影，有的用户可能不到5个推荐电影。<br>这段代码剩下的部分就是把所有的用户推荐结果都输出到一个文件中。</p>
<p><code>DoubanFileDataModel</code>类的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubanFileDataModel</span> <span class="keyword">extends</span> <span class="title">FileDataModel</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Long&gt; userNameAndIDMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Long,String&gt; userIDAndNameMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> userID = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="title">DoubanFileDataModel</span>(File dataFile) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="keyword">super</span>(dataFile);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="title">DoubanFileDataModel</span>(File dataFile, String delimiterRegex) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="keyword">super</span>(dataFile, delimiterRegex);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="title">DoubanFileDataModel</span>(File dataFile, <span class="keyword">boolean</span> transpose, <span class="keyword">long</span> minReloadIntervalMS) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="keyword">super</span>(dataFile, transpose, minReloadIntervalMS);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="title">DoubanFileDataModel</span>(File dataFile, <span class="keyword">boolean</span> transpose, <span class="keyword">long</span> minReloadIntervalMS, String delimiterRegex) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="keyword">super</span>(dataFile, transpose, minReloadIntervalMS, delimiterRegex);</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">readUserIDFromString</span>(String value) {</div><div class="line">        value = value.trim();</div><div class="line">        <span class="keyword">if</span> (userNameAndIDMapping.containsKey(value)) {</div><div class="line">            <span class="keyword">return</span> userNameAndIDMapping.get(value);</div><div class="line">        }</div><div class="line">        userNameAndIDMapping.put(value, userID);</div><div class="line">        userIDAndNameMapping.put(userID, value);</div><div class="line">        userID++;</div><div class="line">        <span class="keyword">return</span> (userID -<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">readItemIDFromString</span>(String value) {</div><div class="line">        value = value.trim();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.readItemIDFromString(value);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面是推荐结果的片段:</p>
<figure class="highlight csv"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">yuan521123,1866473:蚁人</div><div class="line">58472013,26289144:滚蛋吧！肿瘤君,2973079:霍比特人3：五军之战,23761370:速度与激情7,25746375:我是路人甲</div><div class="line">65532408,26021055:栀子花开</div><div class="line">68333051,10533913:头脑特工队,10741643:我的个神啊,10827341:疯狂外星人,25823833:天将雄师,26289144:滚蛋吧！肿瘤君</div><div class="line">80755814,11624706:小黄人大眼萌,10533913:头脑特工队,25723907:捉妖记,26289144:滚蛋吧！肿瘤君,24879839:道士下山</div><div class="line">129734802,25908042:横冲直撞好莱坞</div><div class="line">127252296,10741643:我的个神啊,25723907:捉妖记,2973079:霍比特人3：五军之战,6126442:一步之遥</div><div class="line">aellr,6846893:超能查派,25779218:匆匆那年,24879839:道士下山</div><div class="line">67656730,3338862:终结者：创世纪,6845667:秘密特工,6873042:明日世界,25752261:女间谍,25823833:天将雄师</div><div class="line">ravinenoravine,25838463:像素大战</div></pre></td></tr></table></figure>

<p>比如用户 52973703，我们为ta推荐：<br><a href="http://movie.douban.com/subject/26289144/" title="" target="_blank"><img src="26289144.jpg" style="display:inline;margin-right:20px;" alt=""></a><a href="http://movie.douban.com/subject/24879839/" title="" target="_blank"><img src="24879839.jpg" style="display:inline;" alt=""></a></p>
<p>user-based CF算法适用于：</p>
<ul>
<li>用户较少的场合，否则用户相似度矩阵计算代价很大</li>
<li>适合时效性较强，用户个性化兴趣不太明显的领域</li>
<li>对新用户不友好，对新物品友好，因为用户相似度矩阵不能实时计算</li>
<li>很难提供令用户信服的推荐解释</li>
</ul>
<p>item-based CF算法适用于：</p>
<ul>
<li>物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大</li>
<li>适合长尾物品丰富，用户个性化需求强的领域</li>
<li>对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性</li>
<li>利用用户历史行为做推荐解释，比较令用户信服</li>
</ul>
<p>推荐阅读项亮的<a href="http://book.douban.com/subject/10769749/" target="_blank" rel="external">推荐系统实践</a>,了解推荐系统的基础知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>协同过滤（Collaborative Filtering），简单来说是利用某兴趣相投、拥有共同经验之群体的喜好来推荐使用者感兴趣的信息，个人透过合作的机制给予信息相当程度的反馈（如评分）并记录下来以达到过滤的目的进而帮助别人筛选信息，反馈不一定局限于特别感兴趣的，特别不感兴趣信息的纪录也相当重要，比如浏览信息，收藏，分享，点击等。<br>]]>
    
    </summary>
    
      <category term="推荐系统" scheme="http://colobu.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="协同过滤，mahout" scheme="http://colobu.com/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%8Cmahout/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Spark MLlib给豆瓣用户推荐电影]]></title>
    <link href="http://colobu.com/2015/11/30/movie-recommendation-for-douban-users-by-spark-mllib/"/>
    <id>http://colobu.com/2015/11/30/movie-recommendation-for-douban-users-by-spark-mllib/</id>
    <published>2015-11-30T07:10:11.000Z</published>
    <updated>2015-12-02T07:01:12.717Z</updated>
    <content type="html"><![CDATA[<p>推荐算法就是利用用户的一些行为，通过一些数学算法，推测出用户可能喜欢的东西。<br>随着电子商务规模的不断扩大，商品数量和种类不断增长，用户对于检索和推荐提出了更高的要求。由于不同用户在兴趣爱好、关注领域、个人经历等方面的不同，以满足不同用户的不同推荐需求为目的、不同人可以获得不同推荐为重要特征的个性化推荐系统应运而生。<br><a id="more"></a></p>
<p>推荐系统成为一个相对独立的研究方向一般被认为始自1994年明尼苏达大学GroupLens研究组推出的GroupLens系统。该系统有两大重要贡献：一是首次提出了基于协同过滤(Collaborative Filtering)来完成推荐任务的思想，二是为推荐问题建立了一个形式化的模型。基于该模型的协同过滤推荐引领了之后推荐系统在今后十几年的发展方向。</p>
<p>目前，推荐算法已经已经被广泛集成到了很多商业应用系统中，比较著名的有Netflix在线视频推荐系统、Amazon网络购物商城等。实际上，大多数的电子商务平台尤其是网络购物平台，都不同程度地集成了推荐算法，如淘宝、京东商城等。Amazon发布的数据显示，亚马逊网络书城的推荐算法为亚马逊每年贡献近三十个百分点的创收。</p>
<h3 id="常用的推荐算法">常用的推荐算法</h3>
<ol>
<li>基于人口统计学的推荐(Demographic-Based Recommendation):该方法所基于的基本假设是“一个用户有可能会喜欢与其相似的用户所喜欢的物品”。当我们需要对一个User进行个性化推荐时，利用User Profile计算其它用户与其之间的相似度，然后挑选出与其最相似的前K个用户，之后利用这些用户的购买和打分信息进行推荐。</li>
<li>基于内容的推荐(Content-Based Recommendation):Content-Based方法所基于的基本假设是“一个用户可能会喜欢和他曾经喜欢过的物品相似的物品”。</li>
<li>基于协同过滤的推荐(Collaborative Filtering-Based Recommendation)是指收集用户过去的行为以获得其对产品的显式或隐式信息，即根据用户对<br>物品或者信息的偏好，发现物品或者内容本身的相关性、或用户的相关性，然后再基于这些关联性进行推荐。基于协同过滤的推荐可以分基于用户的推荐（User-based Recommendation），基于物品的推荐（Item-based Recommendation），基于模型的推荐（Model-based Recommendation）等子类。</li>
</ol>
<blockquote>
<p>以上内容copy自参考文档1</p>
</blockquote>
<h3 id="ALS算法">ALS算法</h3>
<p>LS是alternating least squares的缩写 , 意为交替最小二乘法。该方法常用于基于矩阵分解的推荐系统中。例如：将用户(user)对商品(item)的评分矩阵分解为两个矩阵：一个是用户对商品隐含特征的偏好矩阵，另一个是商品所包含的隐含特征的矩阵。在这个矩阵分解的过程中，评分缺失项得到了填充，也就是说我们可以基于这个填充的评分来给用户最商品推荐了。<br>由于评分数据中有大量的缺失项，传统的矩阵分解SVD（奇异值分解）不方便处理这个问题，而ALS能够很好的解决这个问题。对于R(m×n)的矩阵，ALS旨在找到两个低维矩阵X(m×k)和矩阵Y(n×k)，来近似逼近R(m×n)，即：$\tilde{R} = XY$ ，其中 ，$X\in \mathbb{R}^{m\times d}$，$Y\in \mathbb{R}^{d\times n}$，d 表示降维后的维度，一般 d&lt;&lt;r，r表示矩阵 R 的秩，$r&lt;&lt;min(m,n)$。</p>
<p>为了找到低维矩阵X,Y最大程度地逼近矩分矩阵R，最小化下面的平方误差损失函数。<br>$$L(X,Y) = \sum_{u,i}(r_{ui} - x_{u}^{T}y_{i})^{2}$$</p>
<p>为防止过拟合给公式 (1) 加上正则项，公式改下为： $$L(X,Y) = \sum_{u,i}(r_{ui} - x_{u}^{T}y_{i})^{2} + \lambda (\left | x_{u}\right |^{2} +　\left | y_{i}\right |^{2})......(2)$$</p>
<p>其中$x_{u}\in \mathbb{R}^{d}，y_{i}\in \mathbb{R}^{d}$，$1\leqslant u\leqslant m$，$1\leqslant i\leqslant n$，$\lambda$是正则项的系数。<br>MLlib 的实现算法中有以下一些参数：</p>
<dl><br><dt>numBlocks</dt><br><dd>用于并行化计算的分块个数 (-1为自动分配)</dd><br><dt>rank</dt><br><dd>模型中隐藏因子的个数，也就是上面的<em>r</em></dd><br><dt>iterations</dt><br><dd>迭代的次数，推荐值：10-20</dd><br><dt>lambda</dt><br><dd>惩罚函数的因数，是ALS的正则化参数，推荐值：0.01</dd><br><dt>implicitPrefs</dt><br><dd>决定了是用显性反馈ALS的版本还是用适用隐性反馈数据集的版本</dd><br><dt>alpha</dt><br><dd>是一个针对于隐性反馈 ALS 版本的参数，这个参数决定了偏好行为强度的基准</dd><br></dl>

<p><strong>隐性反馈 vs 显性反馈</strong><br>基于矩阵分解的协同过滤的标准方法一般将用户商品矩阵中的元素作为用户对商品的显性偏好。 在许多的现实生活中的很多场景中，我们常常只能接触到隐性的反馈（例如游览，点击，购买，喜欢，分享等等）在 MLlib 中所用到的处理这种数据的方法来源于文献： <a href="http://labs.yahoo.com/files/HuKorenVolinsky-ICDM08.pdf" target="_blank" rel="external">Collaborative Filtering for Implicit Feedback Datasets</a>。 本质上，这个方法将数据作为二元偏好值和偏好强度的一个结合，而不是对评分矩阵直接进行建模。因此，评价就不是与用户对商品的显性评分而是和所观察到的用户偏好强度关联了起来。然后，这个模型将尝试找到隐语义因子来预估一个用户对一个商品的偏好。</p>
<p>以上的介绍带着浓重的学术气息，需要阅读更多的背景知识才能了解这些算法的奥秘。Spark MLlib为我们提供了很好的协同算法的封装。 当前MLlib支持基于模型的协同过滤算法，其中<strong>user</strong>和<strong>product</strong>对应上面的user和item，user和product之间有一些隐藏因子。MLlib使用<a href="http://dl.acm.org/citation.cfm?id=1608614" target="_blank" rel="external">ALS(alternating least squares)</a>来学习/得到这些潜在因子。</p>
<p>下面我们就以实现一个豆瓣电影推荐系统为例看看如何使用Spark实现此类推荐系统。以此类推，你也可以尝试实现豆瓣图书，豆瓣音乐，京东电器商品推荐系统。</p>
<h3 id="豆瓣数据集">豆瓣数据集</h3>
<p>一般学习Spark MLlib ALS会使用<a href="http://grouplens.org/datasets/movielens/" target="_blank" rel="external">movielens</a>数据集。这个数据集保存了用户对电影的评分。<br>但是这个数据集对于国内用户来说有点不接地气，事实上国内有一些网站可以提供这样的数据集，比如豆瓣，它的人气还是挺高的。<br>但是豆瓣并没有提供这样一个公开的数据集，所以我用抓取了一些数据做测试。<br>数据集分为两个文件：</p>
<ul>
<li>hot_movies.csv: 这个文件包含了热门电影的列表，一种166个热门电影。格式为 <code>&lt;movieID&gt;,&lt;评分&gt;,&lt;电影名&gt;</code>，如</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20645098,8.2,小王子</div><div class="line">26259677,8.3,垫底辣妹</div><div class="line">11808948,7.2,海绵宝宝</div><div class="line">26253733,6.4,突然变异</div><div class="line">25856265,6.7,烈日迷踪</div><div class="line">26274810,6.6,侦探：为了原点</div></pre></td></tr></table></figure>

<ul>
<li>user_movies.csv: 这个文件包含用户对热门电影的评价，格式为<code>&lt;userID&gt;:&lt;movieID&gt;:&lt;评分&gt;</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">adamwzw,<span class="number">20645098</span>,<span class="number">4</span></div><div class="line">bak<span class="built_in">a_mono</span>,<span class="number">20645098</span>,<span class="number">3</span></div><div class="line">iRayc,<span class="number">20645098</span>,<span class="number">2</span></div><div class="line">blueandgreen,<span class="number">20645098</span>,<span class="number">3</span></div><div class="line"><span class="number">130992805</span>,<span class="number">20645098</span>,<span class="number">4</span></div><div class="line"><span class="number">134629166</span>,<span class="number">20645098</span>,<span class="number">5</span></div><div class="line">wangymm,<span class="number">20645098</span>,<span class="number">3</span></div></pre></td></tr></table></figure>

<p>可以看到，用户名并不完全是整数类型的，但是MLlib ALS算法要求user,product都是整型的，所以我们在编程的时候需要处理一下。<br>有些用户只填写了评价，并没有打分，文件中将这样的数据记为-1。在ALS算法中，把它转换成3.0，也就是及格60分。虽然可能和用户的实际情况不相符，但是为了简化运算，我在这里做了简化处理。<br>用户的评分收集了大约100万条，实际用户大约22万。这个矩阵还是相当的稀疏。</p>
<p>注意这个数据集完全基于豆瓣公开的网页，不涉及任何个人的隐私。</p>
<h3 id="模型实现">模型实现</h3>
<p>本系统使用Scala实现。<br>首先读入这两个文件，得到相应的弹性分布数据集RDD (第<strong>7</strong>行和第<strong>8</strong>行)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">DoubanRecommender</span> </span>{</div><div class="line">  <span class="keyword">def</span> main(args: Array[String]): Unit = {</div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> SparkContext(<span class="keyword">new</span> SparkConf().setAppName(<span class="string">"DoubanRecommender"</span>))</div><div class="line">    <span class="comment">//val base = "/opt/douban/"</span></div><div class="line">    <span class="keyword">val</span> base = <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) args(<span class="number">0</span>) <span class="keyword">else</span> <span class="string">"/opt/douban/"</span></div><div class="line">    <span class="comment">//获取RDD</span></div><div class="line">    <span class="keyword">val</span> rawUserMoviesData = sc.textFile(base + <span class="string">"user_movies.csv"</span>)</div><div class="line">    <span class="keyword">val</span> rawHotMoviesData = sc.textFile(base + <span class="string">"hot_movies.csv"</span>)</div><div class="line">    <span class="comment">//准备数据</span></div><div class="line">    preparation(rawUserMoviesData, rawHotMoviesData)</div><div class="line">    println(<span class="string">"准备完数据"</span>)</div><div class="line">    model(sc, rawUserMoviesData, rawHotMoviesData)</div><div class="line">  }</div><div class="line">  ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第<strong>10</strong>行调用<code>preparation</code>方法，这个方法主要用来检查分析数据，得到数据集的一些基本的统计信息，还没有到协同算法那一步。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> preparation( rawUserMoviesData: RDD[String],</div><div class="line">                 rawHotMoviesData: RDD[String]) = {</div><div class="line">  <span class="keyword">val</span> userIDStats = rawUserMoviesData.map(_.split(',')(<span class="number">0</span>).trim).distinct().zipWithUniqueId().map(_._2.toDouble).stats()</div><div class="line">  <span class="keyword">val</span> itemIDStats = rawUserMoviesData.map(_.split(',')(<span class="number">1</span>).trim.toDouble).distinct().stats()</div><div class="line">  println(userIDStats)</div><div class="line">  println(itemIDStats)</div><div class="line">  <span class="keyword">val</span> moviesAndName = buildMovies(rawHotMoviesData)</div><div class="line">  <span class="keyword">val</span> (movieID, movieName) = moviesAndName.head</div><div class="line">  println(movieID + <span class="string">" -&gt; "</span> + movieName)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第<strong>5</strong>行和第<strong>6</strong>行打印RDD的statCounter的值，主要是最大值，最小值等。<br>第<strong>9</strong>行输出热门电影的第一个值。<br>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="built_in">count</span>: <span class="number">223239</span>, mean: <span class="number">111620.188663</span>, stdev: <span class="number">64445.607152</span>, <span class="built_in">max</span>: <span class="number">223966.000000</span>, <span class="built_in">min</span>: <span class="number">0.000000</span>)</div><div class="line">(<span class="built_in">count</span>: <span class="number">165</span>, mean: <span class="number">20734733.139394</span>, stdev: <span class="number">8241677.225813</span>, <span class="built_in">max</span>: <span class="number">26599083.000000</span>, <span class="built_in">min</span>: <span class="number">1866473.000000</span>)</div><div class="line"><span class="number">6866928</span> -&gt; 进击的巨人真人版：前篇</div></pre></td></tr></table></figure>

<p>方法<code>buildMovies</code>读取<code>rawHotMoviesData</code>，因为<code>rawHotMoviesData</code>的每一行是一条类似<code>20645098,8.2,小王子</code>的字符串，需要按照,分割，得到第一个值和第三个值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> buildMovies(rawHotMoviesData: RDD[String]): Map[Int, String] =</div><div class="line">  rawHotMoviesData.flatMap { line =&gt;</div><div class="line">    <span class="keyword">val</span> tokens = line.split(',')</div><div class="line">    <span class="keyword">if</span> (tokens(<span class="number">0</span>).isEmpty) {</div><div class="line">      None</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      Some((tokens(<span class="number">0</span>).toInt, tokens(<span class="number">2</span>)))</div><div class="line">    }</div><div class="line">  }.collectAsMap()</div></pre></td></tr></table></figure>

<p>我们使用这个Map可以根据电影的ID得到电影实际的名字。</p>
<p>下面就重点看看如何使用算法建立模型的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> model(sc: SparkContext,</div><div class="line">            rawUserMoviesData: RDD[String],</div><div class="line">            rawHotMoviesData: RDD[String]): Unit = {</div><div class="line">    <span class="keyword">val</span> moviesAndName = buildMovies(rawHotMoviesData)</div><div class="line">    <span class="keyword">val</span> bMoviesAndName = sc.broadcast(moviesAndName)</div><div class="line">    <span class="keyword">val</span> data = buildRatings(rawUserMoviesData)</div><div class="line">    <span class="keyword">val</span> userIdToInt: RDD[(String, Long)] =</div><div class="line">      data.map(_.userID).distinct().zipWithUniqueId()</div><div class="line">    <span class="keyword">val</span> reverseUserIDMapping: RDD[(Long, String)] =</div><div class="line">      userIdToInt map { <span class="keyword">case</span> (l, r) =&gt; (r, l) }</div><div class="line">    <span class="keyword">val</span> userIDMap: Map[String, Int] =   userIdToInt.collectAsMap().map { <span class="keyword">case</span> (n, l) =&gt; (n, l.toInt) }</div><div class="line">    <span class="keyword">val</span> bUserIDMap = sc.broadcast(userIDMap)</div><div class="line">    <span class="keyword">val</span> ratings: RDD[Rating] = data.map { r =&gt; Rating(bUserIDMap.value.get(r.userID).get, r.movieID, r.rating)}.cache()</div><div class="line">    <span class="comment">//使用协同过滤算法建模</span></div><div class="line">    <span class="comment">//val model = ALS.trainImplicit(ratings, 10, 10, 0.01, 1.0)</span></div><div class="line">    <span class="keyword">val</span> model = ALS.train(ratings, <span class="number">50</span>, <span class="number">10</span>, <span class="number">0.0001</span>)</div><div class="line">    ratings.unpersist()</div><div class="line">    println(<span class="string">"输出第一个userFeature"</span>)</div><div class="line">    println(model.userFeatures.mapValues(_.mkString(<span class="string">", "</span>)).first())</div><div class="line">    <span class="keyword">for</span> (userID &lt;- Array(<span class="number">100</span>,<span class="number">1001</span>,<span class="number">10001</span>,<span class="number">100001</span>,<span class="number">110000</span>)) {</div><div class="line">      checkRecommenderResult(userID, rawUserMoviesData, bMoviesAndName, reverseUserIDMapping, model)</div><div class="line">    }</div><div class="line">    unpersist(model)</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>第<strong>4</strong>行到第<strong>12</strong>行是准备辅助数据，第<strong>13</strong>行准备好ALS算法所需的数据RDD[Rating]。<br>第<strong>16</strong>行设置一些参数训练数据。这些参数可以根据下一节的评估算法挑选一个较好的参数集合作为最终的模型参数。<br>第<strong>21</strong>行是挑选几个用户，查看这些用户看过的电影，以及这个模型推荐给他们的电影。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> checkRecommenderResult(userID: Int, rawUserMoviesData: RDD[String], bMoviesAndName: Broadcast[Map[Int, String]], reverseUserIDMapping: RDD[(Long, String)], model: MatrixFactorizationModel): Unit = {</div><div class="line">    <span class="keyword">val</span> userName = reverseUserIDMapping.lookup(userID).head</div><div class="line">    <span class="keyword">val</span> recommendations = model.recommendProducts(userID, <span class="number">5</span>)</div><div class="line">    <span class="comment">//给此用户的推荐的电影ID集合</span></div><div class="line">    <span class="keyword">val</span> recommendedMovieIDs = recommendations.map(_.product).toSet</div><div class="line">    <span class="comment">//得到用户点播的电影ID集合</span></div><div class="line">    <span class="keyword">val</span> rawMoviesForUser = rawUserMoviesData.map(_.split(',')).</div><div class="line">      filter { <span class="keyword">case</span> Array(user, _, _) =&gt; user.trim == userName }</div><div class="line">    <span class="keyword">val</span> existingUserMovieIDs = rawMoviesForUser.map { <span class="keyword">case</span> Array(_, movieID, _) =&gt; movieID.toInt }.</div><div class="line">      collect().toSet</div><div class="line">    println(<span class="string">"用户"</span> + userName + <span class="string">"点播过的电影名"</span>)</div><div class="line">    <span class="comment">//点播的电影名</span></div><div class="line">    bMoviesAndName.value.filter { <span class="keyword">case</span> (id, name) =&gt; existingUserMovieIDs.contains(id) }.values.foreach(println)</div><div class="line">    println(<span class="string">"推荐给用户"</span> + userName + <span class="string">"的电影名"</span>)</div><div class="line">    <span class="comment">//推荐的电影名</span></div><div class="line">    bMoviesAndName.value.filter { <span class="keyword">case</span> (id, name) =&gt; recommendedMovieIDs.contains(id) }.values.foreach(println)</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>比如用户<strong>yimiao</strong>曾经点评过以下的电影：<br><a rel="article0" href="http://movie.douban.com/subject/25858759/" title="" target="_blank"><img src="25858759.jpg" style="display:inline;margin-right:20px;" alt=""></a><a rel="article0" href="http://movie.douban.com/subject/25858785/" title="" target="_blank"><img src="25858785.jpg" style="display:inline;" alt=""></a></p>
<p>然后这个模型为他推荐<br><a rel="article0" href="http://movie.douban.com/subject/25856265/" title="" target="_blank"><img src="25856265.jpg" style="display:inline;margin-right:20px;" alt=""></a><a rel="article0" href="http://movie.douban.com/subject/24405378/" title="" target="_blank"><img src="24405378.jpg" style="display:inline;margin-right:20px;" alt=""></a><a rel="article0" href="http://movie.douban.com/subject/2303845/" title="" target="_blank"><img src="2303845.jpg" style="display:inline;margin-right:20px;" alt=""></a><a rel="article0" href="http://movie.douban.com/subject/26599083/" title="" target="_blank"><img src="26599083.jpg" style="display:inline;margin-right:20px;" alt=""></a><a rel="article0" href="http://movie.douban.com/subject/26538787/" title="" target="_blank"><img src="26538787.jpg" style="display:inline;margin-right:20px;" alt=""></a><br>基本都属于喜剧动作，爱情类的，看起来还不错。</p>
<h3 id="评价">评价</h3>
<p>当然，我们不能凭着自己的感觉评价模型的好坏，尽管我们直觉告诉我们，这个结果看不错。我们需要量化的指标来评价模型的优劣。<br>我们可以通过计算均方差（Mean Squared Error, MSE）来衡量模型的好坏。数理统计中均方误差是指参数估计值与参数真值之差平方的期望值，记为MSE。MSE是衡量“平均误差”的一种较方便的方法，MSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。<br>我们可以调整rank，numIterations，lambda，alpha这些参数，不断优化结果，使均方差变小。比如：iterations越多，lambda较小，均方差会较小，推荐结果较优。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> evaluate( sc: SparkContext,</div><div class="line">                rawUserMoviesData: RDD[String],</div><div class="line">                rawHotMoviesData: RDD[String]): Unit = {</div><div class="line">    <span class="keyword">val</span> moviesAndName = buildMovies(rawHotMoviesData)</div><div class="line">    <span class="keyword">val</span> bMoviesAndName = sc.broadcast(moviesAndName)</div><div class="line">    <span class="keyword">val</span> data = buildRatings(rawUserMoviesData)</div><div class="line">    <span class="keyword">val</span> userIdToInt: RDD[(String, Long)] =</div><div class="line">      data.map(_.userID).distinct().zipWithUniqueId()</div><div class="line">    <span class="keyword">val</span> userIDMap: Map[String, Int] =</div><div class="line">      userIdToInt.collectAsMap().map { <span class="keyword">case</span> (n, l) =&gt; (n, l.toInt) }</div><div class="line">    <span class="keyword">val</span> bUserIDMap = sc.broadcast(userIDMap)</div><div class="line">    <span class="keyword">val</span> ratings: RDD[Rating] = data.map { r =&gt;</div><div class="line">      Rating(bUserIDMap.value.get(r.userID).get, r.movieID, r.rating)</div><div class="line">    }.cache()</div><div class="line">	<span class="keyword">val</span> numIterations = <span class="number">10</span></div><div class="line">    <span class="keyword">for</span> (rank   &lt;- Array(<span class="number">10</span>,  <span class="number">50</span>);</div><div class="line">         lambda &lt;- Array(<span class="number">1.0</span>, <span class="number">0.01</span>,<span class="number">0.0001</span>)) {</div><div class="line">      <span class="keyword">val</span> model = ALS.train(ratings, rank, numIterations, lambda)</div><div class="line">      <span class="comment">// Evaluate the model on rating data</span></div><div class="line">      <span class="keyword">val</span> usersMovies = ratings.map { <span class="keyword">case</span> Rating(user, movie, rate) =&gt;</div><div class="line">        (user, movie)</div><div class="line">      }</div><div class="line">      <span class="keyword">val</span> predictions =</div><div class="line">        model.predict(usersMovies).map { <span class="keyword">case</span> Rating(user, movie, rate) =&gt;</div><div class="line">          ((user, movie), rate)</div><div class="line">        }</div><div class="line">      <span class="keyword">val</span> ratesAndPreds = ratings.map { <span class="keyword">case</span> Rating(user, movie, rate) =&gt;</div><div class="line">        ((user, movie), rate)</div><div class="line">      }.join(predictions)</div><div class="line">      <span class="keyword">val</span> MSE = ratesAndPreds.map { <span class="keyword">case</span> ((user, movie), (r1, r2)) =&gt;</div><div class="line">        <span class="keyword">val</span> err = (r1 - r2)</div><div class="line">        err * err</div><div class="line">      }.mean()</div><div class="line">      println(s<span class="string">"(rank:$rank, lambda: $lambda, Explicit ) Mean Squared Error = "</span> + MSE)</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> (rank   &lt;- Array(<span class="number">10</span>,  <span class="number">50</span>);</div><div class="line">         lambda &lt;- Array(<span class="number">1.0</span>, <span class="number">0.01</span>,<span class="number">0.0001</span>);</div><div class="line">         alpha  &lt;- Array(<span class="number">1.0</span>, <span class="number">40.0</span>)) {</div><div class="line">      <span class="keyword">val</span> model = ALS.trainImplicit(ratings, rank, numIterations, lambda, alpha)</div><div class="line">      <span class="comment">// Evaluate the model on rating data</span></div><div class="line">      <span class="keyword">val</span> usersMovies = ratings.map { <span class="keyword">case</span> Rating(user, movie, rate) =&gt;</div><div class="line">        (user, movie)</div><div class="line">      }</div><div class="line">      <span class="keyword">val</span> predictions =</div><div class="line">        model.predict(usersMovies).map { <span class="keyword">case</span> Rating(user, movie, rate) =&gt;</div><div class="line">          ((user, movie), rate)</div><div class="line">        }</div><div class="line">      <span class="keyword">val</span> ratesAndPreds = ratings.map { <span class="keyword">case</span> Rating(user, movie, rate) =&gt;</div><div class="line">        ((user, movie), rate)</div><div class="line">      }.join(predictions)</div><div class="line">      <span class="keyword">val</span> MSE = ratesAndPreds.map { <span class="keyword">case</span> ((user, movie), (r1, r2)) =&gt;</div><div class="line">        <span class="keyword">val</span> err = (r1 - r2)</div><div class="line">        err * err</div><div class="line">      }.mean()</div><div class="line">      println(s<span class="string">"(rank:$rank, lambda: $lambda,alpha:$alpha ,implicit  ) Mean Squared Error = "</span> + MSE)</div><div class="line">    }</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>第<strong>16</strong>行到第<strong>35</strong>行评估显性反馈的参数的结果，第<strong>36</strong>行到第<strong>56</strong>行评估隐性反馈的参数的结果。<br>评估的结果如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">1.0</span>, Explicit ) Mean Squared Error = <span class="number">1.5592024394027315</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">0.01</span>, Explicit ) Mean Squared Error = <span class="number">0.1597401855959523</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">1.0E-4</span>, Explicit ) Mean Squared Error = <span class="number">0.12000266211936791</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">1.0</span>, Explicit ) Mean Squared Error = <span class="number">1.559198310777233</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">0.01</span>, Explicit ) Mean Squared Error = <span class="number">0.015537276558121003</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">1.0E-4</span>, Explicit ) Mean Squared Error = <span class="number">0.0029577581713741545</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">1.0</span>,alpha:<span class="number">1.0</span> ,implicit  ) Mean Squared Error = <span class="number">10.352420717999916</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">1.0</span>,alpha:<span class="number">40.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.37758192206552</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">0.01</span>,alpha:<span class="number">1.0</span> ,implicit  ) Mean Squared Error = <span class="number">9.138333638388543</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">0.01</span>,alpha:<span class="number">40.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.288950103420938</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">1.0E-4</span>,alpha:<span class="number">1.0</span> ,implicit  ) Mean Squared Error = <span class="number">9.090678049662575</span>                                                                                </div><div class="line">(rank:<span class="number">10</span>, lambda: <span class="number">1.0E-4</span>,alpha:<span class="number">40.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.20726197573743</span>                                                                               </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">1.0</span>,alpha:<span class="number">1.0</span> ,implicit  ) Mean Squared Error = <span class="number">9.920570381082038</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">1.0</span>,alpha:<span class="number">40.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.202627234339378</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">0.01</span>,alpha:<span class="number">1.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.756830091892575</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">0.01</span>,alpha:<span class="number">40.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.054065456899226</span>                                                               </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">1.0E-4</span>,alpha:<span class="number">1.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.599617817478698</span>                                                                                </div><div class="line">(rank:<span class="number">50</span>, lambda: <span class="number">1.0E-4</span>,alpha:<span class="number">40.0</span> ,implicit  ) Mean Squared Error = <span class="number">7.0397787030727645</span></div></pre></td></tr></table></figure>

<p>可以看到rank为50, lambda为0.0001的显性反馈时的MSE最小。我们就已这组参数作为我们的推荐模型。</p>
<h3 id="模型应用">模型应用</h3>
<p>既然我们已经得到了一个很好的推荐模型，下一步就是使用它为所有的用户生成推荐集合。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> recommend(sc: SparkContext,</div><div class="line">                rawUserMoviesData: RDD[String],</div><div class="line">                rawHotMoviesData: RDD[String],</div><div class="line">                base:String): Unit = {</div><div class="line">    <span class="keyword">val</span> moviesAndName = buildMovies(rawHotMoviesData)</div><div class="line">    <span class="keyword">val</span> bMoviesAndName = sc.broadcast(moviesAndName)</div><div class="line">    <span class="keyword">val</span> data = buildRatings(rawUserMoviesData)</div><div class="line">    <span class="keyword">val</span> userIdToInt: RDD[(String, Long)] =</div><div class="line">      data.map(_.userID).distinct().zipWithUniqueId()</div><div class="line">    <span class="keyword">val</span> reverseUserIDMapping: RDD[(Long, String)] =</div><div class="line">      userIdToInt map { <span class="keyword">case</span> (l, r) =&gt; (r, l) }</div><div class="line">    <span class="keyword">val</span> userIDMap: Map[String, Int] =</div><div class="line">      userIdToInt.collectAsMap().map { <span class="keyword">case</span> (n, l) =&gt; (n, l.toInt) }</div><div class="line">    <span class="keyword">val</span> bUserIDMap = sc.broadcast(userIDMap)</div><div class="line">    <span class="keyword">val</span> bReverseUserIDMap = sc.broadcast(reverseUserIDMapping.collectAsMap())</div><div class="line">    <span class="keyword">val</span> ratings: RDD[Rating] = data.map { r =&gt;</div><div class="line">      Rating(bUserIDMap.value.get(r.userID).get, r.movieID, r.rating)</div><div class="line">    }.cache()</div><div class="line">    <span class="comment">//使用协同过滤算法建模</span></div><div class="line">    <span class="comment">//val model = ALS.trainImplicit(ratings, 10, 10, 0.01, 1.0)</span></div><div class="line">    <span class="keyword">val</span> model = ALS.train(ratings, <span class="number">50</span>, <span class="number">10</span>, <span class="number">0.0001</span>)</div><div class="line">    ratings.unpersist()</div><div class="line">    <span class="comment">//model.save(sc, base+"model")</span></div><div class="line">    <span class="comment">//val sameModel = MatrixFactorizationModel.load(sc, base + "model")</span></div><div class="line">    <span class="keyword">val</span> allRecommendations = model.recommendProductsForUsers(<span class="number">5</span>) map {</div><div class="line">      <span class="keyword">case</span> (userID, recommendations) =&gt; {</div><div class="line">        <span class="keyword">var</span> recommendationStr = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> (r &lt;- recommendations) {</div><div class="line">          recommendationStr += r.product + <span class="string">":"</span> + bMoviesAndName.value.getOrElse(r.product, <span class="string">""</span>) + <span class="string">","</span></div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (recommendationStr.endsWith(<span class="string">","</span>))</div><div class="line">          recommendationStr = recommendationStr.substring(<span class="number">0</span>,recommendationStr.length-<span class="number">1</span>)</div><div class="line"></div><div class="line">        (bReverseUserIDMap.value.get(userID).get,recommendationStr)</div><div class="line">      }</div><div class="line">    }</div><div class="line">    allRecommendations.saveAsTextFile(base + <span class="string">"result.csv"</span>)</div><div class="line">    unpersist(model)</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>这里将推荐结果写入到文件中，更实际的情况是把它写入到HDFS中，或者将这个RDD写入到关系型数据库中如Mysql, Postgresql,或者NoSQL数据库中，如MongoDB, cassandra等。 这样我们就可以提供接口为指定的用户提供推荐的电影。</p>
<p>查看本例生成的推荐结果，下面是其中的一个片段，第一个字段是用户名，后面是五个推荐的电影(电影ID:电影名字)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="list">(<span class="title">god8knows</span>,25986688:流浪者年代记,26582787:斗地主,24405378:王牌特工：特工学院,22556810:猛龙特囧,25868191:极道大战争)</span></div><div class="line"><span class="list">(<span class="title">60648596</span>,25853129:瑞奇和闪电,26582787:斗地主,3445457:无境之兽,3608742:冲出康普顿,26297388:这时对那时错)</span></div><div class="line"><span class="list">(<span class="title">120501579</span>,25856265:烈日迷踪,3608742:冲出康普顿,26275494:橘色,26297388:这时对那时错,25868191:极道大战争)</span></div><div class="line"><span class="list">(<span class="title">xrzsdan</span>,24405378:王牌特工：特工学院,26599083:妈妈的朋友,10440076:最后的女巫猎人,25868191:极道大战争,25986688:流浪者年代记)</span></div><div class="line"><span class="list">(<span class="title">HoldonBoxer</span>,10604554:躲藏,26297388:这时对那时错,26265099:白河夜船,26275494:橘色,3608742:冲出康普顿)</span></div><div class="line"><span class="list">(<span class="title">46896492</span>,1972724:斯坦福监狱实验,26356488<span class="attribute">:1944</span>,25717176:新宿天鹅,26582787:斗地主,25919385:长寿商会)</span></div><div class="line"><span class="list">(<span class="title">blankscreen</span>,24405378:王牌特工：特工学院,26599083:妈妈的朋友,25955372<span class="attribute">:1980</span>年代的爱情,25853129:瑞奇和闪电,25856265:烈日迷踪)</span></div><div class="line"><span class="list">(<span class="title">linyiqing</span>,3608742:冲出康普顿,25868191:极道大战争,26275494:橘色,25955372<span class="attribute">:1980</span>年代的爱情,26582787:斗地主)</span></div><div class="line"><span class="list">(<span class="title">1477412</span>,25889465:抢劫,25727048:福尔摩斯先生,26252196:卫生间的圣母像,26303865:维多利亚,26276359:酷毙了)</span></div><div class="line"><span class="list">(<span class="title">130875640</span>,24405378:王牌特工：特工学院,25856265:烈日迷踪,25986688:流浪者年代记,25868191:极道大战争,25898213:军犬麦克斯)</span></div><div class="line"><span class="list">(<span class="title">49996306</span>,25919385:长寿商会,26582787:斗地主,26285777:有客到,25830802:对风说爱你,25821461:旅程终点)</span></div><div class="line"><span class="list">(<span class="title">fanshuren</span>,10604554:躲藏,26582787:斗地主,25856265:烈日迷踪,25843352:如此美好,26275494:橘色)</span></div><div class="line"><span class="list">(<span class="title">sweetxyy</span>,26582787:斗地主,25868191:极道大战争,3608742:冲出康普顿,25859495:思悼,22556810:猛龙特囧)</span></div></pre></td></tr></table></figure>

<h3 id="综述">综述</h3>
<p>通过前面的介绍，我们可以了解如何使用Spark MLlib的ALS算法为22万豆瓣用户实现一个可用的推荐系统，如何加载数据集和输出数据结果，以及如何对模型进行有效的评估。<br>你可以使用本文的算法实现其它的推荐系统，如图书，文章，商品等。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="http://shop.oreilly.com/product/0636920035091.do" target="_blank" rel="external">Advanced Analytics with Spark</a></li>
<li><a href="http://yongfeng.me/attach/rs-survey-zhang.pdf" target="_blank" rel="external">http://yongfeng.me/attach/rs-survey-zhang.pdf</a></li>
<li><a href="https://github.com/ceys/jdml/wiki/ALS" target="_blank" rel="external">https://github.com/ceys/jdml/wiki/ALS</a></li>
<li><a href="http://spark.apache.org/docs/latest/mllib-collaborative-filtering.html" target="_blank" rel="external">http://spark.apache.org/docs/latest/mllib-collaborative-filtering.html</a></li>
<li><a href="https://www.codementor.io/spark/tutorial/building-a-recommender-with-apache-spark-python-example-app-part1" target="_blank" rel="external">https://www.codementor.io/spark/tutorial/building-a-recommender-with-apache-spark-python-example-app-part1</a></li>
<li><a href="http://blog.javachen.com/2015/04/17/spark-mllib-collaborative-filtering.html" target="_blank" rel="external">http://blog.javachen.com/2015/04/17/spark-mllib-collaborative-filtering.html</a></li>
<li><a href="http://www.zhihu.com/question/31509438" target="_blank" rel="external">http://www.zhihu.com/question/31509438</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>推荐算法就是利用用户的一些行为，通过一些数学算法，推测出用户可能喜欢的东西。<br>随着电子商务规模的不断扩大，商品数量和种类不断增长，用户对于检索和推荐提出了更高的要求。由于不同用户在兴趣爱好、关注领域、个人经历等方面的不同，以满足不同用户的不同推荐需求为目的、不同人可以获得不同推荐为重要特征的个性化推荐系统应运而生。<br>]]>
    
    </summary>
    
      <category term="spark" scheme="http://colobu.com/tags/spark/"/>
    
      <category term="mllib" scheme="http://colobu.com/tags/mllib/"/>
    
      <category term="recommendation" scheme="http://colobu.com/tags/recommendation/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web框架性能基准测试]]></title>
    <link href="http://colobu.com/2015/11/27/techempower-benchmarks-round11/"/>
    <id>http://colobu.com/2015/11/27/techempower-benchmarks-round11/</id>
    <published>2015-11-27T01:52:52.000Z</published>
    <updated>2015-11-27T02:35:52.312Z</updated>
    <content type="html"><![CDATA[<p>我在以前的文章曾经转发过 Techempower<a href="http://colobu.com/2015/04/21/web-framework-benchmarks/" target="_blank" rel="external">第9轮的Web框架的性能测试</a>, 11月23号Techempower发布了最新的第11轮的测试: <a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Framework Benchmarks Round 11</a>。<br>不过此文章国内无法访问，可能需要翻墙。我将测试结果以图片的方式贴在这里，让我们看看Web框架们又有了什么样的性能提升。<br><a id="more"></a><br><img src="benchmark.png" alt=""><br><img src="benchmark2.png" alt=""></p>
<p>不知道为什么Netty, Vert.x没有出现在测试结果中，看测试代码还在。 Go的版本还是1.2，在下一轮测试中才换到1.5的版本。<br>所有的web框架都可以在它们的 <a href="https://github.com/TechEmpower/FrameworkBenchmarks" target="_blank" rel="external">github</a>上找到，也可以在它们的 <a href="https://www.techempower.com/benchmarks/#section=environment" target="_blank" rel="external">测试环境</a>页面查看测试的机器和web框架。</p>
<p>注意这些框架测试时还有访问数据库的代码。测试工具是 wrk。</p>
<p>我只列出了一些自己比较感兴趣的性能：</p>
<ol>
<li>c++稳坐第一</li>
<li>netty的测试结果未出现，否则应该能排进前5 (netty忠实粉 :))</li>
<li><a href="http://projects.eclipse.org/projects/rt.gemini.web" target="_blank" rel="external">gemini</a>居然排第4,性能如此的好。这个Eclipse的项目应该属于小众的框架。在第九轮的测试中排第11</li>
<li>Go的版本太低(1.2)，否则Go框架的性能应该还有所提升。现在go-raw排第12名。 不错的成绩</li>
<li>undertow和go的性能差不多。按说不应该这么低啊，第九轮测试的时候还排在第二位呢</li>
<li>node.js/python的框架不温不火，排名相对较靠后</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我在以前的文章曾经转发过 Techempower<a href="http://colobu.com/2015/04/21/web-framework-benchmarks/" target="_blank" rel="external">第9轮的Web框架的性能测试</a>, 11月23号Techempower发布了最新的第11轮的测试: <a href="https://www.techempower.com/benchmarks/" target="_blank" rel="external">Framework Benchmarks Round 11</a>。<br>不过此文章国内无法访问，可能需要翻墙。我将测试结果以图片的方式贴在这里，让我们看看Web框架们又有了什么样的性能提升。<br>]]>
    
    </summary>
    
      <category term="高并发编程" scheme="http://colobu.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spymemcached的一个坑]]></title>
    <link href="http://colobu.com/2015/11/24/One-spymemcached-issue-when-one-node-fails/"/>
    <id>http://colobu.com/2015/11/24/One-spymemcached-issue-when-one-node-fails/</id>
    <published>2015-11-24T01:44:12.000Z</published>
    <updated>2015-11-24T03:30:58.504Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/couchbase/spymemcached" target="_blank" rel="external">Spymemcached</a> 是 Memcached 的一个流行的Java client库(另一个比较著名的是原淘宝的 <em>伯岩/庄晓丹</em> 开发的<a href="https://github.com/killme2008/xmemcached" target="_blank" rel="external">XMemcached</a>, 他也开发另一个Taobao开源的项目 <a href="https://github.com/killme2008/Metamorphosis" target="_blank" rel="external">Metamorphosis</a>)，性能表现出色，广泛应用于Java + Memcached 项目中。<br>Spymemcached 最早由 <a href="http://dustin.sallings.org/" target="_blank" rel="external">Dustin Sallings</a> 开发，Dustin 后来和别人一起创办了Couchbase (原NorthScale)，职位为首席架构师。2014加入Google。<br><a id="more"></a><br>本身Memcached没有集群的功能，客户端可以根据不同的key值set/get到不同的Memcached的节点上。 一致性Hash算法可以将数据均衡地分配到各个节点，并且在节点加入和退出的时候可以很好地将失效节点上的数据均衡的分配给其它节点。 Spymemcached使用Ketama算法。</p>
<p>但是，当 memcached 集群的一个节点因为某种原因宕机的时候，spymemcached 并没有正确的选择到另外一个live的节点，而是直接失败：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.942</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108182.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.944</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108254.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.946</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108341.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.947</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108352.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.947</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108381.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.948</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108407.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.950</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108480.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.952</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108552.</span></div><div class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">05</span>:<span class="number">56</span>:<span class="number">20.954</span> WARN net.spy.memcached.MemcachedConnection:  Could <span class="operator">not</span> redistribute <span class="built_in">to</span> another node, retrying primary node <span class="keyword">for</span> ff-<span class="number">108608.</span></div></pre></td></tr></table></figure>

<p>如果使用XMemcached，则没有这种现象。<br>spymemcached已经设置为一致性Hash的模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">      ConnectionFactoryBuilder builder = <span class="keyword">new</span> ConnectionFactoryBuilder();</div><div class="line">      builder.setHashAlg(DefaultHashAlgorithm.KETAMA_HASH);</div><div class="line">      builder.setLocatorType(ConnectionFactoryBuilder.Locator.CONSISTENT);</div><div class="line">      builder.setFailureMode(FailureMode.Redistribute);</div><div class="line">......</div></pre></td></tr></table></figure>

<p>原因在于当key对应的节点(称之为primary node宕机的时候)，spymemcached会有限地选择另外一个节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (primary.isActive() || failureMode == FailureMode.Retry) {</div><div class="line">    placeIn = primary;</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (failureMode == FailureMode.Cancel) {</div><div class="line">    o.cancel();</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    Iterator&lt;MemcachedNode&gt; i = locator.getSequence(key);</div><div class="line">    <span class="keyword">while</span> (placeIn == <span class="keyword">null</span> && i.hasNext()) {</div><div class="line">        MemcachedNode n = i.next();</div><div class="line">        <span class="keyword">if</span> (n.isActive()) {</div><div class="line">            placeIn = n;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (placeIn == <span class="keyword">null</span>) {</div><div class="line">        placeIn = primary;</div><div class="line">        <span class="keyword">this</span>.getLogger().warn(<span class="string">"Could not redistribute to another node, "</span> + <span class="string">"retrying primary node for %s."</span>, key);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>


<p>其中<code>locator.getSequence(key)</code>最多会提供7个备选虚拟节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Iterator&lt;MemcachedNode&gt; <span class="title">getSequence</span>(String k) {</div><div class="line">  <span class="comment">// Seven searches gives us a 1 in 2^7 chance of hitting the</span></div><div class="line">  <span class="comment">// same dead node all of the time.</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> KetamaIterator(k, <span class="number">7</span>, getKetamaNodes(), hashAlg);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，依照他的注释，在宕机的情况下，大约会有1/128的几率这七个虚拟节点都会指向这个宕机的primary node。<br>实际上，下面的代码百分百会选择不到那个live (&quot;127.0.0.1:11211&quot;)的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMissingNode2</span>() {</div><div class="line">    List&lt;MemcachedNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;MemcachedNode&gt;();</div><div class="line">    nodes.add(createMockNode(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">11211</span>)));</div><div class="line">    nodes.add(createMockNode(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">11311</span>)));</div><div class="line">    KetamaNodeLocator locator = <span class="keyword">new</span> KetamaNodeLocator(nodes, DefaultHashAlgorithm.KETAMA_HASH);</div><div class="line">    Iterator&lt;MemcachedNode&gt; i = locator.getSequence(<span class="string">"ff-108552"</span>);</div><div class="line">    Set&lt;MemcachedNode&gt; foundNodes = <span class="keyword">new</span> HashSet&lt;MemcachedNode&gt;();</div><div class="line">    <span class="keyword">while</span> (i.hasNext()) {</div><div class="line">        foundNodes.add(i.next());</div><div class="line">    }</div><div class="line">    <span class="comment">// This fails. 127.0.0.1:11211 is never found.</span></div><div class="line">    <span class="keyword">for</span> (MemcachedNode node: nodes) {</div><div class="line">        Assert.assertTrue(foundNodes.contains(node));</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">private</span>  MemcachedNode <span class="title">createMockNode</span>(InetSocketAddress sock) {</div><div class="line">    MemcachedNode mockNode = EasyMock.createMock(MemcachedNode.class);</div><div class="line">    EasyMock.expect(mockNode.getSocketAddress()).andReturn(sock).anyTimes();</div><div class="line">    EasyMock.replay(mockNode);</div><div class="line">    <span class="keyword">return</span> mockNode;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>事实上，google groups上也有<a href="http://comments.gmane.org/gmane.comp.java.spymemcached/44" target="_blank" rel="external">讨论</a>, 原spymemcached的bug管理系统上也有相关的<a href="https://code.google.com/p/spymemcached/issues/detail?id=278&amp;sort=-id&amp;colspec=stars%20id%20Milestone%20Priority%20Status%20Summary" target="_blank" rel="external">bug</a>，但是问题并没有解决。<br>导致的问题是，某些缓存项在某个memcached节点宕机的时候，不能利用缓存系统，只能从其它持久化系统比如数据库中获取值。</p>
<p>问题找到，解决办法也就有了，修改getSequence方法，提供更多的节点共选择:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Iterator&lt;MemcachedNode&gt; <span class="title">getSequence</span>(String k) {</div><div class="line">    <span class="comment">// return new KetamaIterator(k, 7, getKetamaNodes(), hashAlg);</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> maxTry = config.getNodeRepetitions() + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (maxTry &lt; <span class="number">20</span>) {</div><div class="line">       maxTry = <span class="number">20</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KetamaIterator(k, maxTry, getKetamaNodes(), hashAlg);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外，如何在运行时动态地增加新的memcached节点? 这篇文章给出了一个<a href="http://stackoverflow.com/questions/17448311/how-to-add-memcached-nodes-dynamically-with-spymemcached/18227270#18227270" target="_blank" rel="external">解决方案</a><br>你不得不重载MemcachedClient, MemcachedConnection 和 DefaultConnectionFactory。作者未测试，不保证work。不管怎样，倒是一个思路。<br><strong>ExtMemCachedConnection.java </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtMemCachedConnection</span> <span class="keyword">extends</span> <span class="title">MemcachedConnection</span> </span>{</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> OperationFactory opFact;</div><div class="line">  <span class="javadoc">/**</span></div><div class="line">   * Construct a memcached connection.</div><div class="line">   *</div><div class="line">   *<span class="javadoctag"> @param</span> bufSize the size of the buffer used for reading from the server</div><div class="line">   *<span class="javadoctag"> @param</span> f       the factory that will provide an operation queue</div><div class="line">   *<span class="javadoctag"> @param</span> a       the addresses of the servers to connect to</div><div class="line">   *<span class="javadoctag"> @throws</span> java.io.IOException if a connection attempt fails early</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> <span class="title">ExtendableMemcachedConnection</span>(<span class="keyword">int</span> bufSize, ConnectionFactory f,</div><div class="line">                                       List&lt;InetSocketAddress&gt; a,</div><div class="line">                                       Collection&lt;ConnectionObserver&gt; obs,</div><div class="line">                                       FailureMode fm, OperationFactory opfactory)</div><div class="line">      <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">super</span>(bufSize, f, a, obs, fm, opfactory);</div><div class="line">    <span class="keyword">this</span>.opFact = opfactory;</div><div class="line">  }</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(InetSocketAddress nodeAddress) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">final</span> List&lt;InetSocketAddress&gt; nodeToAdd = <span class="keyword">new</span> ArrayList&lt;InetSocketAddress&gt;(<span class="number">1</span>);</div><div class="line">    nodeToAdd.add(nodeAddress);</div><div class="line">    List&lt;MemcachedNode&gt; newNodesList = createConnections(nodeToAdd);</div><div class="line">    newNodesList.addAll(getLocator().getAll());</div><div class="line">    getLocator().updateLocator(newNodesList);</div><div class="line">  }</div><div class="line">  <span class="comment">//The node should be obtain from locator to ensure currentNode.equals(node) will return true</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(MemcachedNode node) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="keyword">for</span>(MemcachedNode currentNode : getLocator().getAll()) {</div><div class="line">      <span class="keyword">if</span>(currentNode.equals(node)) {</div><div class="line">        Collection&lt;Operation&gt; notCompletedOperations = currentNode.destroyInputQueue();</div><div class="line">        <span class="keyword">if</span> (currentNode.getChannel() != <span class="keyword">null</span>) {</div><div class="line">          currentNode.getChannel().close();</div><div class="line">          currentNode.setSk(<span class="keyword">null</span>);</div><div class="line">          <span class="keyword">if</span> (currentNode.getBytesRemainingToWrite() &gt; <span class="number">0</span>) {</div><div class="line">            getLogger().warn(<span class="string">"Shut down with %d bytes remaining to write"</span>,</div><div class="line">                             currentNode.getBytesRemainingToWrite());</div><div class="line">          }</div><div class="line">          getLogger().debug(<span class="string">"Shut down channel %s"</span>, currentNode.getChannel());</div><div class="line">        }</div><div class="line">        <span class="comment">//Unfortunatelly,  redistributeOperations is private so it cannot be used or override. I put copy/paste the implementation</span></div><div class="line">        redistributeOperations(notCompletedOperations);</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">redistributeOperations</span>(Collection&lt;Operation&gt; ops) {</div><div class="line">    <span class="keyword">for</span> (Operation op : ops) {</div><div class="line">      <span class="keyword">if</span> (op.isCancelled() || op.isTimedOut()) {</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      }</div><div class="line">      <span class="keyword">if</span> (op <span class="keyword">instanceof</span> KeyedOperation) {</div><div class="line">        KeyedOperation ko = (KeyedOperation) op;</div><div class="line">        <span class="keyword">int</span> added = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (String k : ko.getKeys()) {</div><div class="line">          <span class="keyword">for</span> (Operation newop : opFact.clone(ko)) {</div><div class="line">            addOperation(k, newop);</div><div class="line">            added++;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <span class="keyword">assert</span> added &gt; <span class="number">0</span> : <span class="string">"Didn't add any new operations when redistributing"</span>;</div><div class="line">      } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// Cancel things that don't have definite targets.</span></div><div class="line">        op.cancel();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>ExtMemcachedClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(InetSocketAddress nodeAddress) {</div><div class="line">  <span class="keyword">if</span>(mconn <span class="keyword">instanceof</span> ExtMemcachedConnection) {</div><div class="line">    ((ExtMemcachedConnection)mconn).add(nodeAddress);  </div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span>(MemcachedNode node) {</div><div class="line">  <span class="keyword">if</span>(mconn <span class="keyword">instanceof</span> ExtMemcachedConnection) {</div><div class="line">    ((ExtMemcachedConnection)mconn).remove(nodeAddress);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>ExtMemcachedConnectionfactory.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> MemcachedConnection <span class="title">createConnection</span>(List&lt;InetSocketAddress&gt; addrs) <span class="keyword">throws</span> IOException {</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ExtendableMemcachedConnection(getReadBufSize(), <span class="keyword">this</span>, addrs,</div><div class="line">                                           getInitialObservers(), getFailureMode(), getOperationFactory());</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/couchbase/spymemcached" target="_blank" rel="external">Spymemcached</a> 是 Memcached 的一个流行的Java client库(另一个比较著名的是原淘宝的 <em>伯岩/庄晓丹</em> 开发的<a href="https://github.com/killme2008/xmemcached" target="_blank" rel="external">XMemcached</a>, 他也开发另一个Taobao开源的项目 <a href="https://github.com/killme2008/Metamorphosis" target="_blank" rel="external">Metamorphosis</a>)，性能表现出色，广泛应用于Java + Memcached 项目中。<br>Spymemcached 最早由 <a href="http://dustin.sallings.org/" target="_blank" rel="external">Dustin Sallings</a> 开发，Dustin 后来和别人一起创办了Couchbase (原NorthScale)，职位为首席架构师。2014加入Google。<br>]]>
    
    </summary>
    
      <category term="memcached" scheme="http://colobu.com/tags/memcached/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8 简明教程]]></title>
    <link href="http://colobu.com/2015/11/20/java8-tutorial/"/>
    <id>http://colobu.com/2015/11/20/java8-tutorial/</id>
    <published>2015-11-20T07:14:50.000Z</published>
    <updated>2015-11-20T09:07:45.905Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是<a href="http://winterbe.com" target="_blank" rel="external">Benjamin Winterberg</a>写的英文教程<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">Modern Java - A Guide to Java 8</a>,最早发表于2014年三月，当时由 <a href="http://www.importnew.com/" target="_blank" rel="external">ImportNew</a> - <a href="http://www.importnew.com/author/huangxiaofei" target="_blank" rel="external">黄小非</a>翻译成中文: <a href="http://www.importnew.com/10360.html" target="_blank" rel="external">Java 8简明教程</a>。离原文初次发表已经快两年了，作者又陆陆续续提交多个commit，所以我根据原文以及黄小非的译文又做了修正。实际绝大部分的内容和小非翻译的一样，只有些许的变化。</p>
</blockquote>
<p><strong>Java并没有没落，人们开始认识到这一点</strong></p>
<p>欢迎阅读我编写的<a href="https://jdk8.java.net/" target="_blank" rel="external">Java 8</a>介绍。本教程将带领你一步步认识这门语言的所有新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和可重复注解。在这篇教程的最后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。<br><strong>没有大段的废话，只是一些带注释的代码片段，望君喜欢。</strong></p>
<p>本文最早发表在我的<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">博客</a>上。 你可以在Twitter上<a href="https://twitter.com/winterbe_" target="_blank" rel="external">加我</a>。<br><a id="more"></a></p>
<h2 id="接口中的默认方法">接口中的默认方法</h2>
<p>Java 8 允许我们使用default关键字，为接口添加非抽象(non-abstract)的方法实现。这个特性又被称为<a href="http://stackoverflow.com/a/24102730" target="_blank" rel="external">扩展方法</a>。下面是我们的第一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface Formula {</div><div class="line">    <span class="keyword">double</span> calculate(<span class="keyword">int</span> a);</div><div class="line"></div><div class="line">    <span class="keyword">default</span> <span class="keyword">double</span> sqrt(<span class="keyword">int</span> a) {</div><div class="line">        <span class="keyword">return</span> Math.sqrt(a);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在接口<em>Formula</em>中，除了抽象方法<em>caculate</em>以外，还定义了一个默认方法sqrt。Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Formula formula = <span class="keyword">new</span> Formula() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span>(<span class="keyword">int</span> a) {</div><div class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></div><div class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></div></pre></td></tr></table></figure>

<p><em>formula</em>对象以匿名对象的形式实现了Formula接口。代码很啰嗦：用了6行代码才实现了一个简单的计算功能：a*100 开平方根。我们在下一节会看到，Java 8 还有一种更加漂亮的方法，能够实现只包含单个函数的对象。</p>
<h2 id="Lambda表达式">Lambda表达式</h2>
<p>让我们从最简单的例子开始，来学习如何对一个string列表进行排序。我们首先使用Java 8之前的方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</div><div class="line"></div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(String a, String b) {</div><div class="line">        <span class="keyword">return</span> b.compareTo(a);</div><div class="line">    }</div><div class="line">});</div></pre></td></tr></table></figure>

<p>静态工具方法 Collections.sort 接受一个 list，和一个 Comparator 接口作为输入参数来对，Comparator的实现类可以对输入的list中的元素进行比较。通常你会创建一个匿名Comparator对象，并把它作为参数传递给sort方法。</p>
<p>除了一直以来创建匿名对象的方式外，Java 8 还提供了一种更简洁的语法，Lambda表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; {</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>如你所见，这段代码比之前的更加简短和易读。但是，它还可以更加简短：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>

<p>只要一行代码，包含了方法体。你甚至可以连大括号对{}和return关键字都省略不要。不过这还不是最短的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">names.sort((a, b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>

<p>List现在有了一个 sort方法。Java编译器能够自动识别参数的类型，所以你就可以省略掉类型不写。让我们再深入地研究一下lambda表达式的威力吧。</p>
<h2 id="函数式接口">函数式接口</h2>
<p>Lambda表达式如何匹配Java的类型系统？每一个lambda都能够通过一个特定的接口，与一个给定的类型进行匹配。一个所谓的函数式接口必须要<strong>有且仅有一个抽象方法声明</strong>。每个与之对应的lambda表达式必须要与这个抽象方法的声明相匹配。由于默认方法不是抽象的，因此你可以在你的函数式接口里任意添加默认方法。<br>只包含一个抽象方法的任意接口，我们都可以用来当作lambda表达式的类型。为了让你定义的接口满足要求，你应当在接口前加上<code>@FunctionalInterface</code>注解。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。<br>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line">interface Converter&lt;F, T&gt; {</div><div class="line">    T convert(F from);</div><div class="line">}</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// 123</span></div></pre></td></tr></table></figure>

<p>注意，如果你不写<code>@FunctionalInterface</code> 注解，程序也是正确的。</p>
<h2 id="方法和构造函数引用">方法和构造函数引用</h2>
<p>上面的代码实例可以通过静态方法引用，使之更加简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);   <span class="comment">// 123</span></div></pre></td></tr></table></figure>

<p>Java 8 允许你通过::关键字获取方法或者构造函数的的引用。上面的例子就演示了如何引用一个静态方法。而且，我们还可以对一个对象的方法进行引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Something {</div><div class="line">    String startsWith(String s) {</div><div class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Something something = <span class="keyword">new</span> Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// "J"</span></div></pre></td></tr></table></figure>

<p>让我们看看如何使用::关键字引用构造函数。首先我们定义一个包含不同的构造方法示例bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person {</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() {}</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) {</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来，我们定义一个person工厂接口，用来创建新的person对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface PersonFactory&lt;P extends Person&gt; {</div><div class="line">    P create(String firstName, String lastName);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后我们通过构造函数引用来把所有东西拼到一起，而不是像以前一样，通过手动实现一个工厂来这么做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</div></pre></td></tr></table></figure>

<p>我们通过Person::new来创建一个<code>Person</code>类构造函数的引用。Java编译器会自动地选择合适的构造函数来匹配<code>PersonFactory.create</code>函数的签名，并选择正确的构造函数形式。</p>
<h2 id="Lambda的域_(scope)">Lambda的域 (scope)</h2>
<p>访问lambdab表达式外部的变量类似匿名对象。你能够访问局部外部域(local outer scope)的final变量，以及成员变量和静态变量。</p>
<h3 id="访问局部变量">访问局部变量</h3>
<p>我们可以访问lambda表达式外部的final局部变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p>但是与匿名对象不同的是，变量num并不需要一定是final。下面的代码依然是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p>然而， 变量num 必须隐式地编译成为final类型。下面的代码无法编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = <span class="number">3</span>;</div></pre></td></tr></table></figure>

<p>在Lambda表达式中也禁止对局部变量 <code>num</code>的写。</p>
<h3 id="访问成员变量和静态变量">访问成员变量和静态变量</h3>
<p>与局部变量不同，我们在lambda表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Lambda4 {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</div><div class="line">    <span class="keyword">int</span> outerNum;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> testScopes() {</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {</div><div class="line">            outerNum = <span class="number">23</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        };</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {</div><div class="line">            outerStaticNum = <span class="number">72</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        };</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="访问默认接口方法">访问默认接口方法</h3>
<p>还记得第一节里面formula的那个例子么？ 接口Formula定义了一个默认的方法sqrt，该方法能够被formula所有的实例以及匿名对象所访问。这个对lambda表达式来讲则无效。</p>
<p>默认方法无法在lambda表达式内部被访问。因此下面的代码是无法通过编译的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</div></pre></td></tr></table></figure>

<h2 id="内置函数式接口">内置函数式接口</h2>
<p>JDK 1.8 API中包含了很多内置的函数式接口。有些是在以前版本的Java中大家耳熟能详的，例如<code>Comparator</code>接口，或者<code>Runnable</code>接口。Java8 对这些现成的接口进行了扩展，加上了@FunctionalInterface 注解来标识。</p>
<p>Java 8 API 还提供了很多新的函数式接口，使你的生活更美好。有些新的接口已经在<a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">Google Guava 库</a>中很有名了。如果你对这些库很熟的话，你甚至闭上眼睛都能够想到，这些接口在类库的实现过程中起了多么大的作用。</p>
<h3 id="Predicate">Predicate</h3>
<p>Predicate是一个布尔类型的函数，该函数只有一个输入参数。Predicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>

<h3 id="Function">Function</h3>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起（compse, andThen）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></div></pre></td></tr></table></figure>

<h3 id="Supplier">Supplier</h3>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure>

<h3 id="Consumer">Consumer</h3>
<p>Consumer代表了在单一的输入参数上需要进行的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</div><div class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</div></pre></td></tr></table></figure>

<h3 id="Comparator">Comparator</h3>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></div><div class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></div></pre></td></tr></table></figure>

<h2 id="Optional">Optional</h2>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerEception产生。这个概念在下一节会显得很重要，所以我们在这里快速地浏览一下Optional是如何使用的。</p>
<p>Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</div><div class="line"></div><div class="line">optional.isPresent();           <span class="comment">// true</span></div><div class="line">optional.get();                 <span class="comment">// "bam"</span></div><div class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></div></pre></td></tr></table></figure>

<h2 id="Stream">Stream</h2>
<p><code>java.util.Stream</code>表示了某种元素的序列，在这些元素上可以进行各种操作。Stream操作可以是中间操作(intermediate )，也可以是完结操作(terminal)。完结操作会返回一个某种类型的值，而中间操作会返回流对象本身，并且你可以通过多次调用同一个流操作方法来将操作结果串起来。Stream是在一个源(source)上创建出来的，例如<code>java.util.Collection</code>中的<code>list</code>或者<code>set</code>（map不能作为Stream的源）。Stream操作既可以并行也可以串行。</p>
<blockquote>
<p>你也应该看看 <a href="https://github.com/winterbe/streamjs" target="_blank" rel="external">Stream.js</a>, Java 8 Streams API的 Javascript移植.</p>
</blockquote>
<p>我们先了解一下串行流。首先，我们创建string类型的list的源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(<span class="string">"ddd2"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa2"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb1"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa1"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb3"</span>);</div><div class="line">stringCollection.add(<span class="string">"ccc"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb2"</span>);</div><div class="line">stringCollection.add(<span class="string">"ddd1"</span>);</div></pre></td></tr></table></figure>

<p>Java 8中的Collections类的功能已经有所增强，你可以之直接通过调用<code>Collections.stream()</code>或者<code>Collection.parallelStream()</code>方法来创建一个流对象。下面的章节会解释这个最常用的操作。</p>
<h3 id="Filter">Filter</h3>
<p>Filter接受一个predicate接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基础上再进行其他的流操作（<code>forEach</code>）。ForEach接受一个consumer，用来执行对每一个元素的操作。ForEach是一个中止操作。它返回<code>void</code>，所以我们不能再调用其他的流操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa2", "aaa1"</span></div></pre></td></tr></table></figure>

<h3 id="Sorted">Sorted</h3>
<p>Sorted是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个Comparator接口来改变排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa1", "aaa2"</span></div></pre></td></tr></table></figure>

<p>一定要记住，<code>sorted</code>只是创建一个流对象排序的视图，而不会改变原来集合中元素的顺序。原来string集合中的元素顺序是没有改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(stringCollection);</div><div class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></div></pre></td></tr></table></figure>

<h3 id="Map">Map</h3>
<p>map是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素映射到另外一个对象上。下面的例子就演示了如何把每个string都转换成大写的string. 不但如此，你还可以把每一种对象映射成为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给map的泛型方法来决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></div></pre></td></tr></table></figure>

<h3 id="Match">Match</h3>
<p>匹配操作有多种不同的类型，都是用来判断某个predicate 是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个boolean类型的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      <span class="comment">// tr</span></div></pre></td></tr></table></figure>

<h3 id="Count">Count</h3>
<p>Count是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<h3 id="Reduce">Reduce</h3>
<p>该操作是一个终结操作，它能够通过某一个方法，对元素进行 reduction 操作。该操作的结果会放在一个Optional变量里返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></div></pre></td></tr></table></figure>

<h2 id="并行流">并行流</h2>
<p>像上面所说的，流操作可以是串行的，也可以是并行的。串行操作通过单线程执行，而并行操作则通过多线程执行。<br>下面的例子就演示了如何使用并行流进行操作来提高运行效率，代码非常简单。<br>首先我们创建一个大的list，里面的元素都是唯一的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</div><div class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) {</div><div class="line">    UUID uuid = UUID.randomUUID();</div><div class="line">    values.add(uuid.toString());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，我们测量一下对这个集合进行排序所使用的时间。</p>
<h3 id="串行排序">串行排序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// sequential sort took: 899 ms</span></div></pre></td></tr></table></figure>

<h3 id="并行排序">并行排序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// parallel sort took: 472 ms</span></div></pre></td></tr></table></figure>

<p>如你所见，所有的代码段几乎都相同，唯一的不同就是把<code>stream()</code>改成了<code>parallelStream()</code>, 结果并行排序快了50%。</p>
<h2 id="Map-1">Map</h2>
<p>正如前面已经提到的那样，map是不支持流操作的, map类没有stream()方法。但是你可以在key, value, entry上产生特定流， 比如下列方法 <code>map.keySet().stream()</code>, <code>map.values().stream()</code> 和 <code>map.entrySet().stream()</code>。</p>
<p>而更新后的map现在则支持多种实用的新方法，来完成常规的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</div><div class="line">}</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure>

<p>上面的代码风格是完全自解释的：<code>putIfAbsent</code> 避免我们将<code>null</code>写入；<code>forEach</code>接受一个consumer，从而将操作实施到每一个map中的值上。</p>
<p>下面的这个例子展示了如何使用函数在map执行计算操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</div><div class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</div><div class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div></pre></td></tr></table></figure>

<p>接下来，我们将学习，当给定一个key值时，如何把一个实例从对应的key中移除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></div></pre></td></tr></table></figure>

<p>另一个有用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></div></pre></td></tr></table></figure>

<p>将map中的实例合并也是非常容易的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></div><div class="line"></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></div></pre></td></tr></table></figure>

<p>合并操作先看map中是否没有特定的key/value存在，如果是，则把key/value存入map，否则merging函数就会被调用，对现有的数值进行修改。</p>
<h2 id="时间日期API">时间日期API</h2>
<p>Java 8 包含了全新的时间日期API，这些功能都放在了<code>java.time</code>包下。新的时间日期API是参考<a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda-Time</a>库开发的，但是也<a href="http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html" target="_blank" rel="external">不尽相同</a>。下面的例子就涵盖了大多数新的API的重要部分。</p>
<h3 id="Clock">Clock</h3>
<p>Clock提供了对当前时间和日期的访问功能。Clock是对当前时区敏感的，并可用于替代<code>System.currentTimeMillis()</code>方法来获取当前的毫秒时间。当前时间线上的时刻可以用<code>Instance</code>类来表示。Instance也能够用于创建原先的<code>java.util.Date</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line"><span class="keyword">long</span> millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></div></pre></td></tr></table></figure>

<h3 id="Timezone">Timezone</h3>
<p>时区类可以用一个<code>ZoneId</code>来表示。时区类的对象可以通过静态工厂方法方便地获取。时区类还定义了一个偏移量，用来在当前时刻或某时间与目标时区时间之间进行转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line"><span class="comment">// prints all available timezone ids</span></div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</div><div class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></div></pre></td></tr></table></figure>

<h3 id="LocalTime">LocalTime</h3>
<p>本地时间类表示一个没有指定时区的时间，例如，10 p.m.或者17：30:15，下面的例子会用上面的例子定义的时区创建两个本地时间对象。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></div><div class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></div></pre></td></tr></table></figure>

<p>LocalTime是由多个工厂方法组成，其目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</div><div class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></div></pre></td></tr></table></figure>

<h3 id="LocalDate">LocalDate</h3>
<p>本地时间表示了一个独一无二的时间，例如：2014-03-11。这个时间是不可变的，与LocalTime是同源的。下面的例子演示了如何通过加减日，月，年等指标来计算新的日期。记住，每一次操作都会返回一个新的时间对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></div></pre></td></tr></table></figure>

<p>解析字符串并形成LocalDate对象，这个操作和解析LocalTime一样简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</div><div class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></div></pre></td></tr></table></figure>

<h3 id="LocalDateTime">LocalDateTime</h3>
<p>LocalDateTime表示的是日期-时间。它将刚才介绍的日期对象和时间对象结合起来，形成了一个对象实例。<code>LocalDateTime</code>是不可变的，与LocalTime和LocalDate的工作原理相同。我们可以通过调用方法来获取日期时间对象中特定的数据域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></div></pre></td></tr></table></figure>

<p>如果再加上的时区信息，LocalDateTime能够被转换成Instance实例。Instance能够被转换成以前的java.util.Date对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></div></pre></td></tr></table></figure>

<p>格式化日期-时间对象就和格式化日期对象或者时间对象一样。除了使用预定义的格式以外，我们还可以创建自定义的格式化对象，然后匹配我们自定义的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></div></pre></td></tr></table></figure>

<p>不同于<code>java.text.NumberFormat</code>，新的<code>DateTimeFormatter</code>类是不可变的，也是<strong>线程安全</strong>的。</p>
<p>更多的细节，请看<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">这里</a></p>
<h2 id="Annotation">Annotation</h2>
<p>Java 8中的注解是可重复的。让我们直接深入看看例子，弄明白它是什么意思。<br>首先，我们定义一个包装注解，它包括了一个实际注解的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@interface</span> Hints {</div><div class="line">    Hint[] value();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@Repeatable</span>(Hints.class)</div><div class="line"><span class="annotation">@interface</span> Hint {</div><div class="line">    String value();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>只要在前面加上注解名：<code>@Repeatable</code>，Java 8 允许我们对同一类型使用多重注解，</p>
<h3 id="变体1：使用注解容器（老方法）">变体1：使用注解容器（老方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Hints</span>({<span class="annotation">@Hint</span>(<span class="string">"hint1"</span>), <span class="annotation">@Hint</span>(<span class="string">"hint2"</span>)})</div><div class="line">class Person {}</div></pre></td></tr></table></figure>

<h3 id="变体2：使用可重复注解（新方法）">变体2：使用可重复注解（新方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Hint</span>(<span class="string">"hint1"</span>)</div><div class="line"><span class="annotation">@Hint</span>(<span class="string">"hint2"</span>)</div><div class="line">class Person {}</div></pre></td></tr></table></figure>

<p>使用变体2，Java编译器能够在内部自动对@Hint进行设置。这对于通过反射来读取注解信息来说，是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hint hint = Person.class.getAnnotation(Hint.class);</div><div class="line">System.out.println(hint);                   <span class="comment">// null</span></div><div class="line"></div><div class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</div><div class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></div><div class="line"></div><div class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</div><div class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></div></pre></td></tr></table></figure>

<p>尽管我们绝对不会在<code>Person</code>类上声明<code>@Hints</code>注解，但是它的信息仍然可以通过<code>getAnnotation(Hints.class)</code>来读取。并且，g<code>etAnnotationsByType</code>方法会更方便，因为它赋予了所有<code>@Hints</code>注解标注的方法直接的访问权限。</p>
<p>此外， Java 8中的注解可以扩展到两个新的类型上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Target</span>({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})</div><div class="line"><span class="annotation">@interface</span> MyAnnotation {}</div></pre></td></tr></table></figure>

<h2 id="更多资源">更多资源</h2>
<p>我的Java 8编程指南就到此告一段落。如果你想了解JDK 8 API 所有的新增加的类和特性，可以查看我的<a href="http://winterbe.com/projects/java8-explorer/" target="_blank" rel="external">JDK8 API Explorer</a>, 它可以帮助你了解JDK 8的新增加的类和隐藏的精华。例如：<code>Arrays.parallelSort</code>, <code>StampedLock</code>和<code>CompletableFuture</code>等等 ———— 我这里只是举几个例子而已。</p>
<p>我也在博客上写了一些文章，你可能会感兴趣:</p>
<ul><li><a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="external">Java 8 Stream Tutorial</a></li><li><a href="http://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/" target="_blank" rel="external">Java 8 Nashorn Tutorial</a></li><li><a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="external">Java 8 Concurrency Tutorial: Threads and Executors</a></li><li><a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/" target="_blank" rel="external">Java 8 Concurrency Tutorial: Synchronization and Locks</a></li><li><a href="http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/" target="_blank" rel="external">Java 8 Concurrency Tutorial: Atomic Variables and ConcurrentMap</a></li><li><a href="http://winterbe.com/posts/2015/03/25/java8-examples-string-number-math-files/" target="_blank" rel="external">Java 8 API by Example: Strings, Numbers, Math and Files</a></li><li><a href="http://winterbe.com/posts/2015/03/15/avoid-null-checks-in-java/" target="_blank" rel="external">Avoid Null Checks in Java 8</a></li><li><a href="http://winterbe.com/posts/2015/03/05/fixing-java-8-stream-gotchas-with-intellij-idea/" target="_blank" rel="external">Fixing Java 8 Stream Gotchas with IntelliJ IDEA</a></li><li><a href="http://winterbe.com/posts/2014/04/07/using-backbonejs-with-nashorn/" target="_blank" rel="external">Using Backbone.js with Java 8 Nashorn</a></li></ul>

<p>你可以在Twitter上关注<a href="https://twitter.com/winterbe_" target="_blank" rel="external">我</a>。 感谢阅读。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是<a href="http://winterbe.com" target="_blank" rel="external">Benjamin Winterberg</a>写的英文教程<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">Modern Java - A Guide to Java 8</a>,最早发表于2014年三月，当时由 <a href="http://www.importnew.com/" target="_blank" rel="external">ImportNew</a> - <a href="http://www.importnew.com/author/huangxiaofei" target="_blank" rel="external">黄小非</a>翻译成中文: <a href="http://www.importnew.com/10360.html" target="_blank" rel="external">Java 8简明教程</a>。离原文初次发表已经快两年了，作者又陆陆续续提交多个commit，所以我根据原文以及黄小非的译文又做了修正。实际绝大部分的内容和小非翻译的一样，只有些许的变化。</p>
</blockquote>
<p><strong>Java并没有没落，人们开始认识到这一点</strong></p>
<p>欢迎阅读我编写的<a href="https://jdk8.java.net/" target="_blank" rel="external">Java 8</a>介绍。本教程将带领你一步步认识这门语言的所有新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和可重复注解。在这篇教程的最后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。<br><strong>没有大段的废话，只是一些带注释的代码片段，望君喜欢。</strong></p>
<p>本文最早发表在我的<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">博客</a>上。 你可以在Twitter上<a href="https://twitter.com/winterbe_" target="_blank" rel="external">加我</a>。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java RESTful框架的性能比较]]></title>
    <link href="http://colobu.com/2015/11/17/Jax-RS-Performance-Comparison/"/>
    <id>http://colobu.com/2015/11/17/Jax-RS-Performance-Comparison/</id>
    <published>2015-11-17T08:57:09.000Z</published>
    <updated>2015-11-18T08:26:08.799Z</updated>
    <content type="html"><![CDATA[<p>在微服务流行的今天，我们会从纵向和横向分解代码的逻辑，将一些独立的无状态的代码单元实现为微服务，可以将它们发布到一些分布式计算单元或者Docker中，并在性能需要的时候及时地创建更多的服务单元。<br>微服务是一个概念，并没有规定服务的格式，但是很多厂商和框架都不约而同的采用RESTful的架构,尽管也有一些其它的性能很好的RPC框架。<br>如何在Java生态圈选择一个轻量级的RESTful框架？可以参考一些其他人的经验， 比如我翻译的: <a href="http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">最好的8个 Java RESTful 框架</a>。<br>就我个人而言，我选择框架的理由很简单：</p>
<ul>
<li>简单，轻量级</li>
<li>性能好</li>
<li>稳定，可靠</li>
<li>易于开发和维护</li>
</ul>
<p>我会首选遵循Java规范(<a href="https://jcp.org/en/jsr/detail?id=339" target="_blank" rel="external">JSR339</a>)的框架，轻量级，便于发布到Docker容器中。 所以我不会选择Spring boot, Spring MVC, CXF等比较重的框架,也不会选择纯netty这样的太过底层，还得实现路由等基本功能框架。<br>因为追求轻量级，便于发布到docker容器中，我也不会考察JBOSS, Tomcat这样的JEE容器， 而是选用jetty, undertow这样的嵌入式容器。</p>
<p>所以，这里我挑选了几个候选者：</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Grizzly</a></li>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty</a></li>
<li><a href="http://www.dropwizard.io" target="_blank" rel="external">Dropwizard</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Netty</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Undertow</a></li>
</ol>
<p><strong>[Updated on 2015/11/18]</strong><br>我增加了更多的 RESTful 框架,有些不是Jax-RS的实现，但是也有很活跃的社区。</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty4</a></li>
<li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a></li>
<li><a href="http://netty.io/" target="_blank" rel="external">纯Netty</a></li>
<li><a href="http://vertx.io/" target="_blank" rel="external">Vert.x</a><br>你会发现一些有趣的测试结果。</li>
</ol>
<p>Jersey 是Jax-RS的官方参考实现，可以很好的和其它JEE容器集成。RESTEasy是JBoss出品的框架，也很容易的和其它容器集成。Dropwizard实际上集成了Jersey, Jetty以及其它的第三方库比如它的Metrics，提供了一站式的开发，略微有些厚重。</p>
<p>测试相关的代码已经放在了GITHUB上： <a href="https://github.com/smallnest/Jax-RS-Performance-Comparison" target="_blank" rel="external">代码</a><br><a id="more"></a></p>
<h3 id="编译代码">编译代码</h3>
<p>测试代码是一个多模块的Maven项目， 你直接运行<code>maven clean package</code>就可以生成各个jar,而且这些jar包含了所依赖的类，执行起来相当简单。<br>你也可以在每个模块下运行<code>mvn exec:java</code>启动服务，然后在浏览器中访问 <a href="http://localhost:8080/rest/hello" target="_blank" rel="external">http://localhost:8080/rest/hello</a> (对于Jersey + Jetty,地址是<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>)</p>
<h3 id="测试环境">测试环境</h3>
<p><strong>服务器</strong><br>AWS C3.2xlarge</p>
<ul>
<li>8 cores (E5-2666 v3 @ 2.90GHz)</li>
<li>memory: 16G (服务只分配了4G内存)</li>
</ul>
<p><strong>Java</strong><br>1.8.0_51</p>
<p><strong>测试工具</strong><br><a href="https://github.com/wg/wrk" target="_blank" rel="external">wrk</a><br>测试命令如: <code>wrk -t16 -c1000 -d30s http://127.0.0.1:8080/rest/hello</code>.<br>针对每个case, 我使用16个线程，以及100/200/500/1000并发进行测试。</p>
<p><strong>服务启动命令</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="title">java</span> -Xmx4g -Xms4g -jar jersey-grizzly2-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar jersey-jetty-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar dropwizard-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar hello.yml </div><div class="line">java -Xmx4g -Xms4g -jar resteasy-netty-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar </div><div class="line">java -Xmx4g -Xms4g -jar resteasy-undertow-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar springboot-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar resteasy-netty4-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar </div><div class="line">java -Xmx4g -Xms4g -jar nativenetty-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar vertx-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div></pre></td></tr></table></figure>

<h3 id="测试结果">测试结果</h3>
<p>测试结果数据可以查看这里： <a href="Jax-RS-Performance-Comparison">测试数据</a>,<br>延迟基本在几毫秒到10几毫秒之间。</p>
<p>图形化测试结果(y轴为Requests/sec, x轴为并发量)：<br><img src="performance.png" alt=""></p>
<h3 id="结论">结论</h3>
<p>从结果看，</p>
<ul>
<li>RESTEasy的性能要好于 Jersey,无论哪种嵌入式JEE容器。</li>
<li>Jersey+Grizzly2和Jersey+Jetty, dropwizard性能差别不大</li>
<li>dropwizard底层实际是Jersey+Jetty,性能结果也和Jersey+Jetty一样</li>
<li>RESTEasy+netty (netty3)的结果并没有优于RESTEasy+undertow.这出乎我的意料，可能CPU和Memory占用上会好一些</li>
<li>RESTEasy+netty4的性能远远低于RESTEasy+netty3，这出乎我的意料。或许因为Netty线程池的改变。</li>
<li>纯netty的性能远远高于其它框架，一方面是由于没有http router的逻辑，另一方面也显示了Netty框架的优秀。如果不是实现很复杂的路由和很多的Service,不妨使用纯Netty实现高性能。</li>
<li>Spring Boot太厚重了，使用Spring MVC的语法，性能只有Jersey的一半。</li>
<li>Vert.x底层使用Netty,可以使用Java 8 Lambda语法，也提供了其它语言的支持，但是性能看起来不是太好，而且随着并发量增大吞吐率也随之下降。</li>
</ul>
<p>当然测试也有一点遗憾，就是没有记录测试时的CPU占用率和Memory占用率，以我个人的经验，这方面Netty会占一些优势。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在微服务流行的今天，我们会从纵向和横向分解代码的逻辑，将一些独立的无状态的代码单元实现为微服务，可以将它们发布到一些分布式计算单元或者Docker中，并在性能需要的时候及时地创建更多的服务单元。<br>微服务是一个概念，并没有规定服务的格式，但是很多厂商和框架都不约而同的采用RESTful的架构,尽管也有一些其它的性能很好的RPC框架。<br>如何在Java生态圈选择一个轻量级的RESTful框架？可以参考一些其他人的经验， 比如我翻译的: <a href="http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">最好的8个 Java RESTful 框架</a>。<br>就我个人而言，我选择框架的理由很简单：</p>
<ul>
<li>简单，轻量级</li>
<li>性能好</li>
<li>稳定，可靠</li>
<li>易于开发和维护</li>
</ul>
<p>我会首选遵循Java规范(<a href="https://jcp.org/en/jsr/detail?id=339" target="_blank" rel="external">JSR339</a>)的框架，轻量级，便于发布到Docker容器中。 所以我不会选择Spring boot, Spring MVC, CXF等比较重的框架,也不会选择纯netty这样的太过底层，还得实现路由等基本功能框架。<br>因为追求轻量级，便于发布到docker容器中，我也不会考察JBOSS, Tomcat这样的JEE容器， 而是选用jetty, undertow这样的嵌入式容器。</p>
<p>所以，这里我挑选了几个候选者：</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Grizzly</a></li>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty</a></li>
<li><a href="http://www.dropwizard.io" target="_blank" rel="external">Dropwizard</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Netty</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Undertow</a></li>
</ol>
<p><strong>[Updated on 2015/11/18]</strong><br>我增加了更多的 RESTful 框架,有些不是Jax-RS的实现，但是也有很活跃的社区。</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty4</a></li>
<li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a></li>
<li><a href="http://netty.io/" target="_blank" rel="external">纯Netty</a></li>
<li><a href="http://vertx.io/" target="_blank" rel="external">Vert.x</a><br>你会发现一些有趣的测试结果。</li>
</ol>
<p>Jersey 是Jax-RS的官方参考实现，可以很好的和其它JEE容器集成。RESTEasy是JBoss出品的框架，也很容易的和其它容器集成。Dropwizard实际上集成了Jersey, Jetty以及其它的第三方库比如它的Metrics，提供了一站式的开发，略微有些厚重。</p>
<p>测试相关的代码已经放在了GITHUB上： <a href="https://github.com/smallnest/Jax-RS-Performance-Comparison" target="_blank" rel="external">代码</a><br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最好的8个 Java RESTful 框架]]></title>
    <link href="http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/"/>
    <id>http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/</id>
    <published>2015-11-15T05:03:22.000Z</published>
    <updated>2015-11-18T02:53:34.362Z</updated>
    <content type="html"><![CDATA[<p>原文： <a href="http://www.gajotres.net/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">Top 8 Java RESTful Micro Frameworks</a><br>过去的每一年，涌现出越来越多的Java框架。就像JavaScript，每个人都认为他们知道一个好的框架的功能应该是怎么样的。连我的老祖母现在也使用一个我从来没有听说过而且可能永远不会使用的框架。玩笑归玩笑，可以做几乎任何事的臃肿的框架市场已经饱和，，但是如何评判呢?</p>
<p>这篇文章旨在提供目前最好的 Java RESTfulful 框架。我只介绍轻量级的产品， 略过了那些臃肿的过度设计的框架。同时，我只想要他们稳定和成熟，提供简单，轻量级的特点。我只在介绍Play frameworks时打破这条规则，理由稍后给出。</p>
<p>在将来的项目中使用哪个 Java RESTful框架完全取决于你当前的需求。为了便于你取舍，我将列出最突出的框架功能,希望这能节省一些你的时间。</p>
<a id="more"></a>
<h3 id="Dropwizard">Dropwizard</h3>
<p>诞生时间: 2011<br>评分: 4.5/5</p>
<p>Dropwizard 提供了稳定成熟的Java库， 并封装成一个简单的轻量级的包。<br>Dropwizard 介于框架和库之间。它提供了一个开发web应用程序的全部所需。由于内置模块化，一个应用程序可以保持小而精干的特点，减少开发和维护的时间，减少负担。<br>Dropwizard 使用已有的 Jetty HTTP 库，嵌入到你的项目中，无需外部的server。所有的Dropwizard项目都有一个 main 方法来管理内建的 HTTP server. </p>
<p><strong>链接</strong><br><a href="http://www.dropwizard.io/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/dropwizard/dropwizard" target="_blank" rel="external">GITHUB</a> <a href="http://www.dropwizard.io/getting-started.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快速的项目构建和启动</li>
<li>模块化</li>
<li>不可思议的快(至少根据内建的 metric 测得的结果)</li>
<li>Jetty for HTTP, Jersey for REST, 以及 Jackson for JSON</li>
<li>也支持其它的库， 比如 Mustache, Logback, JDBI, Hibernate Validator, Guava, …</li>
<li>使用Metrics支持监控</li>
<li>Main方法启动 Jetty server，可以容易地调试和维护</li>
<li>社区力度强</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>Dropwizard文档是主要的知识来源，但谈不上优秀。你可能需要搜索和发掘第三方类库的文档。</li>
<li>因为某些原因错误被当作普通文本, 如果你希望响应结果总是JSON，这可能有问题</li>
<li>确保使用最新的Dropwizard， 一些老版本使用了废弃的第三方库。 而且早期的Dropwizzard也很难升级</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.helloworld;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> io.dropwizard.Application;</div><div class="line"><span class="keyword">import</span> io.dropwizard.setup.Bootstrap;</div><div class="line"><span class="keyword">import</span> io.dropwizard.setup.Environment;</div><div class="line"><span class="keyword">import</span> com.example.helloworld.resources.HelloWorldResource;</div><div class="line"><span class="keyword">import</span> com.example.helloworld.health.TemplateHealthCheck;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HelloWorldConfiguration</span>&gt; </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="keyword">new</span> HelloWorldApplication().run(args);</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">getName</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello-world"</span>;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span>(Bootstrap&lt;HelloWorldConfiguration&gt; bootstrap) {</div><div class="line">        <span class="comment">// nothing to do yet</span></div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(HelloWorldConfiguration configuration,</div><div class="line">                    Environment environment) {</div><div class="line">        <span class="comment">// nothing to do yet</span></div><div class="line">    }</div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>个人不想为大的项目推荐这个框架。不过如果你想尝试的话，你不会失望的。主要是这个框架使用最好的现代的Java web 组件，组装成一个简单易用的框架。<br>不幸的是这也带来了它的问题。 将这些库糅合起来可能导致不可预见的问题。这也是我为什么给它减掉0.5颗星，而没有评为满分5颗星。</p>
<h3 id="Jersey">Jersey</h3>
<p>诞生时间: 2012 (Jersey 2.X)<br>评分: 5/5</p>
<p>Jersey RESTful 框架是开源的RESTful框架, 实现了JAX-RS (JSR 311 &amp; JSR 339) 规范。它扩展了JAX-RS 参考实现， 提供了更多的特性和工具， 可以进一步地简化 RESTful service 和 client 开发。尽管相对年轻，它已经是一个产品级的 RESTful service 和 client 框架。</p>
<p><strong>链接</strong><br><a href="https://jersey.java.net/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/jersey/jersey" target="_blank" rel="external">GITHUB</a> <a href="https://jersey.java.net/documentation/latest/index.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>优秀的文档和例子</li>
<li>快速</li>
<li>超级容易的路由</li>
<li>平滑的 JUnit 集成</li>
<li>就个人而言, 当开发 RESTful service 时, JAX-RS 实现要好于 MVC 框架。</li>
<li>可以集成到其它库/框架 (Grizzly, Netty). 这也可能是很多产品使用它的原因。</li>
<li>支持异步链接</li>
<li>不喜欢 servlet container? 使用Jersey的时候可以不用它们。</li>
<li>WADL, XML/JSON support</li>
<li>包含在Glassfish中</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>Jersey 2.0+使用了有些复杂的依赖注入实现</li>
<li>可能不是一件坏事。Jersey 1.X 使用较老的 JAX-RS 实现</li>
<li>一大堆第三方库只支持 Jersey 1.X， 在 Jersey 2.X 不可用</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.glassfish.jersey.examples.helloworld;</div><div class="line">  </div><div class="line"><span class="keyword">import</span> javax.ws.rs.GET;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.Path;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</div><div class="line">  </div><div class="line"><span class="annotation">@Path</span>(<span class="string">"helloworld"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldResource</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLICHED_MESSAGE = <span class="string">"Hello World!"</span>;</div><div class="line">  </div><div class="line"><span class="annotation">@GET</span></div><div class="line"><span class="annotation">@Produces</span>(<span class="string">"text/plain"</span>)</div><div class="line">    <span class="keyword">public</span> String <span class="title">getHello</span>() {</div><div class="line">        <span class="keyword">return</span> CLICHED_MESSAGE;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>Jersey 是我的选择， 5颗星。</p>
<h3 id="Ninja_Web_Framework">Ninja Web Framework</h3>
<p>诞生时间: 2012<br>评分: 3.5/5<br>Ninja Web Framework是全栈的 java web framework。稳定, 快速, 可靠, 产品级.<br>它提供了开发，测试，发布，维护 RESTful web应用的一切(Servlets, Guice, JPA, Flyway migrations, Maven, etc.).<br>就像 DropWizzard, Ninja Web Framework 是一个集成的软件栈。你不必建立你自己的，只需使用 Maven archetype生成一个新的项目，导入到IDE中就可以开始编码了。</p>
<p><strong>链接</strong><br><a href="http://www.ninjaframework.org/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/ninjaframework/ninja" target="_blank" rel="external">GITHUB</a> <a href="http://www.ninjaframework.org/documentation/getting_started/installing_ninja.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快</li>
<li>快速的项目构建和启动</li>
<li>模块化</li>
<li>XML, HTML, JSON渲染</li>
<li>也支持其它的库 (如 Guice, Logback, Guava, etc.)</li>
<li>很好的数据持久化和缓存</li>
<li>不喜欢 servlet container? U可以选择你喜欢的容器</li>
<li>如果根本就不喜欢容器，可以使用 standalone 模式, 使用Jetty作为一个自执行的jar</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>同样，就像DropWizzard, 文档有但是不够好。我花了好长时间去了解它。这个框架也依赖很多其它的库，有时候想得到所需的信息很麻烦。</li>
<li>不怎么出名，社区小。 有谣言说这个框架是由那些切换到Scala的 Play 2.X 用户创建的</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationController</span> </span>{       </div><div class="line"> </div><div class="line">    <span class="keyword">public</span> Result <span class="title">index</span>() {</div><div class="line"> </div><div class="line">        Person person = <span class="keyword">new</span> Person();</div><div class="line">        person.name = <span class="string">"John Johnson"</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> Results.json().render(person);</div><div class="line"> </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>看起来不错，但是在它成熟之前我还是把它丢在一边吧。</p>
<h3 id="Play_Framework">Play Framework</h3>
<p>诞生时间: 2011<br>评分: 4/5 </p>
<p>使用Play Framework 很容易地创建，构建和发布 web 应用程序，支持 Java &amp; Scala。它使用Akka, 基于一个轻量级的无状态的架构。它应该应用于大规模地低CPU和内存消耗的应用。</p>
<p><strong>链接</strong><br><a href="https://www.playframework.com/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/playframework/playframework" target="_blank" rel="external">GITHUB</a> <a href="https://www.playframework.com/documentation/2.4.x/Home" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>易于开发</li>
<li>快，但是没有其它的一些框架快</li>
<li>基于 Netty, 支持非阻塞的 I/O. 并行处理远程调用的时候很优秀</li>
<li>社区很大</li>
<li>快速的项目构建和启动</li>
<li>模块化</li>
<li><strong>MVC</strong></li>
<li>REST, JSON/XML, Web Sockets, non-blocking I/O</li>
<li>只需刷新浏览器就可以看到最新的改变</li>
<li>支持Async</li>
<li>有出版的书</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>版本2.0 是最有争议的Java框架。 切换至Switch to Scala made some Java developers outraged.</li>
<li>不向后兼容; Play 2.X 重写了</li>
<li>号称轻量级，但有些臃肿</li>
<li>SBT构建工具. 号称 Maven 杀手, 但是从没有优秀到替换它。难以学习和配置</li>
<li>非 servlet</li>
<li>Breaking changes across releases</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers</div><div class="line"> </div><div class="line"><span class="keyword">import</span> play.api._</div><div class="line"><span class="keyword">import</span> play.api.mvc._</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>{</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> hello(name: String) = Action {</div><div class="line">    Ok(<span class="string">"Hello "</span> + name + <span class="string">"!"</span>)</div><div class="line">  }</div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>抱怨归抱怨，我还是一直喜欢和首选这个框架。不幸的是，我只能给它4颗星。我坚信 基于JAX-RS的框架更适合 RESTful web services.</p>
<h3 id="RestExpress">RestExpress</h3>
<p>诞生时间: 2009<br>评分: 3/5 </p>
<p>RestExpress是一个非容器的轻量级的 Netty HTTP栈的包装， 以便更容易地创建 Java RESTful services.<br>RestExpress 目标是支持最好的 RESTful 实践。</p>
<p><strong>链接</strong><br><a href="https://github.com/RestExpress/RestExpress" target="_blank" rel="external">GITHUB</a></p>
<p><strong>优点</strong></p>
<ul>
<li>真正的微框架</li>
<li>顶级的性能，快，可靠</li>
<li>XML/JSON</li>
<li>最老的也是最稳定的 RESTful 框架之一</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>没有文档</li>
<li>几乎没有支持</li>
<li>很小的社区    </li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpMethod;</div><div class="line"><span class="keyword">import</span> org.restexpress.RestExpress;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></div><div class="line">{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RestExpress <span class="title">startServer</span>(String[] args) <span class="keyword">throws</span> IOException</div><div class="line">    {</div><div class="line">        RestExpress server = <span class="keyword">new</span> RestExpress();</div><div class="line">        MyResource r = <span class="keyword">new</span> MyResource();</div><div class="line"> </div><div class="line">        server.uri(<span class="string">"/myapp/myresource"</span>, r)</div><div class="line">            .method(HttpMethod.GET)</div><div class="line">            .noSerialization();</div><div class="line"> </div><div class="line">        server.uri(<span class="string">"/myapp/myresource"</span>, r)</div><div class="line">            .method(HttpMethod.POST);</div><div class="line"> </div><div class="line">        server.bind(<span class="number">8080</span>);</div><div class="line">        <span class="keyword">return</span> server;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        RestExpress server = startServer(args);</div><div class="line">        System.out.println(<span class="string">"Hit enter to stop it..."</span>);</div><div class="line">        System.in.read();</div><div class="line">        server.shutdown();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>尽管这个框架超级快，我也不想推荐它。文档缺乏以及没有支持使它成为一个欠佳的框架。看在速度的份上给它3颗星。</p>
<h3 id="Restlet">Restlet</h3>
<p>诞生时间: 2005<br>评分: 4.5/5</p>
<p>Restlet 帮助Java程序员建立大规模的快速的符合 RESTful 架构模式的web api。<br>它提供了强大的路由和filtering 系统。统一的client/server Java API. 满足所有主要的平台 (Java SE/EE, Google AppEngine, OSGi, GWT, Android) 以及提供了无数的扩展以满足程序员的需求。<br>据我说知，它是第一个 java RESTful web 框架。很多公司都在用它，但是你可能从未听说过它，好像它已经不可见了。</p>
<p><strong>链接</strong><br><a href="http://restlet.com/products/restlet-framework/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/restlet/restlet-framework-java" target="_blank" rel="external">GITHUB</a> <a href="http://restlet.com/products/restlet-framework/" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>强大</li>
<li>企业级的框架</li>
<li>多平台 Java SE, Java EE, Google Web Toolkit, Google AppEngine, Android, OSGi environments</li>
<li>支持JAX-RS (就像 Jersey)</li>
<li>大部分高级 RESTful 支持</li>
<li>模块化</li>
<li>支持其它库</li>
<li>开发一直活跃</li>
<li>智能的url绑定， 全功能的 URI 路由</li>
<li>有相关的书籍</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>非常陡峭的学习曲线</li>
<li>关闭的社区，尽管 StackOverflow 上还是开放的</li>
<li>不再流行，更多的是因为 Play Framework 和 Jersey</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Part03</span> <span class="keyword">extends</span> <span class="title">ServerResource</span> </span>{</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="comment">// Create the HTTP server and listen on port 8182</span></div><div class="line">        <span class="keyword">new</span> Server(Protocol.HTTP, <span class="number">8182</span>, Part03.class).start();</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Get</span>(<span class="string">"txt"</span>)</div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello, world"</span>;</div><div class="line">    }</div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>尽管这个框架还一直流行，考虑到它的年纪和当前的完成度，我不能给它5颗星。</p>
<h3 id="Restx">Restx</h3>
<p>诞生时间: 2013<br>评分: 3.5/5 </p>
<p>Restx 是一个轻量级的,模块化的,特性众多的，超快的开源 Java REST 框架。</p>
<p><strong>链接</strong><br><a href="http://restx.io/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/restx/restx" target="_blank" rel="external">GITHUB</a> <a href="http://restx.io/docs/" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快速，轻量级</li>
<li>容易搭建</li>
<li>真正的微框架</li>
<li>模块化</li>
<li>支持其它库</li>
<li>支持MongoDB</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不友好的令人迷惑的文档。对于这类框架我期望能有好一点的文档</li>
<li>太年轻</li>
<li>目前还不支持异步Async</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@GET</span>(<span class="string">"/message/{id}"</span>)</div><div class="line">    <span class="keyword">public</span> Message <span class="title">sayHello</span>(String id, // path param</div><div class="line">                            String who // query param</div><div class="line">                            ) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message().setMessage(String.format(</div><div class="line">                <span class="string">"hello %s, it's %s"</span>,</div><div class="line">                who, DateTime.now().toString(<span class="string">"HH:mm:ss"</span>)));</div><div class="line">    }</div><div class="line"><span class="annotation">@POST</span>(<span class="string">"/message/{id}"</span>)</div><div class="line">    <span class="keyword">public</span> Message <span class="title">sayHello</span>(String id, // path param</div><div class="line">                            Message msg // body param</div><div class="line">                            ) {</div><div class="line">        <span class="keyword">return</span> msg.setMessage(String.format(</div><div class="line">                <span class="string">"%s @ %s"</span>,</div><div class="line">                msg.getMessage(), DateTime.now().toString(<span class="string">"HH:mm:ss"</span>)));</div><div class="line">    }</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>真心来讲我没有在这个框架上花费太多时间。不值得在另一个框架上花费太多精力，我意思是说，Java框架市场已经越来越碎片化了，就像 JavaScript 市场，应该停止这种趋势了。</p>
<h3 id="Spark_Framework">Spark Framework</h3>
<p>诞生时间: 2011<br>评分: 3.5/5<br>不要和 Apache 的大数据框架 Spark 弄混, 这里的 Spark 框架是一个轻量级的 Java web 框架，用来进行快速的开发(50% Spark用户使用 Spark 创建 REST APIs)。 它受 Ruby 框架 Sinatra 启发。</p>
<p>它有一个不到1M的最小化的内核， 提供了所有基本的特性, 用来构建 RESTful 或者传统的 web 应用程序。</p>
<p><strong>链接</strong><br><a href="http://sparkjava.com/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/perwendel/spark" target="_blank" rel="external">GITHUB</a> <a href="http://sparkjava.com/documentation.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快，轻量级</li>
<li>优秀的快速原型</li>
<li>易于搭建</li>
<li>经常和AngularJS搭配使用</li>
<li>真正的微框架</li>
<li>使用 Jetty</li>
<li>可以用在容器中或者独立运行</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>文档可以更好，它不适合初学者</li>
<li>不适合大型项目</li>
<li>社区小</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> spark.Spark.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">      get(<span class="string">"/hello"</span>, (req, res) -&gt; <span class="string">"Hello World"</span>);</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>这个框架适合初始开发。主要用作小小项目或者原型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文： <a href="http://www.gajotres.net/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">Top 8 Java RESTful Micro Frameworks</a><br>过去的每一年，涌现出越来越多的Java框架。就像JavaScript，每个人都认为他们知道一个好的框架的功能应该是怎么样的。连我的老祖母现在也使用一个我从来没有听说过而且可能永远不会使用的框架。玩笑归玩笑，可以做几乎任何事的臃肿的框架市场已经饱和，，但是如何评判呢?</p>
<p>这篇文章旨在提供目前最好的 Java RESTfulful 框架。我只介绍轻量级的产品， 略过了那些臃肿的过度设计的框架。同时，我只想要他们稳定和成熟，提供简单，轻量级的特点。我只在介绍Play frameworks时打破这条规则，理由稍后给出。</p>
<p>在将来的项目中使用哪个 Java RESTful框架完全取决于你当前的需求。为了便于你取舍，我将列出最突出的框架功能,希望这能节省一些你的时间。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[uriDB网站的可扩展的技术栈]]></title>
    <link href="http://colobu.com/2015/11/09/The-Stack-of-uriDB/"/>
    <id>http://colobu.com/2015/11/09/The-Stack-of-uriDB/</id>
    <published>2015-11-09T04:43:00.000Z</published>
    <updated>2015-11-10T07:11:10.478Z</updated>
    <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB</a>本身不生产干货，<a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>网站只是大自然的搬运工。<br>自<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>诞生依赖，已经有多个中文技术头条的网站了，比如<a href="http://toutiao.io/" target="_blank" rel="external">开发者头条</a>和<a href="http://geek.csdn.net/hotest" target="_blank" rel="external">极客头条</a>，为什么还要做这样一个雷同的头条网站呢？</p>
<p>有两个原因：<br>一是我想做一个分类头条的网站，按照技术领域对文章进行分类，这样只对前端感兴趣的同学可以只跟踪最新的前端文章。 同时uriDB只会筛选最新的技术干货，不会将问答，闲聊等技术层次低的文章收录。<br>二是这么多年来，我涉及的领域包括后台，大数据，前端和移动端的技术也是我感兴趣的领域。心中那份对技术的持久的热情，促使我将多年的技术积累以某种具体的形式呈现出来，籍此展示并能持久的进行技术架构的演化。</p>
<p>因此，uriDB技术流网站也就孵化出来了。虽然目前的访问量比较少，但是看的用户数和访问量在逐步的提升，也是一件令人欣慰的事。至少，这个网站收集的干货也为那些执着学习的同学带来些许的便利和技能提升。</p>
<p>与其说<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>类似<em>Hacker News</em>网站， 还不说说它类似<a href="http://toutiao.com/" target="_blank" rel="external">今日头条</a>， 只不是今日头条上全是新闻类的内容，而<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>上全是技术干货。今日头条会将目标网站上的内容抓去过来进行重新排版，更加适合阅读。我也抓去了目标文章的内容，却没有进行重新排版显示，主要是考虑到了版权的问题，还是老老实实的做<em>Hacker News</em>一样的转发。</p>
<p>这个网站是2015年国庆节期间开始启动的，也是作为我的side project在维护。我会时不时的将我的新的想法，技术灵感应用于这个网站上。<br><img src="/2015/11/09/The-Stack-of-uriDB/uridb.png" alt=""><br><a id="more"></a></p>
<h3 id="产品部署环境">产品部署环境</h3>
<h4 id="云主机">云主机</h4>
<p>国内的云服务器包括：<a href="http://www.aliyun.com/" target="_blank" rel="external">阿里云</a> <a href="http://www.qcloud.com/" target="_blank" rel="external">腾讯云</a> <a href="https://mos.meituan.com/" target="_blank" rel="external">美团云</a> <a href="http://www.qingcloud.com/" target="_blank" rel="external">青云</a> <a href="http://www.hwclouds.com/" target="_blank" rel="external">华为云</a> <a href="http://www.ctyun.cn/" target="_blank" rel="external">天翼云</a> <a href="http://www.west263.com/" target="_blank" rel="external">西部数码</a> <a href="http://www.linkcloud.cn/" target="_blank" rel="external">Linkcloud</a><br>国外的如 <a href="http://aws.amazon.com/" target="_blank" rel="external">AWS</a> <a href="http://www.windowsazure.com/" target="_blank" rel="external">Azure</a> <a href="https://www.digitalocean.com/" target="_blank" rel="external">Digital Ocean</a> <a href="https://www.linode.com/" target="_blank" rel="external">linnode</a></p>
<p>云服务器之间的比较大家可以具体的搜索。<br>我使用 <a href="https://www.digitalocean.com/?refcode=67c9dbb27bb2" target="_blank" rel="external">DigitalOcean</a>的云主机作为服务器， 主要考虑价格便宜，而是使用ssd作硬盘，速度好，可以选用新加坡的机房。</p>
<h4 id="负载均衡">负载均衡</h4>
<p>使用CentOS 7.1做所有的节点的操作系统。<br>nginx 1.8.0作为负载均衡。为了实现高可用性，采用keepalived实现， 比如文章<a href="http://www.tokiwinter.com/building-a-highly-available-load-balancer-with-nginx-and-keepalived-on-centos/" target="_blank" rel="external">Building a Highly-Available Load Balancer with Nginx and Keepalived on CentOS</a>。这样当一台Load balancer宕机的时候，它的功能转移到另外一台Load balancer上。</p>
<p>Keepalived的作用是检测服务器的健康状态，在所有可能出现单点故障的地方为其提供高可用。如果有一台服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。keepalived的核心是vrrp，它是通过脚本来调用服务的，所以在keepalived的使用中，仅需关心两点：配置文件（/etc/keepalived/keepalived.conf）和服务脚本（/etc/rc.d/init.d/keepalived）</p>
<p>N年前我在Motorola工作的时候，使用的是一个商业的高可用方案，后来基于HAProxy+keepalived方式实现高可用，应用于视频节目的播放产品中。这里我们使用Nginx作为负载均衡器，所以配置Nginx+Keepalived作为双主高可用负载均衡器。</p>
<p>参考文档中列出了此方案的配置方法的一些介绍文章，文档内容基本类似，读者可以选择查看。<br>商业版的NGINX Plus提供了Keepalived的集成。</p>
<p>国内厂商使用 <a href="http://tengine.taobao.org/" target="_blank" rel="external">Tengine</a>也不少，配置keepalived一样。</p>
<p>使用Golang开发了整个服务器后台程序和爬虫。自2000年开始我用.NET做了三年的开发，2003年以后一致用Java做开发，2015年使用Scala做大数据和高性能服务器的开发。所以最熟悉的开发语言还是Java和Scala。<br>但是，我想挑战一下自己。Scala代码的优雅(这里指代码本身，不谈论性能等其它方面)，面向对象和函数式编程是我的思维得到了极大的扩展。通过对Go语言的学习，我也深深被它的简洁和编译的本地代码所吸引，所以业余将主要精力放在了Go语言的学习和实践上，也尝试为开源项目提供<a href="https://github.com/parnurzeal/gorequest/graphs/contributors" target="_blank" rel="external">贡献</a>。</p>
<p>虽然Java生态圈的库和框架多如牛毛，Go相关的高质量库也不断的涌现。Go在中国也相当的<a href="http://herman.asia/why-is-go-popular-in-china" target="_blank" rel="external">火</a>,国内的一些厂商也在应用Golang,如七牛，360等。本身我对Go实现一个高性能的服务器架构不持怀疑态度。</p>
<p>上面一句话是假的。既然决定采用Go作为主开发语言，必然在选型的时候做一些性能的测试。实际的测试结果也表明Go的性能不错。尽管<a href="http://colobu.com/2015/04/24/Web-Frameworks-Benchmark-2015/" target="_blank" rel="external">Web Frameworks Benchmark 2015</a>的测试中Go排名19，低于Java实现的Netty,undertow,Servlet, C++/C的实现等，我还是觉得Go的潜力无限。</p>
<p>另一个值得关注的语言是Mozilla主导的<a href="https://www.rust-lang.org/" target="_blank" rel="external">rust</a>，但是能否成气候还有待观察。</p>
<h3 id="前端">前端</h3>
<p>网站的前端主要采用当前流行的<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="external">单页程序</a>设计。采用AJAX进行数据的拉取。<br>2014年在Thistech主要采用<a href="http://emberjs.com/" target="_blank" rel="external">ember.js</a>进行开发，积累了一些前端框架经验，所以对ember.js的评价有好有坏。考虑到uriDB网站的形式，动态交互的逻辑不多(搜索，加载)，没必要重度使用前端框架如AngularJS, Ember.js, Backbone.js等。</p>
<p>所以最后使用jquery的ajax调用访问服务器的Restful API，以及jquery相关的插件。<br>前端的css框架采用定制的bootstrap，主要以红色色调为主，因为快到冬天了，红红火火，比较温暖，而没有采用蓝色系，尽管蓝色系的bootstrap也准备好了。</p>
<p>尽然通过jquery动态加载数据，页面基本上就是一个模版，这样动静分离，可以将静态页面cache住，减少服务器的压力。<br>相关的javascript和css进行了合并，并且进行了压缩。<br>在nginx出配置了gzip特性，超过1k的响应会被压缩。<br>将js,css,图片分流到另外一个域名上 <a href="http://static.uridb.com。" target="_blank" rel="external">http://static.uridb.com。</a><br>前端的图片采用动态加载的方式，只有滚动到显示时才进行加载，从而避免页面加载时间过长。</p>
<p>更多的前端优化请参看: <a href="http://colobu.com/2015/10/30/h5-performance/" target="_blank" rel="external">前端性能优化指南</a></p>
<h3 id="爬虫">爬虫</h3>
<p>爬虫运行在单独的服务器上，它会定时的到指定网站抓取最新的文章列表，这里对网站的请求使用了我的一个开源项目: <a href="https://github.com/smallnest/goreq" target="_blank" rel="external">goreq</a>，它简化了http client的操作。<br>它基于<a href="http://www.rssboard.org/" target="_blank" rel="external">RSS</a>或者<a href="https://github.com/PuerkitoBio/goquery" target="_blank" rel="external">goquery</a>进行分析列表，得到候选文章。<br>但是不止于此，它还会基于候选文章列表访问每个抓取的文章，获取文章的元数据和正文。<br>基于这些信息，它会生成文章的元数据，并进行自动化的分类。<br>当前的分类还是一个简单的根据关键词的分类，所以有时候会造成误判， 比如一篇《Go, Go, GO,让我们开始用Java编程》可能会被分类成Golang文章，尽管它属于Java栏目的。</p>
<p>爬虫应该能处理超时以及意外情况(不规整的html)，我们可以容忍一条文章的损失，但是必须保证整个爬虫程序不会垮掉。</p>
<p>充分利用Go interface，我们实现了简洁的爬虫程序，并且可以很方便的添加新的网站源。</p>
<p>通过crontab进行抓取，每天会抓取几次，每次的抓取时间少于10分钟。</p>
<h3 id="后台">后台</h3>
<p>使用<a href="https://github.com/go-zoo/bone" target="_blank" rel="external">bone</a>作为http Multiplexer，而没有采用其它流行的Go web框架如: <a href="http://www.gorillatoolkit.org/" target="_blank" rel="external">Gorilla</a>, 谢工的<a href="http://beego.me/" target="_blank" rel="external">Beego</a>等，主要还是考虑到简单和性能。<br>依照bone官方的测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> <span class="constant">BenchmarkBoneMux</span>        <span class="number">10000000</span>               <span class="number">118</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkZeusMux</span>          <span class="number">100000</span>               <span class="number">144</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkHttpRouterMux</span>  <span class="number">10000000</span>               <span class="number">134</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkNetHttpMux</span>      <span class="number">3000000</span>               <span class="number">580</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkGorillaMux</span>       <span class="number">300000</span>              <span class="number">3333</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkGorillaPatMux</span>   <span class="number">1000000</span>              <span class="number">1889</span> ns/op</span></div></pre></td></tr></table></figure>

<p>它的性能比Gorilla好太多了。使用它开发也非常的简单快捷。</p>
<p>后台是无状态的服务设计。Session需要在所有的节点共享。<br>使用 <a href="http://github.com/gorilla/sessions" target="_blank" rel="external">gorilla/sessions</a>实现session的管理，并且使用<a href="github.com/kidstuff/mongostore">mongostore</a>将session存储在MongoDB中。<br>也有其它的session存储方式， 如MySQL, Redis等：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/starJammer/gorilla-sessions-arangodb</span>](<span class="link_url">https://github.com/starJammer/gorilla-sessions-arangodb</span>) - ArangoDB</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/yosssi/boltstore</span>](<span class="link_url">https://github.com/yosssi/boltstore</span>) - Bolt</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/srinathgs/couchbasestore</span>](<span class="link_url">https://github.com/srinathgs/couchbasestore</span>) - Couchbase</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/denizeren/dynamostore</span>](<span class="link_url">https://github.com/denizeren/dynamostore</span>) - Dynamodb on AWS</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/bradleypeabody/gorilla-sessions-memcache</span>](<span class="link_url">https://github.com/bradleypeabody/gorilla-sessions-memcache</span>) - Memcache</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/hnakamur/gaesessions</span>](<span class="link_url">https://github.com/hnakamur/gaesessions</span>) - Memcache on GAE</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/kidstuff/mongostore</span>](<span class="link_url">https://github.com/kidstuff/mongostore</span>) - MongoDB</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/srinathgs/mysqlstore</span>](<span class="link_url">https://github.com/srinathgs/mysqlstore</span>) - MySQL</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/antonlindstrom/pgstore</span>](<span class="link_url">https://github.com/antonlindstrom/pgstore</span>) - PostgreSQL</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/boj/redistore</span>](<span class="link_url">https://github.com/boj/redistore</span>) - Redis</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/boj/rethinkstore</span>](<span class="link_url">https://github.com/boj/rethinkstore</span>) - RethinkDB</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/boj/riakstore</span>](<span class="link_url">https://github.com/boj/riakstore</span>) - Riak</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/michaeljs1990/sqlitestore</span>](<span class="link_url">https://github.com/michaeljs1990/sqlitestore</span>) - SQLite</div></pre></td></tr></table></figure>

<p>得益于Go http库的设计，可以实现很精巧的请求拦截， 比如进行权限检查，日志输出和Panic处理等。比如下面的panic的处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> panicCover(f http.HandlerFunc) http.HandlerFunc {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(w http.ResponseWriter, req *http.Request) {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="constant">nil</span> {</div><div class="line">				glog.Error(<span class="string">"Recovered in handlers"</span>, r, stack.Callers<span class="number">(3</span>))</div><div class="line">				http.Error(w, <span class="string">"Error"</span>, http.StatusInternalServerError)</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		f(w, req)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">mux.Get(<span class="string">"/abc"</span>, panicCover(http.HandlerFunc(oneHandler)))</div></pre></td></tr></table></figure>

<p>基于golang template可以实现网站的模板化处理,将布局layout和组件widget分开，这样可以公用header, footer,菜单，边栏等。<br>Restful API提供JSON数据，将从Mongo或者缓存中的数据返回给前端。</p>
<p>使用mgo作为数据访问层， mgo对于session/连接池的管理官方还缺乏一个详细而精确的说明，这里使用了基于请求的session管理:<a href="http://stackoverflow.com/questions/26574594/best-practice-to-maintain-a-mgo-session" target="_blank" rel="external">Best practice to maintain a mgo session</a></p>
<p>uriDB提供了微博,QQ,Github,Linkedin,Google的OAuth2登录，<a href="golang.org/x/oauth2">x/oauth2</a>并不能完全cover所有的oauth2的认证，因为每个厂家都有自己的方言，所以实现的时候针对每个厂家做了底层的处理。<br>同时还提供了注册服务器帐号的功能。<br>为了避免机器人注册和登录，提供了验证码的功能,基于<a href="github.com/dchest/captcha">dchest/captcha</a>。<br>我们需要考虑多节点的情况，填写验证码后请求可能会被提交到另外一个节点，所以验证码需要在节点中共享，所以实现了一个基于memcached的store。</p>
<p>考虑uriDB站点的情况， <strong>写</strong>操作相对较少，大部分的操作还是<strong>读</strong>，所以很适合用缓存来减少数据库的压力。使用memcached缓存文章的查询，极大地减少数据库的压力。</p>
<p>uriDB还提供了搜索的功能，详情见搜索那一节。</p>
<p>另外，还设计了管理员的简单平台，可以对文章进行审核，对用户进行管理，对文章进行修改。还提供了命令行的工具。<br>但是这些基本上不会用到，而是采用了slack机器人的方式，随时随地对网站进行管理: <a href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/" target="_blank" rel="external">使用Go开发一个 Slack 运维机器人 </a></p>
<p>日志采用<a href="https://github.com/golang/glog" target="_blank" rel="external">glog</a>，简单好用。</p>
<h3 id="数据库">数据库</h3>
<p>数据库的选择倒不是一个很艰难的选择，无论mysql还是MongoDB，cassandra都能胜任。<br>基本上现在每天收集的文章不到100篇，一年也才3万多篇， 10年也才30万。对数据库的存储压力不大。<br>所以这里选用了我近两年一直使用的Mongo。<br>Mongo数据的备份开始参照: <a href="http://colobu.com/2015/10/27/mongodb-backup/" target="_blank" rel="external">Mongodb 定期备份</a></p>
<p>如果数据库的压力增大，我会考虑将当前的MongoDB单例迁移到Replica Set,如果性能再不济，将其迁移到cluster模式，通过shard方式分担数据库的压力。我想基本不会达到这样的压力的。</p>
<p>但是数据库的备份是至关重要的，一旦机器宕机，或者遭受攻击，或者运维误操作，必须能恢复回来，否则哭也来不及。</p>
<h3 id="搜索">搜索</h3>
<p>当前的搜索基于Mongo的查询，搜索字段都建立了索引。但是在数据量大的时候，分页查询会是一个瓶颈，我想这对于实现过大数据分页的读者来说并不陌生。当offset很大的时候， 因为尽管你会skip这些offset取得limit条数据，也会搜索这些所有的数据，越往后查询越慢。<br>杨卫华(TimYang)有一篇很好的总结文章：<a href="http://timyang.net/data/key-list-pagination/" target="_blank" rel="external">为什么超长列表数据的翻页技术实现复杂</a></p>
<p>所以一般实现扶梯方式，只提供上一页下一页的功能，并不能直接跳转到n页。这样就可以通过最后一条或者第一条的偏移，获取下一页或者上一页的数据。<br>另外还要根据多字段查询，都建立索引对数据库的性能也有影响。</p>
<p>总的来说，在大数据量的情况下，查询并不是一件容易的事。</p>
<p>现在正在做的一件事是使用<a href="https://www.elastic.co/" target="_blank" rel="external">Elasticsearch</a>做索引服务器，可以很好的解决查询的问题。Elasticsearch已经在很多大公司得到广泛的应用，绝对是值得使用的做内容索引的产品。</p>
<p>最简单的方式，将Mongo数据库的数据导入到Elasticsearch中： <a href="http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/" target="_blank" rel="external">基于Golang将MongoDB的数据同步到Elasticsearch</a>。但是我不会采用这种方式，而是采用一种近实时的索引架构。</p>
<p>我索引的内容就是文章的元数据，元数据插入的时候只有两种：爬虫插入，读者提交/管理员更改/删除。所以在数据插入/更改/删除的时候将操作放入到<a href="https://github.com/nsqio/nsq" target="_blank" rel="external">nsq</a>中，Elasticsearch服务器读取到文章的变动，实时更新索引服务器。</p>
<p>使用nsq可以很好的实现异步的操作，将文章的变动和索引服务器的操作交给不同的服务器进行处理。<br>而且nsq也会作为uriDB异步服务的基础框架。</p>
<h3 id="移动端">移动端</h3>
<p>事实上，我先实现的Android版的移动端， 叫&quot;<a href="http://colobu.com/techreview/" target="_blank" rel="external">技术快报</a>&quot;， 如果你在一些应用商店搜索&quot;<a href="https://www.google.is/webhp?ie=utf-8&amp;oe=utf-8&amp;gws_rd=cr&amp;ei=w3BAVorbNsi80ASPsouICA#q=%E6%8A%80%E6%9C%AF%E5%BF%AB%E6%8A%A5+android" target="_blank" rel="external">Android 技术快报</a>&quot;就能搜到它。</p>
<p>因为当时还没有客户端，所以爬虫代码就在手机端实现的，出于时间的考虑，只能拉取很少的文章资源。</p>
<p>新的版本将直接从 <a href="http://uridb.com" target="_blank" rel="external">http://uridb.com</a> 拉取数据，并提供按照栏目进行浏览的方式，基本上会类似网易新闻这样的客户端。</p>
<h3 id="运维">运维</h3>
<p>Elasticsearch、Logstash和Kibana会是日志分析的三剑客。<br>当前的运维还很薄弱，服务器的监控，软件的重启和升级都靠手工，这些都是有待加强的地方。</p>
<p>当前实现了一个slack机器人，这样我就可以通过聊天室让机器人完成一些网站管理的工作，现在感觉超方便，我甚至可以在炒菜的时候得到网站的消息，也可以在睡觉前查看服务器的状态。</p>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="http://www.tokiwinter.com/building-a-highly-available-load-balancer-with-nginx-and-keepalived-on-centos/" target="_blank" rel="external">http://www.tokiwinter.com/building-a-highly-available-load-balancer-with-nginx-and-keepalived-on-centos/</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-highly-available-web-servers-with-keepalived-and-floating-ips-on-ubuntu-14-04" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-set-up-highly-available-web-servers-with-keepalived-and-floating-ips-on-ubuntu-14-04</a></li>
<li><a href="http://seanlook.com/2015/05/18/nginx-keepalived-ha/" target="_blank" rel="external">http://seanlook.com/2015/05/18/nginx-keepalived-ha/</a></li>
<li><a href="http://nmshuishui.blog.51cto.com/1850554/1405484" target="_blank" rel="external">http://nmshuishui.blog.51cto.com/1850554/1405484</a></li>
<li><a href="http://isux.tencent.com/h5-performance.html" target="_blank" rel="external">http://isux.tencent.com/h5-performance.html</a></li>
<li><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">https://developer.yahoo.com/performance/rules.html</a></li>
<li><a href="https://github.com/PuerkitoBio/goquery" target="_blank" rel="external">https://github.com/PuerkitoBio/goquery</a></li>
<li><a href="https://github.com/smallnest/goreq" target="_blank" rel="external">https://github.com/smallnest/goreq</a></li>
<li><a href="https://github.com/go-zoo/bone" target="_blank" rel="external">https://github.com/go-zoo/bone</a></li>
<li><a href="http://github.com/gorilla/sessions" target="_blank" rel="external">http://github.com/gorilla/sessions</a></li>
<li><a href="http://github.com/kidstuff/mongostore" target="_blank" rel="external">http://github.com/kidstuff/mongostore</a></li>
<li><a href="https://labix.org/mgo" target="_blank" rel="external">https://labix.org/mgo</a></li>
<li><a href="http://stackoverflow.com/questions/26574594/best-practice-to-maintain-a-mgo-session" target="_blank" rel="external">http://stackoverflow.com/questions/26574594/best-practice-to-maintain-a-mgo-session</a></li>
<li><a href="https://godoc.org/golang.org/x/oauth2" target="_blank" rel="external">https://godoc.org/golang.org/x/oauth2</a></li>
<li><a href="https://github.com/dchest/captcha" target="_blank" rel="external">https://github.com/dchest/captcha</a></li>
<li><a href="https://github.com/golang/glog" target="_blank" rel="external">https://github.com/golang/glog</a></li>
<li><a href="https://github.com/bradfitz/gomemcache/memcache" target="_blank" rel="external">https://github.com/bradfitz/gomemcache/memcache</a></li>
<li><a href="http://colobu.com/2015/10/27/mongodb-backup/" target="_blank" rel="external">http://colobu.com/2015/10/27/mongodb-backup/</a></li>
<li><a href="http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/" target="_blank" rel="external">http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/</a></li>
<li><a href="https://github.com/nsqio/nsq" target="_blank" rel="external">https://github.com/nsqio/nsq</a></li>
<li><a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="external">https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details</a></li>
<li><a href="http://kibana.logstash.es/" target="_blank" rel="external">http://kibana.logstash.es/</a></li>
<li><a href="https://www.gitbook.com/book/chenryn/logstash-best-practice/details" target="_blank" rel="external">https://www.gitbook.com/book/chenryn/logstash-best-practice/details</a></li>
<li><a href="https://www.gitbook.com/book/looly/elasticsearch-the-definitive-guide-cn/details" target="_blank" rel="external">https://www.gitbook.com/book/looly/elasticsearch-the-definitive-guide-cn/details</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="背景">背景</h3>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB</a>本身不生产干货，<a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>网站只是大自然的搬运工。<br>自<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>诞生依赖，已经有多个中文技术头条的网站了，比如<a href="http://toutiao.io/" target="_blank" rel="external">开发者头条</a>和<a href="http://geek.csdn.net/hotest" target="_blank" rel="external">极客头条</a>，为什么还要做这样一个雷同的头条网站呢？</p>
<p>有两个原因：<br>一是我想做一个分类头条的网站，按照技术领域对文章进行分类，这样只对前端感兴趣的同学可以只跟踪最新的前端文章。 同时uriDB只会筛选最新的技术干货，不会将问答，闲聊等技术层次低的文章收录。<br>二是这么多年来，我涉及的领域包括后台，大数据，前端和移动端的技术也是我感兴趣的领域。心中那份对技术的持久的热情，促使我将多年的技术积累以某种具体的形式呈现出来，籍此展示并能持久的进行技术架构的演化。</p>
<p>因此，uriDB技术流网站也就孵化出来了。虽然目前的访问量比较少，但是看的用户数和访问量在逐步的提升，也是一件令人欣慰的事。至少，这个网站收集的干货也为那些执着学习的同学带来些许的便利和技能提升。</p>
<p>与其说<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>类似<em>Hacker News</em>网站， 还不说说它类似<a href="http://toutiao.com/" target="_blank" rel="external">今日头条</a>， 只不是今日头条上全是新闻类的内容，而<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>上全是技术干货。今日头条会将目标网站上的内容抓去过来进行重新排版，更加适合阅读。我也抓去了目标文章的内容，却没有进行重新排版显示，主要是考虑到了版权的问题，还是老老实实的做<em>Hacker News</em>一样的转发。</p>
<p>这个网站是2015年国庆节期间开始启动的，也是作为我的side project在维护。我会时不时的将我的新的想法，技术灵感应用于这个网站上。<br><img src="/2015/11/09/The-Stack-of-uriDB/uridb.png" alt=""><br>]]>
    
    </summary>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="bootstrap" scheme="http://colobu.com/tags/bootstrap/"/>
    
      <category term="nginx" scheme="http://colobu.com/tags/nginx/"/>
    
      <category term="nsq" scheme="http://colobu.com/tags/nsq/"/>
    
      <category term="android" scheme="http://colobu.com/tags/android/"/>
    
      <category term="mongo" scheme="http://colobu.com/tags/mongo/"/>
    
      <category term="elasticsearch" scheme="http://colobu.com/tags/elasticsearch/"/>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法 Python&R 速查表]]></title>
    <link href="http://colobu.com/2015/11/05/full-cheatsheet-machine-learning-algorithms/"/>
    <id>http://colobu.com/2015/11/05/full-cheatsheet-machine-learning-algorithms/</id>
    <published>2015-11-05T02:55:29.000Z</published>
    <updated>2015-11-09T01:36:49.673Z</updated>
    <content type="html"><![CDATA[<p>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">Cheatsheet – Python &amp; R codes for common Machine Learning Algorithms</a><br>在拿破仑•希尔的名著《思考与致富》中讲述了达比的故事：达比经过几年的时间快要挖掘到了金矿，却在离它三英尺的地方离开了！</p>
<p>现在,我不知道这个故事是否真实。但是,我肯定在我的周围有一些跟达比一样的人，这些人认为，不管遇到什么问题, 机器学习的目的就是执行以及使用2 – 3组算法。他们不去尝试更好的算法和技术，因为他们觉得太困难或耗费时间。</p>
<p>像达比一样,他们无疑是在到达最后一步的时候突然消失了!最后,他们放弃机器学习,说计算量非常大、非常困难或者认为自己的模型已经到达优化的临界点——真的是这样吗?</p>
<p>下面这些速查表能让这些“达比”成为机器学习的支持者。这是10个最常用的机器学习算法，这些算法使用了Python和R代码。考虑到机器学习在构建模型中的应用，这些速查表可以很好作为编码指南帮助你学好这些机器学习算法。Good Luck!</p>
<p><a href="http://discuss.analyticsvidhya.com/t/download-full-cheatsheet-on-machine-learning-algorithms/4063/1" target="_blank" rel="external">PDF版本</a><br><a id="more"></a><br><img src="1.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">Cheatsheet – Python &amp; R codes for common Machine Learning Algorithms</a><br>在拿破仑•希尔的名著《思考与致富》中讲述了达比的故事：达比经过几年的时间快要挖掘到了金矿，却在离它三英尺的地方离开了！</p>
<p>现在,我不知道这个故事是否真实。但是,我肯定在我的周围有一些跟达比一样的人，这些人认为，不管遇到什么问题, 机器学习的目的就是执行以及使用2 – 3组算法。他们不去尝试更好的算法和技术，因为他们觉得太困难或耗费时间。</p>
<p>像达比一样,他们无疑是在到达最后一步的时候突然消失了!最后,他们放弃机器学习,说计算量非常大、非常困难或者认为自己的模型已经到达优化的临界点——真的是这样吗?</p>
<p>下面这些速查表能让这些“达比”成为机器学习的支持者。这是10个最常用的机器学习算法，这些算法使用了Python和R代码。考虑到机器学习在构建模型中的应用，这些速查表可以很好作为编码指南帮助你学好这些机器学习算法。Good Luck!</p>
<p><a href="http://discuss.analyticsvidhya.com/t/download-full-cheatsheet-on-machine-learning-algorithms/4063/1" target="_blank" rel="external">PDF版本</a><br>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法精要(Python 和 R 代码)]]></title>
    <link href="http://colobu.com/2015/11/05/common-machine-learning-algorithms/"/>
    <id>http://colobu.com/2015/11/05/common-machine-learning-algorithms/</id>
    <published>2015-11-05T01:25:46.000Z</published>
    <updated>2015-11-05T02:31:42.071Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://www.analyticsvidhya.com" target="_blank" rel="external">analyticsvidhya</a>网站有一些非常好的机器学习的文章，这是其中的一篇。<br>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" target="_blank" rel="external">Essentials of Machine Learning Algorithms</a>,<br>国内有人翻译了，可以移步：<a href="http://blog.jobbole.com/92021/" target="_blank" rel="external">10 种机器学习算法的要点</a><br><a id="more"></a></p>
</blockquote>
<h3 id="Introduction">Introduction</h3>
<blockquote>
<p>Google’s self-driving cars and robots get a lot of press, but the company’s real future is in machine learning, the technology that enables computers to get smarter and more personal.</p>
<p>   – Eric Schmidt (Google Chairman)</p>
</blockquote>
<p>We are probably living in the most defining period of human history. The period when computing moved from large mainframes to PCs to cloud. But what makes it defining is not what has happened, but what is coming our way in years to come.</p>
<p>What makes this period exciting for some one like me is the democratization of the tools and techniques, which followed the boost in computing. Today, as a data scientist, I can build data crunching machines with complex algorithms for a few dollors per hour. But, reaching here wasn’t easy! I had my dark days and nights.</p>
<h3 id="Who_can_benefit_the_most_from_this_guide?">Who can benefit the most from this guide?</h3>
<p><strong>What I am giving out today is probably the most valuable guide, I have ever created.</strong><br>(这一篇指南，可能是我写过的最有价值的指南)</p>
<p>The idea behind creating this guide is to simplify the journey of aspiring data scientists and machine learning enthusiasts across the world. Through this guide, I will enable you to work on machine learning problems and gain from experience. <strong>I am providing a high level understanding about various machine learning algorithms along with R &amp; Python codes to run them. These should be sufficient to get your hands dirty.</strong><br><img src="1.jpg" alt=""><br>I have deliberately skipped the statistics behind these techniques, as you don’t need to understand them at the start. So, if you are looking for statistical understanding of these algorithms, you should look elsewhere. But, if you are looking to equip yourself to start building machine learning project, you are in for a treat.</p>
<h3 id="Broadly,_there_are_3_types_of_Machine_Learning_Algorithms-">Broadly, there are 3 types of Machine Learning Algorithms..</h3>
<p><strong>1 Supervised Learning</strong><br>监督式学习<br><strong>How it works</strong>: This algorithm consist of a target / outcome variable (or dependent variable) which is to be predicted from a given set of predictors (independent variables). Using these set of variables, we generate a function that map inputs to desired outputs. The training process continues until the model achieves a desired level of accuracy on the training data. Examples of Supervised Learning: Regression, Decision Tree, Random Forest, KNN, Logistic Regression etc. (回归、决策树、随机森林、K–近邻算法、逻辑回归等)</p>
<p><strong>2 Unsupervised Learning</strong><br>非监督式学习<br><strong>How it works</strong>: In this algorithm, we do not have any target or outcome variable to predict / estimate.  It is used for clustering population in different groups, which is widely used for segmenting customers in different groups for specific intervention. Examples of Unsupervised Learning: Apriori algorithm, K-means. (关联算法, K–均值算法)</p>
<p><strong>3 Reinforcement Learning</strong><br>强化学习<br><strong>How it works</strong>:  Using this algorithm, the machine is trained to make specific decisions. It works this way: the machine is exposed to an environment where it trains itself continually using trial and error. This machine learns from past experience and tries to capture the best possible knowledge to make accurate business decisions. Example of Reinforcement Learning: Markov Decision Process</p>
<h3 id="List_of_Common_Machine_Learning_Algorithms">List of Common Machine Learning Algorithms</h3>
<p>Here is the list of commonly used machine learning algorithms. These algorithms can be applied to almost any data problem:</p>
<ol>
<li>Linear Regression (线性回归)</li>
<li>Logistic Regression (逻辑回归)</li>
<li>Decision Tree (决策树)</li>
<li>SVM (支持向量机)</li>
<li>Naive Bayes (朴素贝叶斯)</li>
<li>KNN (K最近邻算法)</li>
<li>K-Means (K均值算法)</li>
<li>Random Forest (随机森林算法)</li>
<li>Dimensionality Reduction Algorithms (降维算法)</li>
<li>Gradient Boost &amp; Adaboost</li>
</ol>
<h4 id="1_Linear_Regression">1 Linear Regression</h4>
<p>It is used to estimate real values (cost of houses, number of calls, total sales etc.) based on continuous variable(s). Here, we establish relationship between independent and dependent variables by fitting a best line. This best fit line is known as regression line and represented by a linear equation Y= a *X + b.</p>
<p>The best way to understand linear regression is to relive this experience of childhood. Let us say, you ask a child in fifth grade to arrange people in his class by increasing order of weight, without asking them their weights! What do you think the child will do? He / she would likely look (visually analyze) at the height and build of people and arrange them using a combination of these visible parameters. This is linear regression in real life! The child has actually figured out that height and build would be correlated to the weight by a relationship, which looks like the equation above.</p>
<p>In this equation:</p>
<ul>
<li>Y – Dependent Variable</li>
<li>a – Slope</li>
<li>X – Independent variable</li>
<li>b – Intercept</li>
</ul>
<p>These coefficients a and b are derived based on minimizing the sum of squared difference of distance between data points and regression line.</p>
<p>Look at the below example. Here we have identified the best fit line having linear equation <strong>y=0.2811x+13.9</strong>. Now using this equation, we can find the weight, knowing the height of a person.<br><img src="2.png" alt=""></p>
<p>Linear Regression is of mainly two types: Simple Linear Regression and Multiple Linear Regression. Simple Linear Regression is characterized by one independent variable. And, Multiple Linear Regression(as the name suggests) is characterized by multiple (more than 1) independent variables. While finding best fit line, you can fit a polynomial or curvilinear regression. And these are known as polynomial or curvilinear regression.</p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="comment">#Import other necessary libraries like pandas, numpy...</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</div><div class="line"><span class="comment">#Load Train and Test datasets</span></div><div class="line"><span class="comment">#Identify feature and response variable(s) and values must be numeric and numpy arrays</span></div><div class="line">x_train=input_variables_values_training_datasets</div><div class="line">y_train=target_variables_values_training_datasets</div><div class="line">x_test=input_variables_values_test_datasets</div><div class="line"><span class="comment"># Create linear regression object</span></div><div class="line">linear = linear_model.LinearRegression()</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">linear.fit(x_train, y_train)</div><div class="line">linear.score(x_train, y_train)</div><div class="line"><span class="comment">#Equation coefficient and Intercept</span></div><div class="line">print(<span class="string">'Coefficient: \n'</span>, linear.coef_)</div><div class="line">print(<span class="string">'Intercept: \n'</span>, linear.intercept_)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= linear.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong><em>R</em></strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Load Train and Test datasets</span></div><div class="line"><span class="comment">#Identify feature and response variable(s) and values must be numeric and numpy arrays</span></div><div class="line">x_train &lt;- input_variables_values_training_datasets</div><div class="line">y_train &lt;- target_variables_values_training_datasets</div><div class="line">x_test &lt;- input_variables_values_test_datasets</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">linear &lt;- lm(y_train ~ ., data = x)</div><div class="line">summary(linear)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= predict(linear,x_test)</div></pre></td></tr></table></figure>

<h4 id="2_Logistic_Regression">2 Logistic Regression</h4>
<p>Don’t get confused by its name! It is a classification not a regression algorithm. It is used to estimate discrete values ( Binary values like 0/1, yes/no, true/false ) based on given set of independent variable(s). In simple words, it predicts the probability of occurrence of an event by fitting data to a logit function. Hence, it is also known as <strong>logit regression</strong>. Since, it predicts the probability, its output values lies between 0 and 1 (as expected).</p>
<p>Again, let us try and understand this through a simple example.</p>
<p>Let’s say your friend gives you a puzzle to solve. There are only 2 outcome scenarios – either you solve it or you don’t. Now imagine, that you are being given wide range of puzzles / quizzes in an attempt to understand which subjects you are good at. The outcome to this study would be something like this – if you are given a trignometry based tenth grade problem, you are 70% likely to solve it. On the other hand, if it is grade fifth history question, the probability of getting an answer is only 30%. This is what Logistic Regression provides you.</p>
<p>Coming to the math, the log odds of the outcome is modeled as a linear combination of the predictor variables.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dds= p/ (<span class="number">1</span>-p) = probability <span class="keyword">of</span> event occurrence / probability <span class="keyword">of</span> <span class="keyword">not</span> event occurrence</div><div class="line"><span class="function"><span class="title">ln</span><span class="params">(odds)</span> = <span class="title">ln</span><span class="params">(p/(<span class="number">1</span>-p)</span>)</span></div><div class="line"><span class="title">logit</span><span class="params">(p)</span> = <span class="title">ln</span><span class="params">(p/(<span class="number">1</span>-p)</span>) = <span class="title">b0</span>+<span class="title">b1X1</span>+<span class="title">b2X2</span>+<span class="title">b3X3</span>....+<span class="title">bkXk</span></div></pre></td></tr></table></figure>

<p>Above, p is the probability of presence of the characteristic of interest. It chooses parameters that maximize the likelihood of observing the sample values rather than that minimize the sum of squared errors (like in ordinary regression).</p>
<p>Now, you may ask, why take a log? For the sake of simplicity, let’s just say that this is one of the best mathematical way to replicate a step function. I can go in more details, but that will beat the purpose of this article.<br><img src="3.png" alt=""></p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create logistic regression object</span></div><div class="line">model = LogisticRegression()</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line">model.score(X, y)</div><div class="line"><span class="comment">#Equation coefficient and Intercept</span></div><div class="line">print(<span class="string">'Coefficient: \n'</span>, model.coef_)</div><div class="line">print(<span class="string">'Intercept: \n'</span>, model.intercept_)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">logistic &lt;- glm(y_train ~ ., data = x,family=<span class="string">'binomial'</span>)</div><div class="line">summary(logistic)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= predict(logistic,x_test)</div></pre></td></tr></table></figure>

<p><strong>Furthermore...</strong></p>
<p>There are many different steps that could be tried in order to improve the model:</p>
<ul>
<li>including interaction terms</li>
<li>removing features</li>
<li>regularization techniques</li>
<li>using a non-linear model</li>
</ul>
<h4 id="3_Decision_Tree">3 Decision Tree</h4>
<p>This is one of my favorite algorithm and I use it quite frequently. It is a type of supervised learning algorithm that is mostly used for classification problems. Surprisingly, it works for both categorical and continuous dependent variables. In this algorithm, we split the population into two or more homogeneous sets. This is done based on most significant attributes/ independent variables to make as distinct groups as possible. For more details, you can read: <a href="http://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="external">Decision Tree Simplified</a>.<br><img src="4.png" alt=""><br>In the image above, you can see that population is classified into four different groups based on multiple attributes to identify ‘if they will play or not’. To split the population into different heterogeneous groups, it uses various techniques like Gini, Information Gain, Chi-square, entropy.</p>
<p>The best way to understand how decision tree works, is to play Jezzball – a classic game from Microsoft (image below). Essentially, you have a room with moving walls and you need to create walls such that maximum area gets cleared off with out the balls.<br><img src="5.jpg" alt=""><br>So, every time you split the room with a wall, you are trying to create 2 different populations with in the same room. Decision trees work in very similar fashion by dividing a population in as different groups as possible.</p>
<p>More: <a href="http://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="external">Simplified Version of Decision Tree Algorithms</a></p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="comment">#Import other necessary libraries like pandas, numpy...</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create tree object </span></div><div class="line">model = tree.DecisionTreeClassifier(criterion=<span class="string">'gini'</span>) <span class="comment"># for classification, here you can change the algorithm as gini or entropy (information gain) by default it is gini  </span></div><div class="line"><span class="comment"># model = tree.DecisionTreeRegressor() for regression</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line">model.score(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rpart)</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># grow tree </span></div><div class="line">fit &lt;- rpart(y_train ~ ., data = x,method=<span class="string">"class"</span>)</div><div class="line">summary(fit)</div><div class="line"><span class="comment">#Predict Output </span></div><div class="line">predicted= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="4_SVM_(Support_Vector_Machine)">4 SVM (Support Vector Machine)</h4>
<p>It is a classification method. In this algorithm, we plot each data item as a point in n-dimensional space (where n is number of features you have) with the value of each feature being the value of a particular coordinate.</p>
<p>For example, if we only had two features like Height and Hair length of an individual, we’d first plot these two variables in two dimensional space where each point has two co-ordinates (these co-ordinates are known as <strong>Support Vectors</strong>)</p>
<p><img src="6.png" alt=""></p>
<p>Now, we will find some line that splits the data between the two differently classified groups of data. This will be the line such that the distances from the closest point in each of the two groups will be farthest away.<br><img src="7.png" alt=""></p>
<p>In the example shown above, the line which splits the data into two differently classified groups is the black line, since the two closest points are the farthest apart from the line. This line is our classifier. Then, depending on where the testing data lands on either side of the line, that’s what class we can classify the new data as.</p>
<p>More: <a href="http://www.analyticsvidhya.com/blog/2014/10/support-vector-machine-simplified/" target="_blank" rel="external">Simplified Version of Support Vector Machine</a></p>
<p><strong>Think of this algorithm as playing JezzBall in n-dimensional space. The tweaks in the game are:</strong></p>
<ul>
<li>You can draw lines / planes at any angles (rather than just horizontal or vertical as in classic game)</li>
<li>The objective of the game is to segregate balls of different colors in different rooms.</li>
<li>And the balls are not moving.</li>
</ul>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create SVM classification object </span></div><div class="line">model = svm.svc() <span class="comment"># there is various option associated with it, this is simple for classification. You can refer link, for mo# re detail.</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line">model.score(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(e1071)</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Fitting model</span></div><div class="line">fit &lt;-svm(y_train ~ ., data = x)</div><div class="line">summary(fit)</div><div class="line"><span class="comment">#Predict Output </span></div><div class="line">predicted= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="5_Naive_Bayes">5 Naive Bayes</h4>
<p>It is a classification technique based on Bayes’ theorem with an assumption of independence between predictors. In simple terms, a Naive Bayes classifier assumes that the presence of a particular feature in a class is unrelated to the presence of any other feature. For example, a fruit may be considered to be an apple if it is red, round, and about 3 inches in diameter. Even if these features depend on each other or upon the existence of the other features, a naive Bayes classifier would consider all of these properties to independently contribute to the probability that this fruit is an apple.</p>
<p>Naive Bayesian model is easy to build and particularly useful for very large data sets. Along with simplicity, Naive Bayes is known to outperform even highly sophisticated classification methods.</p>
<p>Bayes theorem provides a way of calculating posterior probability P(c|x) from P(c), P(x) and P(x|c). Look at the equation below:<br><img src="8.png" alt=""><br>Here,</p>
<ul>
<li>P(c|x) is the posterior probability of class (target) given predictor (attribute). </li>
<li>P(c) is the prior probability of class. </li>
<li>P(x|c) is the likelihood which is the probability of predictor given class. </li>
<li>P(x) is the prior probability of predictor.</li>
</ul>
<p><strong>Example</strong>: Let’s understand it using an example. Below I have a training data set of weather and corresponding target variable ‘Play’. Now, we need to classify whether players will play or not based on weather condition. Let’s follow the below steps to perform it.</p>
<p>Step 1: Convert the data set to frequency table</p>
<p>Step 2: Create Likelihood table by finding the probabilities like Overcast probability = 0.29 and probability of playing is 0.64.<br><img src="9.png" alt=""></p>
<p>Step 3: Now, use Naive Bayesian equation to calculate the posterior probability for each class. The class with the highest posterior probability is the outcome of prediction.</p>
<p><strong>Problem</strong>: Players will pay if weather is sunny, is this statement is correct?</p>
<p>We can solve it using above discussed method, so P(Yes | Sunny) = P( Sunny | Yes) * P(Yes) / P (Sunny)</p>
<p>Here we have P (Sunny |Yes) = 3/9 = 0.33, P(Sunny) = 5/14 = 0.36, P( Yes)= 9/14 = 0.64</p>
<p>Now, P (Yes | Sunny) = 0.33 * 0.64 / 0.36 = 0.60, which has higher probability.</p>
<p>Naive Bayes uses a similar method to predict the probability of different class based on various attributes. This algorithm is mostly used in text classification and with problems having multiple classes.</p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create SVM classification object model = GaussianNB() # there is other distribution for multinomial classes like Bernoulli Naive Bayes, Refer link</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">library</span>(e1071)</div><div class="line"><span class="title">x</span> &lt;- cbind(x_train,y_train)</div><div class="line"><span class="preprocessor"># Fitting model</span></div><div class="line"><span class="title">fit</span> &lt;-naiveBayes(y_train ~ ., <span class="typedef"><span class="keyword">data</span> = x)</span></div><div class="line"><span class="title">summary</span>(fit)</div><div class="line"><span class="preprocessor">#Predict Output </span></div><div class="line"><span class="title">predicted</span>= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="6_KNN_(K-_Nearest_Neighbors)">6 KNN (K- Nearest Neighbors)</h4>
<p>It can be used for both classification and regression problems. However, it is more widely used in classification problems in the industry. K nearest neighbors is a simple algorithm that stores all available cases and classifies new cases by a majority vote of its k neighbors. The case being assigned to the class is most common amongst its K nearest neighbors measured by a distance function.</p>
<p>These distance functions can be Euclidean, Manhattan, Minkowski and Hamming distance. First three functions are used for continuous function and fourth one (Hamming) for categorical variables. If K = 1, then the case is simply assigned to the class of its nearest neighbor. At times, choosing K turns out to be a challenge while performing KNN modeling.</p>
<p>More: <a href="http://Introduction to k-nearest neighbors : Simplified" target="_blank" rel="external">Introduction to k-nearest neighbors : Simplified.</a><br><img src="10.png" alt=""><br>KNN can easily be mapped to our real lives. If you want to learn about a person, of whom you have no information, you might like to find out about his close friends and the circles he moves in and gain access to his/her information!<br>Things to consider before selecting KNN:</p>
<ul>
<li>KNN is computationally expensive</li>
<li>Variables should be normalized else higher range variables can bias it</li>
<li>Works on pre-processing stage more before going for KNN like outlier, noise removal</li>
</ul>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create KNeighbors classifier object model </span></div><div class="line">KNeighborsClassifier(n_neighbors=<span class="number">6</span>) <span class="comment"># default value for n_neighbors is 5</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">library</span>(knn)</div><div class="line"><span class="title">x</span> &lt;- cbind(x_train,y_train)</div><div class="line"><span class="preprocessor"># Fitting model</span></div><div class="line"><span class="title">fit</span> &lt;-knn(y_train ~ ., <span class="typedef"><span class="keyword">data</span> = x,k=5)</span></div><div class="line"><span class="title">summary</span>(fit)</div><div class="line"><span class="preprocessor">#Predict Output </span></div><div class="line"><span class="title">predicted</span>= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="7_K-Means">7 K-Means</h4>
<p>It is a type of unsupervised algorithm which  solves the clustering problem. Its procedure follows a simple and easy  way to classify a given data set through a certain number of  clusters (assume k clusters). Data points inside a cluster are homogeneous and heterogeneous to peer groups.</p>
<p>Remember figuring out shapes from ink blots? k means is somewhat similar this activity. You look at the shape and spread to decipher how many different clusters / population are present!<br><img src="11.jpg" alt=""></p>
<p><strong>How K-means forms cluster:</strong></p>
<ol>
<li>K-means picks k number of points for each cluster known as centroids.</li>
<li>Each data point forms a cluster with the closest centroids i.e. k clusters.</li>
<li>Finds the centroid of each cluster based on existing cluster members. Here we have new centroids.</li>
<li>As we have new centroids, repeat step 2 and 3. Find the closest distance for each data point from new centroids and get associated with new k-clusters. Repeat this process until convergence occurs i.e. centroids does not change.</li>
</ol>
<p><strong>How to determine value of K:</strong><br>In K-means, we have clusters and each cluster has its own centroid. Sum of square of difference between centroid and the data points within a cluster constitutes within sum of square value for that cluster. Also, when the sum of square values for all the clusters are added, it becomes total within sum of square value for the cluster solution.</p>
<p>We know that as the number of cluster increases, this value keeps on decreasing but if you plot the result you may see that the sum of squared distance decreases sharply up to some value of k, and then much more slowly after that. Here, we can find the optimum number of cluster.<br><img src="12.png" alt=""><br><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</div><div class="line"><span class="comment">#Assumed you have, X (attributes) for training data set and x_test(attributes) of test_dataset</span></div><div class="line"><span class="comment"># Create KNeighbors classifier object model </span></div><div class="line">k_means = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">0</span>)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(<span class="keyword">cluster</span>)</div><div class="line">fit &lt;- kmeans(X, 3) # 5 <span class="keyword">cluster</span> solution</div></pre></td></tr></table></figure>

<h4 id="8_Random_Forest">8 Random Forest</h4>
<p>Random Forest is a trademark term for an ensemble of decision trees. In Random Forest, we’ve collection of decision trees (so known as “Forest”). To classify a new object based on attributes, each tree gives a classification and we say the tree “votes” for that class. The forest chooses the classification having the most votes (over all the trees in the forest).</p>
<p>Each tree is planted &amp; grown as follows:</p>
<ol>
<li>If the number of cases in the training set is N, then sample of N cases is taken at random but with replacement. This sample will be the training set for growing the tree.</li>
<li>If there are M input variables, a number m&lt;&lt;M is specified such that at each node, m variables are selected at random out of the M and the best split on these m is used to split the node. The value of m is held constant during the forest growing.</li>
<li>Each tree is grown to the largest extent possible. There is no pruning.</li>
</ol>
<p>For more details on this algorithm, comparing with decision tree and tuning model parameters, I would suggest you to read these articles:</p>
<ol>
<li><a href="http://www.analyticsvidhya.com/blog/2014/06/introduction-random-forest-simplified/" target="_blank" rel="external">Introduction to Random forest – Simplified</a></li>
<li><a href="http://www.analyticsvidhya.com/blog/2014/06/comparing-cart-random-forest-1/" target="_blank" rel="external">Comparing a CART model to Random Forest (Part 1)</a></li>
<li><a href="http://www.analyticsvidhya.com/blog/2014/06/comparing-random-forest-simple-cart-model/" target="_blank" rel="external">Comparing a Random Forest to a CART model (Part 2)</a></li>
<li><a href="http://www.analyticsvidhya.com/blog/2015/06/tuning-random-forest-model/" target="_blank" rel="external">Tuning the parameters of your Random Forest model</a></li>
</ol>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create Random Forest object</span></div><div class="line">model= RandomForestClassifier()</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">library</span>(randomForest)</div><div class="line"><span class="title">x</span> &lt;- cbind(x_train,y_train)</div><div class="line"><span class="preprocessor"># Fitting model</span></div><div class="line"><span class="title">fit</span> &lt;- randomForest(<span class="type">Species</span> ~ ., x,ntree=<span class="number">500</span>)</div><div class="line"><span class="title">summary</span>(fit)</div><div class="line"><span class="preprocessor">#Predict Output </span></div><div class="line"><span class="title">predicted</span>= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="9_Dimensionality_Reduction_Algorithms">9 Dimensionality Reduction Algorithms</h4>
<p>In the last 4-5 years, there has been an exponential increase in data capturing at every possible stages. Corporates/ Government Agencies/ Research organisations are not only coming with new sources but also they are capturing data in great detail.</p>
<p>For example: E-commerce companies are capturing more details about customer like their demographics, web crawling history, what they like or dislike, purchase history, feedback and many others to give them personalized attention more than your nearest grocery shopkeeper.</p>
<p>As a data scientist, the data we are offered also consist of many features, this sounds good for building good robust model but there is a challenge. How’d you identify highly significant variable(s) out 1000 or 2000? In such cases, dimensionality reduction algorithm helps us along with various other algorithms like Decision Tree, Random Forest, PCA, Factor Analysis, Identify based on correlation matrix, missing value ratio and others.</p>
<p>To know more about this algorithms, you can read <a href="http://www.analyticsvidhya.com/blog/2015/07/dimension-reduction-methods/" target="_blank" rel="external">“Beginners Guide To Learn Dimension Reduction Techniques“</a>.</p>
<p><strong>Python  Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> decomposition</div><div class="line"><span class="comment">#Assumed you have training and test data set as train and test</span></div><div class="line"><span class="comment"># Create PCA obeject pca= decomposition.PCA(n_components=k) #default value of k =min(n_sample, n_features)</span></div><div class="line"><span class="comment"># For Factor analysis</span></div><div class="line"><span class="comment">#fa= decomposition.FactorAnalysis()</span></div><div class="line"><span class="comment"># Reduced the dimension of training dataset using PCA</span></div><div class="line">train_reduced = pca.fit_transform(train)</div><div class="line"><span class="comment">#Reduced the dimension of test dataset</span></div><div class="line">test_reduced = pca.transform(test)</div><div class="line"><span class="comment">#For more detail on this, please refer  this link.</span></div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">library</span><span class="params">(stats)</span></span></div><div class="line"><span class="title">pca</span> &lt;- <span class="title">princomp</span><span class="params">(train, cor = <span class="variable">TRUE</span>)</span></div><div class="line"><span class="title">train_reduced</span>  &lt;- <span class="title">predict</span><span class="params">(pca,train)</span></div><div class="line"><span class="title">test_reduced</span>  &lt;- <span class="title">predict</span><span class="params">(pca,test)</span></div></pre></td></tr></table></figure>

<h4 id="10_Gradient_Boosting_&amp;_AdaBoost">10 Gradient Boosting &amp; AdaBoost</h4>
<p>GBM &amp; AdaBoost are boosting algorithms used when we deal with plenty of data to make a prediction with high prediction power. Boosting is an ensemble learning algorithm which combines the prediction of several base estimators in order to improve robustness over a single estimator. It combines multiple weak or average predictors to a build strong predictor. These boosting algorithms always work well in data science competitions like Kaggle, AV Hackathon, CrowdAnalytix.</p>
<p>More: <a href="http://www.analyticsvidhya.com/blog/2015/05/boosting-algorithms-simplified/" target="_blank" rel="external">Know about Gradient and AdaBoost in detail</a></p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create Gradient Boosting Classifier object</span></div><div class="line">model= GradientBoostingClassifier(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">1.0</span>, max_depth=<span class="number">1</span>, random_state=<span class="number">0</span>)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">library(caret)</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Fitting model</span></div><div class="line">fitControl &lt;- trainControl( <span class="keyword">method</span> = <span class="string">"repeatedcv"</span>, number = <span class="number">4</span>, repeats = <span class="number">4</span>)</div><div class="line">fit &lt;- train(y ~ ., data = x, <span class="keyword">method</span> = <span class="string">"gbm"</span>, trControl = fitControl,verbose = <span class="type">FALSE</span>)</div><div class="line">predicted= predict(fit,x_test,<span class="keyword">type</span>= <span class="string">"prob"</span>)[,<span class="number">2</span>]</div></pre></td></tr></table></figure>

<p>GradientBoostingClassifier and Random Forest are two different boosting tree classifier and often people ask about <a href="http://discuss.analyticsvidhya.com/t/what-is-the-fundamental-difference-between-randomforest-and-gradient-boosting-algorithms/2341" target="_blank" rel="external">the difference between these two algorithms</a>.</p>
<h4 id="End_Notes">End Notes</h4>
<p>By now, I am sure, you would have an idea of commonly used machine learning algorithms. My sole intention behind writing this article and providing the codes in R and Python is to get you started right away. If you are keen to master machine learning, start right away. Take up problems, develop a physical understanding of the process, apply these codes and see the fun!</p>
<p>Did you find this article useful ? Share your views and opinions in the comments section below.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><a href="http://www.analyticsvidhya.com" target="_blank" rel="external">analyticsvidhya</a>网站有一些非常好的机器学习的文章，这是其中的一篇。<br>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" target="_blank" rel="external">Essentials of Machine Learning Algorithms</a>,<br>国内有人翻译了，可以移步：<a href="http://blog.jobbole.com/92021/" target="_blank" rel="external">10 种机器学习算法的要点</a><br>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go开发一个 Slack 运维机器人]]></title>
    <link href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/"/>
    <id>http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/</id>
    <published>2015-11-04T04:31:01.000Z</published>
    <updated>2015-11-09T01:36:20.452Z</updated>
    <content type="html"><![CDATA[<p>受湾区日报的自动化机器人启发：<a href="https://wanqu.co/blog/2015-08-19-slack-hubot.html" target="_blank" rel="external">湾区日报的第一个“员工”：Slack/Hubot</a>， 我决定为自己的 side project 写一个自动化的slack运维机器人。</p>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>是一个搜集高质量技术文章的网站。主要是由爬虫到一些技术站点寻找关注度高的技术文章，以及一些技术聚合站点的高质量的文章，我也会发一些平常自己看到的技术文章。uriDB也允许用户注册发布文章。</p>
<p>因为这是自己的 side project, 我不会将精力全部放在这个项目上。 如果有一个机器人，可以方便的维护这个站点，那么可以极大减少我的工作量。</p>
<p>这个网站后台完全是由 Go 开发的，所以我还是想用Golang实现这个机器人，而没有采用<a href="https://hubot.github.com/" target="_blank" rel="external">hubot</a> + <a href="https://github.com/slackhq/hubot-slack" target="_blank" rel="external">hubot-slack</a>。</p>
<p>目前这个机器人实现了基本的功能：</p>
<ul>
<li>发表一个文章链接</li>
<li>修改文章的元数据</li>
<li>删除文章</li>
<li>分析一个文章链接</li>
</ul>
<p>有时间我会将服务器性能监控等功能加上。</p>
<a id="more"></a>
<h3 id="关于Slack">关于Slack</h3>
<p>Slack创始人是Stewart Butterfield，他在2009年创立游戏制作商Tiny Speck，之后联合创立了图片分享网站Flickr。13年他开始转型做Slack，这款产品13年8月内测，14年2月公测。2014年4月，正式推出不到三个月，Slack就已融资4275万美元。2014年10月，融资1.2亿美元，估值达11.2亿美元，成为了有史以来发展最快的 SaaS 公司。<br>本质上，Slack是一个企业内部沟通协作平台。提供了 Web 端，IOS 端和 Android 端的访问。</p>
<p>我们公司先前用hipchat,被<strong>comcast</strong>收购后开始改用slack。</p>
<p>Slack提供了机器人的功能，而且提供了清晰简单的API接口，这一点在实时通讯工具中值得称赞。人们可以使用各种语言实现各种各样的机器人和插件。你可以查看<a href="https://api.slack.com/community" target="_blank" rel="external">Community-built Integrations</a>，文章中列出了各种语言的插件和SDK。</p>
<p>我使用<a href="https://github.com/nlopes/slack" target="_blank" rel="external">nlopes/slack</a>来实现我的机器人。</p>
<p>第一步，你首先创建一个Team，并且加入到这个Team中。这是使用Slack的第一步。以后你可以直接访问http://<your team="">.slack.com登录到你的team中。</your></p>
<p>第二步，新建一个<a href="https://my.slack.com/services/new/bot" target="_blank" rel="external">bot user integration</a>。你需要为你的机器人起一个名字，比如我称我的机器人为 mybot。好像不支持中文，本来我想叫她&quot;小冰&quot;的。<br>可以为它指定头像，slack会为它生成一个 API Token。 这个API Token很重要， 以后访问slack API需要传入这个token。<br>slack提供乐意个简化的访问API的认证，你可以不使用oauth2的方式获取access token实现认证。而是直接获得api token访问API。<br>你也可以为你的普通登录用户生成full-access token，网址是: <a href="https://api.slack.com/web。" target="_blank" rel="external">https://api.slack.com/web。</a> </p>
<p>第三步，将你创建的bot加入到一个channel中。 比如我创建一个管理uridb网站的channel,将这个机器人邀请进来：<br><img src="1.png" alt=""></p>
<p>现在准备工作完成了。你可以在这个channel聊天了，但是这个机器人无动于衷，因为你还未实现它的逻辑。</p>
<h3 id="使用_Go_实现这个机器人">使用 Go 实现这个机器人</h3>
<p>创建一个 Go 项目， 并引入<a href="https://github.com/nlopes/slack" target="_blank" rel="external">nlopes/slack</a>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/nlopes/slack</div></pre></td></tr></table></figure>

<p>这个库访问slack api超级简单， 如下面访问用户信息的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/nlopes/slack"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    api := slack.New(<span class="string">"YOUR_TOKEN_HERE"</span>)</div><div class="line">    user, err := api.GetUserInfo(<span class="string">"U023BECGF"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Printf(<span class="string">"%s\n"</span>, err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    fmt.Printf(<span class="string">"ID: %s, Fullname: %s, Email: %s\n"</span>, user.ID, user.Profile.RealName, user.Profile.Email)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为我们要机器人实时接受指令，需要访问 <a href="https://api.slack.com/rtm" target="_blank" rel="external">Real Time Messaging API</a>， 它是通过websocket实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/nlopes/slack"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	api := slack.New(<span class="string">"YOUR TOKEN HERE"</span>)</div><div class="line">	api.SetDebug(<span class="constant">true</span>)</div><div class="line"></div><div class="line">	rtm := api.NewRTM()</div><div class="line">	<span class="keyword">go</span> rtm.ManageConnection()</div><div class="line"></div><div class="line">Loop:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> msg := &lt;-rtm.IncomingEvents:</div><div class="line">			fmt.Print(<span class="string">"Event Received: "</span>)</div><div class="line">			<span class="keyword">switch</span> ev := msg.Data.(<span class="keyword">type</span>) {</div><div class="line">			<span class="keyword">case</span> *slack.HelloEvent:</div><div class="line">				<span class="comment">// Ignore hello</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.ConnectedEvent:</div><div class="line">				fmt.Println(<span class="string">"Infos:"</span>, ev.Info)</div><div class="line">				fmt.Println(<span class="string">"Connection counter:"</span>, ev.ConnectionCount)</div><div class="line">				<span class="comment">// Replace #general with your Channel ID</span></div><div class="line">				rtm.SendMessage(rtm.NewOutgoingMessage(<span class="string">"Hello world"</span>, <span class="string">"#general"</span>))</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.MessageEvent:</div><div class="line">				fmt.Printf(<span class="string">"Message: %v\n"</span>, ev)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.PresenceChangeEvent:</div><div class="line">				fmt.Printf(<span class="string">"Presence Change: %v\n"</span>, ev)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.LatencyReport:</div><div class="line">				fmt.Printf(<span class="string">"Current latency: %v\n"</span>, ev.Value)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.RTMError:</div><div class="line">				fmt.Printf(<span class="string">"Error: %s\n"</span>, ev.Error())</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.InvalidAuthEvent:</div><div class="line">				fmt.Printf(<span class="string">"Invalid credentials"</span>)</div><div class="line">				<span class="keyword">break</span> Loop</div><div class="line"></div><div class="line">			<span class="keyword">default</span>:</div><div class="line"></div><div class="line">				<span class="comment">// Ignore other events..</span></div><div class="line">				<span class="comment">// fmt.Printf("Unexpected: %v\n", msg.Data)</span></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最重要的是 <code>case *slack.MessageEvent:</code>，这里会接收到实时的消息。 我们可以判断消息是否来自我们定制的channel，以及指令是否是对机器人发出的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">			<span class="keyword">case</span> *slack.MessageEvent:</div><div class="line">				<span class="keyword">if</span> ev.Channel == channelID && ev.Team == teamID {</div><div class="line">					msg := ev.Text					</div><div class="line">					</div><div class="line">					sendToMyBot := checkMessage(msg)</div><div class="line">					</div><div class="line">					<span class="keyword">if</span> sendToMyBot {</div><div class="line">						<span class="keyword">go</span> handleCommand(msg)</div><div class="line">					}</div><div class="line"></div><div class="line">				}</div><div class="line">...</div></pre></td></tr></table></figure>

<p>剩下的逻辑就是你去实现<code>handleCommand</code>，你可以实现各种各样的命令,如:<br><a rel="external" href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/2.png" title="" class="fancybox" target="_blank"><img data-bd-imgshare-binded="1" src="2.png" alt="" width="400px"></a><br><br><br><br><a rel="external" href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/3.png" title="" class="fancybox" target="_blank"><img data-bd-imgshare-binded="1" src="3.png" alt="" width="400px"></a></p>
<p>BTW:<br>增加了一个邪恶的功能，可以通过它远程执行linux命令，这样就可以运行命令查看服务器的状态，但是这个后门有点危险。<br><img src="4.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>受湾区日报的自动化机器人启发：<a href="https://wanqu.co/blog/2015-08-19-slack-hubot.html" target="_blank" rel="external">湾区日报的第一个“员工”：Slack/Hubot</a>， 我决定为自己的 side project 写一个自动化的slack运维机器人。</p>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>是一个搜集高质量技术文章的网站。主要是由爬虫到一些技术站点寻找关注度高的技术文章，以及一些技术聚合站点的高质量的文章，我也会发一些平常自己看到的技术文章。uriDB也允许用户注册发布文章。</p>
<p>因为这是自己的 side project, 我不会将精力全部放在这个项目上。 如果有一个机器人，可以方便的维护这个站点，那么可以极大减少我的工作量。</p>
<p>这个网站后台完全是由 Go 开发的，所以我还是想用Golang实现这个机器人，而没有采用<a href="https://hubot.github.com/" target="_blank" rel="external">hubot</a> + <a href="https://github.com/slackhq/hubot-slack" target="_blank" rel="external">hubot-slack</a>。</p>
<p>目前这个机器人实现了基本的功能：</p>
<ul>
<li>发表一个文章链接</li>
<li>修改文章的元数据</li>
<li>删除文章</li>
<li>分析一个文章链接</li>
</ul>
<p>有时间我会将服务器性能监控等功能加上。</p>
]]>
    
    </summary>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="slack" scheme="http://colobu.com/tags/slack/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Linux 上如何清除内存的 Cache、Buffer 和交换空间]]></title>
    <link href="http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/"/>
    <id>http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/</id>
    <published>2015-10-31T13:09:20.000Z</published>
    <updated>2015-10-31T13:30:33.911Z</updated>
    <content type="html"><![CDATA[<p>英文原文: <a href="http://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/" target="_blank" rel="external">How to Clear RAM Memory Cache, Buffer and Swap Space on Linux</a>,<br>中文翻译: <a href="https://linux.cn/article-5627-1.html" target="_blank" rel="external">在 Linux 上如何清除内存的 Cache、Buffer 和交换空间</a> by strugglingyouth<br>像任何其他的操作系统一样，GNU/Linux 已经实现的内存管理不仅有效，而且更好。但是，如果有任何进程正在蚕食你的内存，而你想要清除它的话，Linux 提供了一个刷新或清除RAM缓存方法。<br><img src="http://www.tecmint.com/wp-content/uploads/2015/05/Clear-RAM-Cache-in-Linux.jpg" alt=""><br><a id="more"></a></p>
<h3 id="如何在_Linux_中清除缓存（Cache）？">如何在 Linux 中清除缓存（Cache）？</h3>
<p>每个 Linux 系统有三种选项来清除缓存而不需要中断任何进程或服务。<br>（LCTT 译注：Cache，译作“缓存”，指 CPU 和内存之间高速缓存。Buffer，译作“缓冲区”，指在写入磁盘前的存储再内存中的内容。在本文中，Buffer 和 Cache 有时候会通指。）</p>
<ol>
<li>仅清除页面缓存（PageCache）</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sync; echo 1 &gt; /proc/sys/vm/drop_caches</span></div></pre></td></tr></table></figure>

<ol>
<li>清除目录项和inode</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sync; echo 2 &gt; /proc/sys/vm/drop_caches</span></div></pre></td></tr></table></figure>

<ol>
<li>清除页面缓存，目录项和inode</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sync; echo 3 &gt; /proc/sys/vm/drop_caches</span></div></pre></td></tr></table></figure>

<p>上述命令的说明：<br><code>sync</code>将刷新文件系统缓冲区（buffer），命令通过“;”分隔，顺序执行，shell在执行序列中的下一个命令之前会等待命令的终止。正如内核文档中提到的，写入到drop_cache将清空缓存而不会杀死任何应用程序/服务，<a href="http://www.tecmint.com/echo-command-in-linux/" target="_blank" rel="external">echo命令</a>做写入文件的工作。</p>
<p>如果你必须清除磁盘高速缓存，第一个命令在企业和生产环境中是最安全，&quot;...echo 1&gt; ...&quot;只会清除页面缓存。 在生产环境中不建议使用上面的第三个选项&quot;...echo 3 &gt; ...&quot; ，除非你明确自己在做什么，因为它会清除缓存页，目录项和inodes。</p>
<h4 id="在Linux上释放也许被内核所使用的缓冲区（Buffer）和缓存（Cache）是否是个好主意？">在Linux上释放也许被内核所使用的缓冲区（Buffer）和缓存（Cache）是否是个好主意？</h4>
<p>当你设置许多设定想要检查效果时，如果它实际上是专门针对 I/O 范围的基准测试，那么你可能需要清除缓冲区和缓存。你可以如上所示删除缓存，无需重新启动系统（即无需停机）。</p>
<p>Linux被设计成它在寻找磁盘之前到磁盘缓存寻找的方式。如果它发现该资源在缓存中，则该请求不会发送到磁盘。如果我们清理缓存，磁盘缓存就起不到作用了，系统会到磁盘上寻找资源。</p>
<p>此外，当清除缓存后它也将减慢系统运行速度，系统会将每一个被请求的资源再次加载到磁盘缓存中。</p>
<p>现在，我们将创建一个 shell 脚本，通过一个 cron 调度任务在每天下午2点自动清除RAM缓存。如下创建一个 shell 脚本 <em>clearcache.sh </em>并在其中添加以下行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment"># 注意，我们这里使用了 "echo 3"，但是不推荐使用在产品环境中，应该使用 "echo 1"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"echo 3 &gt; /proc/sys/vm/drop_caches"</span></div></pre></td></tr></table></figure>

<p>给<em>clearcache.sh</em>文件设置执行权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chmod 755 clearcache.sh</span></div></pre></td></tr></table></figure>

<p>现在，当你需要清除内存缓存时只需要调用脚本。</p>
<p>现在设置一个每天下午2点的定时任务来清除RAM缓存，打开crontab进行编辑。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># crontab -e</span></div></pre></td></tr></table></figure>

<p>添加以下行，保存并退出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> <span class="number">3</span> * * * /path/to/clearcache.sh</div></pre></td></tr></table></figure>

<p>有关如何创建一个定时任务，更多细节你可以查看我们的文章 <a href="http://www.tecmint.com/11-cron-scheduling-task-examples-in-linux/" target="_blank" rel="external">11 个定时调度任务的例子</a>。</p>
<h4 id="在生产环境的服务器上自动清除RAM是否是一个好主意？">在生产环境的服务器上自动清除RAM是否是一个好主意？</h4>
<p>不！它不是。想想一个情况，当你已经预定脚本在每天下午2点来清除内存缓存。那么其时该脚本会执行并刷新你的内存缓存。在某一天由于某些原因，可能您的网站的在线用户会超过预期地从你的服务器请求资源。</p>
<p>而在这时，按计划调度的脚本运行了，并清除了缓存中的一切。当所有的用户都从磁盘读取数据时，这将导致服务器崩溃并损坏数据库。因此，清除缓存仅在必要时并且在你的预料之中，否则你就是个呆瓜系统管理员。</p>
<h3 id="如何清除Linux的交换空间？">如何清除Linux的交换空间？</h3>
<p>如果你想清除掉Swap空间，你可以运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># swapoff -a && swapon -a</span></div></pre></td></tr></table></figure>

<p>此外，了解有关风险后，您可以将上面的命令添加到cron中。</p>
<p>现在，我们将上面两种命令结合成一个命令，写成正确的脚本来同时清除RAM缓存和交换空间。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches && swapoff -a && swapon -a && printf '\n%s\n' 'Ram-cache and Swap Cleared'</span></div></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su -c 'echo <span class="number">3</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches' && swapoff -a && swapon -a && printf '\n%s\n' '<span class="type">Ram</span>-cache <span class="keyword">and</span> <span class="type">Swap</span> <span class="type">Cleared</span>'</div></pre></td></tr></table></figure>

<p>在测试上面的命令之前，我们在执行脚本前后运行“free -m” 来检查缓存。<br>就是这样，如果你喜欢这篇文章，不要忘记向我们提供您宝贵的意见，让我们知道，您认为在企业和生产环境中清除内存缓存和缓冲区是否是一个好主意？</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2015/05/Clear-RAM-Cache.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原文: <a href="http://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/" target="_blank" rel="external">How to Clear RAM Memory Cache, Buffer and Swap Space on Linux</a>,<br>中文翻译: <a href="https://linux.cn/article-5627-1.html" target="_blank" rel="external">在 Linux 上如何清除内存的 Cache、Buffer 和交换空间</a> by strugglingyouth<br>像任何其他的操作系统一样，GNU/Linux 已经实现的内存管理不仅有效，而且更好。但是，如果有任何进程正在蚕食你的内存，而你想要清除它的话，Linux 提供了一个刷新或清除RAM缓存方法。<br><img src="http://www.tecmint.com/wp-content/uploads/2015/05/Clear-RAM-Cache-in-Linux.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎样在后台模式中登录一个docker容器的bash?]]></title>
    <link href="http://colobu.com/2015/10/30/How-to-get-bash-or-ssh-into-a-running-container-in-background-mode/"/>
    <id>http://colobu.com/2015/10/30/How-to-get-bash-or-ssh-into-a-running-container-in-background-mode/</id>
    <published>2015-10-30T02:22:15.000Z</published>
    <updated>2015-10-30T02:30:52.235Z</updated>
    <content type="html"><![CDATA[<p><a href="">Ask Ubuntu</a>上有人问怎么能login或者ssh一个运行的docker容器。<br>例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run <span class="operator">-d</span> webserver</div><div class="line">webserver is clean image from ubuntu:<span class="number">14.04</span></div><div class="line">$ <span class="built_in">sudo</span> docker ps</div><div class="line">CONTAINER ID  IMAGE            COMMAND    CREATED STATUS  PORTS          NAMES</div><div class="line"><span class="number">665</span>b4a1e17b6  webserver:latest /bin/bash  ...     ...     <span class="number">22</span>/tcp, <span class="number">80</span>/tcp loving_heisenberg</div></pre></td></tr></table></figure>

<p>想进行这样的登录:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run -t -i webserver (or maybe <span class="number">665</span>b4a1e17b6 instead)</div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment"># </span></div><div class="line">However when I run the line above I get new CONTAINER ID</div><div class="line">$ root@<span class="number">42</span>f1e37bd0e5:/<span class="comment">#</span></div></pre></td></tr></table></figure>

<a id="more"></a>
<p>答案是 <a href="https://docs.docker.com/reference/commandline/attach/" target="_blank" rel="external">attach</a>或者最新的<a href="https://docs.docker.com/reference/commandline/exec/" target="_blank" rel="external">exec</a></p>
<p>The answer is docker&#39;s <code>attach</code> command. So for my example above the solution will:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker attach <span class="number">665</span>b4a1e17b6 <span class="comment">#by ID</span></div><div class="line">or</div><div class="line">$ <span class="built_in">sudo</span> docker attach loving_heisenberg <span class="comment">#by Name</span></div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment">#</span></div></pre></td></tr></table></figure>

<p><strong>UPDATE: (docker &gt;= 1.3)</strong> Thanks to <strong>WiR3D</strong> user who suggested another way to get container&#39;s shell. If we use attach we can use only one instance of shell. So if we want open new terminal with new instance of container&#39;s shell, we just need run the following:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker <span class="keyword">exec</span> -i -t <span class="number">665</span>b4a1e17b6 bash <span class="comment">#by ID</span></div><div class="line">or</div><div class="line">$ <span class="built_in">sudo</span> docker <span class="keyword">exec</span> -i -t loving_heisenberg bash <span class="comment">#by Name</span></div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment">#</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="">Ask Ubuntu</a>上有人问怎么能login或者ssh一个运行的docker容器。<br>例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run <span class="operator">-d</span> webserver</div><div class="line">webserver is clean image from ubuntu:<span class="number">14.04</span></div><div class="line">$ <span class="built_in">sudo</span> docker ps</div><div class="line">CONTAINER ID  IMAGE            COMMAND    CREATED STATUS  PORTS          NAMES</div><div class="line"><span class="number">665</span>b4a1e17b6  webserver:latest /bin/bash  ...     ...     <span class="number">22</span>/tcp, <span class="number">80</span>/tcp loving_heisenberg</div></pre></td></tr></table></figure>

<p>想进行这样的登录:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run -t -i webserver (or maybe <span class="number">665</span>b4a1e17b6 instead)</div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment"># </span></div><div class="line">However when I run the line above I get new CONTAINER ID</div><div class="line">$ root@<span class="number">42</span>f1e37bd0e5:/<span class="comment">#</span></div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Docker" scheme="http://colobu.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动H5前端性能优化指南]]></title>
    <link href="http://colobu.com/2015/10/30/h5-performance/"/>
    <id>http://colobu.com/2015/10/30/h5-performance/</id>
    <published>2015-10-30T01:53:50.000Z</published>
    <updated>2015-10-30T02:10:03.938Z</updated>
    <content type="html"><![CDATA[<p>腾讯出品的前端性能优化指南： <a href="http://isux.tencent.com/h5-performance.html" target="_blank" rel="external">原文</a>,<br>另外比较知名的很早的一篇前端优化规则是Yahoo出品的，现在依然有效。 <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">Best Practices for Speeding Up Your Web Site</a>, 中文<a href="http://segmentfault.com/a/1190000000735395" target="_blank" rel="external">Yahoo前端优化性能规则</a></p>
<p>以下是腾讯的移动h5前端性能优化指南全文：<br><a id="more"></a><br><img src="html5.png" alt=""></p>
<h2 id="概述">概述</h2>
<ol>
<li>PC优化手段在Mobile侧同样适用</li>
<li>在Mobile侧我们提出<strong>三秒种渲染完成首屏指标</strong></li>
<li>基于第二点，首屏加载3秒完成或使用Loading</li>
<li>基于联通3G网络平均338KB/s(2.71Mb/s)，所以<strong>首屏资源不应超过1014KB</strong></li>
<li>Mobile侧因手机配置原因，除加载外渲染速度也是优化重点</li>
<li>基于第五点，要合理处理代码减少渲染损耗</li>
<li>基于第二、第五点，<strong>所有影响首屏加载和渲染的代码应在处理逻辑中后置</strong></li>
<li>加载完成后用户交互使用时也需注意性能</li>
</ol>
<h2 id="优化指南">优化指南</h2>
<h3 id="加载优化">加载优化</h3>
<p>加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点</p>
<h4 id="减少HTTP请求">减少HTTP请求</h4>
<p>因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个<br>a) 合并CSS、JavaScript<br>b) 合并小图片，使用雪碧图</p>
<h4 id="缓存">缓存</h4>
<p>使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）<br>a) 缓存一切可缓存的资源<br>b) 使用长Cache（使用时间戳更新Cache）<br>c) 使用外联式引用CSS、JavaScript</p>
<h4 id="压缩HTML、CSS、JavaScript">压缩HTML、CSS、JavaScript</h4>
<p>减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip<br>a) 压缩（例如，多余的空格、换行符和缩进）<br>b) 启用GZip</p>
<h4 id="无阻塞">无阻塞</h4>
<p>写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载</p>
<h4 id="使用首屏加载">使用首屏加载</h4>
<p>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化</p>
<h4 id="按需加载">按需加载</h4>
<p>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量<br>PS：按需加载会导致大量重绘，影响渲染性能<br>a) LazyLoad<br>b) 滚屏加载<br>c) 通过Media Query加载</p>
<h4 id="预加载">预加载</h4>
<p>大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失<br>对用户行为分析，可以在当前页加载下一页资源，提升速度<br>a) 可感知Loading(如进入空间游戏的Loading)<br>b) 不可感知的Loading（如提前加载下一页）</p>
<h4 id="压缩图片">压缩图片</h4>
<p>图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示<br>PS：过度压缩图片大小影响图片显示效果<br>a) 使用智图（ <a href="http://zhitu.tencent.com/" target="_blank" rel="external">http://zhitu.tencent.com/</a> ）<br>b) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)<br>c) 使用Srcset<br>d) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)<br>e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））</p>
<h4 id="减少Cookie">减少Cookie</h4>
<p>Cookie会影响加载速度，所以静态资源域名不使用Cookie</p>
<h4 id="避免重定向">避免重定向</h4>
<p>重定向会影响加载速度，所以在服务器正确设置避免重定向</p>
<h4 id="异步加载第三方资源">异步加载第三方资源</h4>
<p>第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源</p>
<h3 id="脚本执行优化">脚本执行优化</h3>
<p>脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意</p>
<h4 id="CSS写在头部，JavaScript写在尾部或异步">CSS写在头部，JavaScript写在尾部或异步</h4>
<h4 id="避免图片和iFrame等的空Src">避免图片和iFrame等的空Src</h4>
<p>空Src会重新加载当前页面，影响速度和效率</p>
<h4 id="尽量避免重设图片大小">尽量避免重设图片大小</h4>
<p>重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能</p>
<h4 id="图片尽量避免使用DataURL">图片尽量避免使用DataURL</h4>
<p>DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长</p>
<h3 id="CSS优化">CSS优化</h3>
<h4 id="尽量避免写在HTML标签中写Style属性">尽量避免写在HTML标签中写Style属性</h4>
<h4 id="避免CSS表达式">避免CSS表达式</h4>
<p>CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式</p>
<h4 id="移除空的CSS规则">移除空的CSS规则</h4>
<p>空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则</p>
<h4 id="正确使用Display的属性">正确使用Display的属性</h4>
<p>Display属性会影响页面的渲染，因此请合理使用<br>a) display:inline后不应该再使用width、height、margin、padding以及float<br>b) display:inline-block后不应该再使用float<br>c) display:block后不应该再使用vertical-align<br>d) display:table-*后不应该再使用margin或者float</p>
<h4 id="不滥用Float">不滥用Float</h4>
<p>Float在渲染时计算量比较大，尽量减少使用</p>
<h4 id="不滥用Web字体">不滥用Web字体</h4>
<p>Web字体需要下载，解析，重绘当前页面，尽量减少使用</p>
<h4 id="不声明过多的Font-size">不声明过多的Font-size</h4>
<p>过多的Font-size引发CSS树的效率</p>
<h4 id="值为0时不需要任何单位">值为0时不需要任何单位</h4>
<p>为了浏览器的兼容性和性能，值为0时不要带单位</p>
<h4 id="标准化各种浏览器前缀">标准化各种浏览器前缀</h4>
<p>a) 无前缀应放在最后<br>b) CSS动画只用 （-webkit- 无前缀）两种即可<br>c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）</p>
<h4 id="避免让选择符看起来像正则表达式">避免让选择符看起来像正则表达式</h4>
<p>高级选择器执行耗时长且不易读懂，避免使用</p>
<h3 id="JavaScript执行优化">JavaScript执行优化</h3>
<h4 id="减少重绘和回流">减少重绘和回流</h4>
<p>a) 避免不必要的Dom操作<br>b) 尽量改变Class而不是Style，使用classList代替className<br>c) 避免使用document.write<br>d) 减少drawImage</p>
<h4 id="缓存Dom选择与计算">缓存Dom选择与计算</h4>
<p>每次Dom选择都要计算，缓存他</p>
<h4 id="缓存列表-length">缓存列表.length</h4>
<p>每次.length都要计算，用一个变量保存这个值</p>
<h4 id="尽量使用事件代理，避免批量绑定事件">尽量使用事件代理，避免批量绑定事件</h4>
<h4 id="尽量使用ID选择器">尽量使用ID选择器</h4>
<p>ID选择器是最快的</p>
<h4 id="TOUCH事件优化">TOUCH事件优化</h4>
<p>使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作</p>
<h3 id="渲染优化">渲染优化</h3>
<h4 id="HTML使用Viewport">HTML使用Viewport</h4>
<p>Viewport可以加速页面的渲染，请使用以下代码</p>
<meta name="”viewport”" content="”width=device-width," initial-scale="1″">

<h4 id="减少Dom节点">减少Dom节点</h4>
<p>Dom节点太多影响页面的渲染，应尽量减少Dom节点</p>
<h4 id="动画优化">动画优化</h4>
<p>a) 尽量使用CSS3动画<br>b) 合理使用requestAnimationFrame动画代替setTimeout<br>c) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）</p>
<h4 id="高频事件优化">高频事件优化</h4>
<p>Touchmove、Scroll 事件可导致多次渲染<br>a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染<br>b) 增加响应变化的时间间隔，减少重绘次数</p>
<h4 id="GPU加速">GPU加速</h4>
<p>CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用<br>PS：过渡使用会引发手机过耗电增加</p>
<p><strong>参考资料</strong></p>
<ul><br><li><a target="_blank" href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201412/293834.shtml">移动页面性能优化</a></li><br><li><a target="_blank" href="https://github.com/cssmagic/blog/issues/20">[译]&nbsp;如何做到一秒渲染一个移动页面</a></li><br><li><a target="_blank" href="http://lists.w3.org/Archives/Public/public-html-ig-zh/2014May/0005.html">首屏渲染优化提案反馈（原：Re:&nbsp;答复:&nbsp;中文兴趣小组5月5日电话会议）</a></li><br><li><a target="_blank" href="http://isux.tencent.com/html5-game-development-cheats.html">HTML5游戏前端开发秘籍</a></li><br><li><a target="_blank" href="http://isux.tencent.com/emancipate-gpu.html">被解放的GPU</a></li><br><li><a target="_blank" href="http://s5s5.github.io/CSS-Animations/">CSS动画</a></li><br><li><a target="_blank" href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">High Performance Animations</a></li><br><li><a target="_blank" href="https://developers.google.com/speed/docs/insights/rules">PageSpeed Insights规则</a></li><br><li><a target="_blank" href="https://developer.yahoo.com/performance/rules.html">Best Practices for Speeding Up Your Web Site</a></li><br><li><a target="_blank" href="http://browserdiet.com/en/">How to lose weight (in the browser)</a></li><br><li><a target="_blank" href="http://nomospace.github.io/posts/css-lint.html">关注&nbsp;CSS Lint</a></li><br><li><a target="_blank" href="http://blog.91gaoqing.com/archives/146.html">HTML5应用开发功耗调优化小结</a></li><br><li><a target="_blank" href="http://blog.csdn.net/milado_nju/article/details/39271463">理解WebKit和Chromium: Chromium WebView和Chrome浏览器渲染机制</a></li><br><li><a target="_blank" href="https://developers.google.com/web/fundamentals/performance/">Optimizing Performance — Web Fundamentals</a></li><br><li><a target="_blank" href="http://www.w3cfuns.com/article-5601016-1-1.html">移动前端工作的那些事—前端制作之动画效率问题简析</a></li><br><li><a target="_blank" href="http://www.sitepoint.com/optimizing-critical-rendering-path/">Optimizing the Critical Rendering Path</a></li><br><li><a target="_blank" href="http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/">7&nbsp;天打造前端性能监控系统</a></li><br><li><a target="_blank" href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201411/291773.shtml">数据驱动设计</a></li><br><li><a target="_blank" href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201404/258325.shtml">为你的移动页面寻找一丝新意（技术篇）——手机互动网页项目总结（下）</a></li><br><li><a target="_blank" href="http://www.imageoptimization.info/">Image Optimization</a></li><br><li><a target="_blank" href="http://www.cnblogs.com/yexiaochai/p/3759959.html">[webapp的优化整理]要做移动前端优化的朋友进来看看吧</a></li><br><li><a target="_blank" href="http://www.egret-labs.org/blog/3097.html">Egret Framework Canvas Renderer性能优化</a></li><br><li><a target="_blank" href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">Roundup on Parallel Connections</a></li><br><li><a target="_blank" href="http://www.speedtest.cn/info/2014-8th">2014年第二季度全国网速实测报告</a></li><br></ul>]]></content>
    <summary type="html">
    <![CDATA[<p>腾讯出品的前端性能优化指南： <a href="http://isux.tencent.com/h5-performance.html" target="_blank" rel="external">原文</a>,<br>另外比较知名的很早的一篇前端优化规则是Yahoo出品的，现在依然有效。 <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">Best Practices for Speeding Up Your Web Site</a>, 中文<a href="http://segmentfault.com/a/1190000000735395" target="_blank" rel="external">Yahoo前端优化性能规则</a></p>
<p>以下是腾讯的移动h5前端性能优化指南全文：<br>]]>
    
    </summary>
    
      <category term="html5" scheme="http://colobu.com/tags/html5/"/>
    
      <category term="前端开发" scheme="http://colobu.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于Golang将MongoDB的数据同步到Elasticsearch]]></title>
    <link href="http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/"/>
    <id>http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/</id>
    <published>2015-10-27T08:49:45.000Z</published>
    <updated>2015-12-11T02:38:09.352Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.elastic.co/" target="_blank" rel="external">Elasticsearch</a>是一个分布式可扩展的实时搜索和分析引擎。它能帮助你搜索、分析和浏览数据。Elasticsearch 是一个基于Lucene实现的搜索服务器，用Java开发实现。它提供了RESTful web接口，并作为Apache许可条款下的开放源码发布，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>Elasticsearch关键概念</p>
<p><dl></dl></p>
<p><dt>Cluster集群</dt></p>
<dd>有相同集群名称的节点Node的集合。集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</dd><br><br><dt>Cluster集群</dt><br><dd></dd><br><dt>Node节点</dt><br><dd>一个elasticsearch运行的实例。其实就是一个java进程。一般情况下，一个节点运行在一台机器上。</dd><br><dt>Shards分片</dt><br><dd>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</dd><br><dt>Replicas副本</dt><br><dd>代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</dd><br><dt>Recovery恢复</dt><br><dd>代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</dd><br><dt>River</dt><br><dd>代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。River在1.5中弃用了，2.0中移除了。</dd><br><dt>Gateway</dt><br><dd>代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</dd><br><dt>Discovery.zen</dt><br><dd>代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过多播协议来进行节点之间的通信，同时也支持点对点的交互。</dd><br><dt>Transport</dt><br><dd>代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、thrift、servlet、memcached、zeroMQ等的传输协议（通过插件方式集成）。</dd><br><dt>Index索引</dt><br><dd>Elasticsearch用来存储数据的逻辑区域，它类似于关系型数据库中的table概念。一个index可以在一个或者多个shard上面，同时一个shard也可能会有多个replicas。</dd><br><dt>Document</dt><br><dd>Elasticsearch里面存储的实体数据，类似于关系数据中一个table里面的一行数据。 document由多个field组成，不同的document里面同名的field一定具有相同的类型。document里面field可以重复出现，也就是一个field会有多个值，即multivalued。</dd><br><dt>Document type</dt><br><dd>为了查询需要，一个index可能会有多种document，也就是document type，但需要注意，不同document里面同名的field一定要是相同类型的。</dd><br><dt>Mapping</dt><br><dd>存储field的相关映射信息，不同document type会有不同的mapping。</dd>

<a id="more"></a>
<p>本文不是介绍Elasticsearch的安装配置文档，这些文档你可以在本文的参考资料中获得， 而是笔者在项目中的实践笔记。<br>我最近在开发过程中需要将Mongo数据库中的文章进行索引， 避免直接对Mongo数据库进行搜索导致的性能降低。基于Elasticsearch的手册的描述，以及在一些大公司如twitter的应用的经验，我选用它作为现在的项目的索引服务器。</p>
<p>现在的项目是Golang语言实现的，所以我调研的目标放在了Golang + MongoDB + Elasticsearch上面。</p>
<p><a href="https://github.com/richardwilly98/elasticsearch-river-mongodb" target="_blank" rel="external">elasticsearch-river-mongodb</a>是一个针对Mongo的elasticsearch river的插件。它从Mongo oplog中读取信息，将Mongo集群中的数据导入到 elasticsearch 中。考虑到river被弃用，暂时不考虑这个方案。</p>
<p>mandeepm91在文章 <a href="https://www.digitalocean.com/community/tutorials/how-to-sync-transformed-data-from-mongodb-to-elasticsearch-with-transporter-on-ubuntu-14-04" target="_blank" rel="external">How To Sync Transformed Data from MongoDB to Elasticsearch with Transporter on Ubuntu 14.04</a>提到了另外一个工具 <a href="https://github.com/compose/transporter" target="_blank" rel="external">Transporter</a>,这是一个相当好的工具，可以抽取Mongo单例或者Mongo集群的数据，然后使用<a href="https://github.com/robertkrimen/otto" target="_blank" rel="external">otto框架</a>进行Javascript处理，而且处理是通道式的。在调研中很容易的将Mongo数据库导入到Elasticsearch。</p>
<p>不过我也没有采用这个方案。因为我的项目中，对文章的增删改的动作比较少，可以直接调用Elasticsearch的API进行操作。而且这样可以做到数据的实时索引和查询。</p>
<p>上面的方案多少会影响服务器的性能，有可能会block在Elasticsearch的API调用上。 所以我在增删改文章时，将操作命令的log放入到一个消息服务器中(<a href="https://github.com/nsqio/nsq" target="_blank" rel="external">nsq</a>或者<a href="http://kafka.apache.org/" target="_blank" rel="external">kafka</a>)，然后在单独的一台服务器上接收消息并调用Elasticsearch的API。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-sync-transformed-data-from-mongodb-to-elasticsearch-with-transporter-on-ubuntu-14-04" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-sync-transformed-data-from-mongodb-to-elasticsearch-with-transporter-on-ubuntu-14-04</a></li>
<li><a href="https://github.com/compose/transporter" target="_blank" rel="external">https://github.com/compose/transporter</a></li>
<li><a href="http://www.learnes.net/" target="_blank" rel="external">Elasticsearch 权威指南</a></li>
<li><a href="https://www.gitbook.com/book/endymecy/elasticsearch-guide-chinese/details" target="_blank" rel="external">elasticsearch中文指南</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html</a></li>
<li><a href="https://github.com/mattbaird/elastigo" target="_blank" rel="external">https://github.com/mattbaird/elastigo</a></li>
<li><a href="https://github.com/olivere/elastic" target="_blank" rel="external">https://github.com/olivere/elastic</a></li>
<li><a href="https://github.com/richardwilly98/elasticsearch-river-mongodb" target="_blank" rel="external">https://github.com/richardwilly98/elasticsearch-river-mongodb</a></li>
<li><a href="http://baike.baidu.com/item/elasticsearch" target="_blank" rel="external">http://baike.baidu.com/item/elasticsearch</a></li>
<li><a href="https://www.elastic.co/blog/deprecating-rivers" target="_blank" rel="external">https://www.elastic.co/blog/deprecating-rivers</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://www.elastic.co/" target="_blank" rel="external">Elasticsearch</a>是一个分布式可扩展的实时搜索和分析引擎。它能帮助你搜索、分析和浏览数据。Elasticsearch 是一个基于Lucene实现的搜索服务器，用Java开发实现。它提供了RESTful web接口，并作为Apache许可条款下的开放源码发布，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>Elasticsearch关键概念</p>
<p><dl></dl></p>
<p><dt>Cluster集群</dt></p>
<dd>有相同集群名称的节点Node的集合。集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</dd><br><br><dt>Cluster集群</dt><br><dd></dd><br><dt>Node节点</dt><br><dd>一个elasticsearch运行的实例。其实就是一个java进程。一般情况下，一个节点运行在一台机器上。</dd><br><dt>Shards分片</dt><br><dd>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</dd><br><dt>Replicas副本</dt><br><dd>代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</dd><br><dt>Recovery恢复</dt><br><dd>代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</dd><br><dt>River</dt><br><dd>代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。River在1.5中弃用了，2.0中移除了。</dd><br><dt>Gateway</dt><br><dd>代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</dd><br><dt>Discovery.zen</dt><br><dd>代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过多播协议来进行节点之间的通信，同时也支持点对点的交互。</dd><br><dt>Transport</dt><br><dd>代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、thrift、servlet、memcached、zeroMQ等的传输协议（通过插件方式集成）。</dd><br><dt>Index索引</dt><br><dd>Elasticsearch用来存储数据的逻辑区域，它类似于关系型数据库中的table概念。一个index可以在一个或者多个shard上面，同时一个shard也可能会有多个replicas。</dd><br><dt>Document</dt><br><dd>Elasticsearch里面存储的实体数据，类似于关系数据中一个table里面的一行数据。 document由多个field组成，不同的document里面同名的field一定具有相同的类型。document里面field可以重复出现，也就是一个field会有多个值，即multivalued。</dd><br><dt>Document type</dt><br><dd>为了查询需要，一个index可能会有多种document，也就是document type，但需要注意，不同document里面同名的field一定要是相同类型的。</dd><br><dt>Mapping</dt><br><dd>存储field的相关映射信息，不同document type会有不同的mapping。</dd>

]]>
    
    </summary>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="mongo" scheme="http://colobu.com/tags/mongo/"/>
    
      <category term="elasticsearch" scheme="http://colobu.com/tags/elasticsearch/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongodb 定期备份]]></title>
    <link href="http://colobu.com/2015/10/27/mongodb-backup/"/>
    <id>http://colobu.com/2015/10/27/mongodb-backup/</id>
    <published>2015-10-27T02:43:43.000Z</published>
    <updated>2015-10-27T03:02:57.802Z</updated>
    <content type="html"><![CDATA[<p>在生产系统中，数据库的备份是必要的，否则当服务器被攻击，硬盘坏掉，运维误删等原因将数据库干掉的时候就欲哭无泪了。</p>
<p>备份MongoDB数据库常见的方式有三种：</p>
<ul>
<li>使用[MongoDB管理服务（MMS）(<a href="https://mms.mongodb.com/)进行云备份" target="_blank" rel="external">https://mms.mongodb.com/)进行云备份</a></li>
<li>使用文件系统快照</li>
<li>使用MongoDB自身的mongodump工具</li>
</ul>
<p>本文介绍第三种简单的备份，对于备份数据量不是太大的数据库还是很有效的。<br><a id="more"></a></p>
<p>Sheharyar Naseer在<a href="https://sheharyar.me/blog/regular-mongo-backups-using-cron/" target="_blank" rel="external">Regular Mongo Backups Using Cron</a>一文中提供了一个简单的脚本mongo_backup.sh：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"></div><div class="line">MONGO_DATABASE=<span class="string">"your_db_name"</span></div><div class="line">APP_NAME=<span class="string">"your_app_name"</span></div><div class="line"></div><div class="line">MONGO_HOST=<span class="string">"127.0.0.1"</span></div><div class="line">MONGO_PORT=<span class="string">"27017"</span></div><div class="line">TIMESTAMP=`date +%F-%H%M`</div><div class="line">MONGODUMP_PATH=<span class="string">"/usr/bin/mongodump"</span></div><div class="line">BACKUPS_DIR=<span class="string">"/home/username/backups/<span class="variable">$APP_NAME</span>"</span></div><div class="line">BACKUP_NAME=<span class="string">"<span class="variable">$APP_NAME</span>-<span class="variable">$TIMESTAMP</span>"</span></div><div class="line"></div><div class="line"><span class="comment"># mongo admin --eval "printjson(db.fsyncLock())"</span></div><div class="line"><span class="comment"># $MONGODUMP_PATH -h $MONGO_HOST:$MONGO_PORT -d $MONGO_DATABASE</span></div><div class="line"><span class="variable">$MONGODUMP_PATH</span> <span class="operator">-d</span> <span class="variable">$MONGO_DATABASE</span></div><div class="line"><span class="comment"># mongo admin --eval "printjson(db.fsyncUnlock())"</span></div><div class="line"></div><div class="line">mkdir -p <span class="variable">$BACKUPS_DIR</span></div><div class="line">mv dump <span class="variable">$BACKUP_NAME</span></div><div class="line">tar -zcvf <span class="variable">$BACKUPS_DIR</span>/<span class="variable">$BACKUP_NAME</span>.tgz <span class="variable">$BACKUP_NAME</span></div><div class="line">rm -rf <span class="variable">$BACKUP_NAME</span></div></pre></td></tr></table></figure>

<p>View <a href="https://gist.github.com/sheharyarn/0f04c1ba18462cddaaf5" target="_blank" rel="external">Gist</a> on Github</p>
<p>如果你想在备份的时候锁住数据库，避免备份的时候有更新操作，可以uncomment <code>fsyncLock</code> 和 <code>fsyncUnlock</code>这两行。</p>
<p>然后将其加入到cron中:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab <span class="operator">-e</span></div></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">00</span> <span class="number">00</span> * * * /bin/bash /home/username/scripts/mongo_backup.sh</div></pre></td></tr></table></figure>

<p>micahwedemeyer提供了更强大的一个脚本<a href="https://github.com/micahwedemeyer/automongobackup/blob/master/src/automongobackup.sh" target="_blank" rel="external">automongobackup.sh</a>，提供了更强大的备份的功能。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="http://www.infoq.com/cn/articles/mongodb-deployment-backup-security" target="_blank" rel="external">http://www.infoq.com/cn/articles/mongodb-deployment-backup-security</a></li>
<li><a href="https://docs.mongodb.org/manual/reference/program/mongodump/" target="_blank" rel="external">https://docs.mongodb.org/manual/reference/program/mongodump/</a></li>
<li><a href="https://docs.mongodb.org/manual/reference/program/mongorestore/" target="_blank" rel="external">https://docs.mongodb.org/manual/reference/program/mongorestore/</a></li>
<li><a href="https://sheharyar.me/blog/regular-mongo-backups-using-cron/" target="_blank" rel="external">https://sheharyar.me/blog/regular-mongo-backups-using-cron/</a></li>
<li><a href="https://github.com/micahwedemeyer/automongobackup" target="_blank" rel="external">https://github.com/micahwedemeyer/automongobackup</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在生产系统中，数据库的备份是必要的，否则当服务器被攻击，硬盘坏掉，运维误删等原因将数据库干掉的时候就欲哭无泪了。</p>
<p>备份MongoDB数据库常见的方式有三种：</p>
<ul>
<li>使用[MongoDB管理服务（MMS）(<a href="https://mms.mongodb.com/)进行云备份" target="_blank" rel="external">https://mms.mongodb.com/)进行云备份</a></li>
<li>使用文件系统快照</li>
<li>使用MongoDB自身的mongodump工具</li>
</ul>
<p>本文介绍第三种简单的备份，对于备份数据量不是太大的数据库还是很有效的。<br>]]>
    
    </summary>
    
      <category term="mongo" scheme="http://colobu.com/tags/mongo/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
