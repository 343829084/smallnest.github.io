<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 衍化至繁]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2014-11-13T05:06:47.312Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[流量调整和限流技术]]></title>
    <link href="http://colobu.com/2014/11/13/rate-limiting/"/>
    <id>http://colobu.com/2014/11/13/rate-limiting/</id>
    <published>2014-11-13T02:11:20.000Z</published>
    <updated>2014-11-13T05:05:57.000Z</updated>
    <content type="html"><![CDATA[<p>最近看到一些限流的文章，特地整理了一下相关的知识。<br>在早期的计算机领域，限流技术(time limiting)被用作控制网络接口收发通信数据的速率。 可以用来优化性能，减少延迟和提高带宽等。<br>现在在互联网领域，也借鉴了这个概念， 用来为服务控制请求的速率， 如果双十一的限流， 12306的抢票等。<br>即使在细粒度的软件架构中，也有类似的概念。 比如Java线程池可以用Bounded queues保存待执行的任务， 一旦超过queue的容量， 线程池可以根据配置的策略处理此请求。</p>
<a id="more"></a>

<h2 id="两种常用算法">两种常用算法</h2>
<p>令牌桶(<a href="http://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="external">Token Bucket</a>)和漏桶(<a href="http://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="external">leaky bucket</a>)是<br>最常用的两种限流的算法。</p>
<h3 id="漏桶算法">漏桶算法</h3>
<p><img src="leaky_bucket.GIF" alt=""><br>它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。<br>漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。<br>用说人话的讲：   </p>
<blockquote>
<p>漏桶算法思路很简单，水（数据或者请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p>
</blockquote>
<p>在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的参数，所以，即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使某一个单独的流突发到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法可以结合起来为网络流量提供更大的控制。</p>
<h3 id="令牌桶算法">令牌桶算法</h3>
<p><img src="token_bucket.JPG" alt=""><br>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。<br>令牌桶的另外一个好处是可以方便的改变速度。 一旦需要提高速率，则按需提高放入桶中的令牌的速率。<br>一般会定时(比如100毫秒)往桶中增加一定数量的令牌， 有些变种算法则实时的计算应该增加的令牌的数量, 比如华为的专利”<strong>采用令牌漏桶进行报文限流的方法</strong>“(CN 1536815 A),提供了一种动态计算可用令牌数的方法， 相比其它定时增加令牌的方法， 它只在收到一个报文后，计算该报文与前一报文到来的时间间隔内向令牌漏桶内注入的令牌数， 并计算判断桶内的令牌数是否满足传送该报文的要求。</p>
<h2 id="Guava_RateLimiter">Guava RateLimiter</h2>
<p><a href="http://docs.guava-libraries.googlecode.com/git-history/master/javadoc/com/google/common/util/concurrent/RateLimiter.html" target="_blank" rel="external">Google Guava RateLimiter</a>是一个速度控制器，可以根据配置的速度发放许可(令牌)。 每次调用<code>acquire()</code>, 如果有可用的许可，则拿走许可， 否则被阻塞。 拿走的许可毋须被释放。<br>和JDK中的<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html?is-external=true" target="_blank" rel="external">Semaphore</a>不同， Semaphore控制访问资源的并发数，而RateLimiter控制访问资源的速度。<br>RateLimter以每秒N个许可的方式按照固定速率分发许可。<br>你可以warmup让RateLimter能够一开始就稳定的按照固定的速率发放许可。<br><code>tryAcquire()</code>是一个非阻塞的调用方法。</p>
<p>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RateLimiter limiter = RateLimiter.create(<span class="number">20</span>);</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">	<span class="keyword">for</span> (Item item : items) {</div><div class="line">		limiter.acquire(); <span class="comment">//获取许可</span></div><div class="line">		server.sync(item); <span class="comment">//只有获得许可后才会被执行</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考">参考</h2>
<p>网上有众多关于这方面的文章，这里列出了本文参考的一些文档。</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="external">http://en.wikipedia.org/wiki/Token_bucket</a> </li>
<li><a href="http://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="external">http://en.wikipedia.org/wiki/Leaky_bucket</a></li>
<li><a href="http://www.google.com/patents/CN1536815A?cl=zh" target="_blank" rel="external">http://www.google.com/patents/CN1536815A?cl=zh</a></li>
<li><a href="http://www.cnblogs.com/LBSer/p/4083131.html" target="_blank" rel="external">http://www.cnblogs.com/LBSer/p/4083131.html</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>最近看到一些限流的文章，特地整理了一下相关的知识。<br>在早期的计算机领域，限流技术(time limiting)被用作控制网络接口收发通信数据的速率。 可以用来优化性能，减少延迟和提高带宽等。<br>现在在互联网领域，也借鉴了这个概念， 用来为服务控制请求的速率， 如果双十一的限流， 12306的抢票等。<br>即使在细粒度的软件架构中，也有类似的概念。 比如Java线程池可以用Bounded queues保存待执行的任务， 一旦超过queue的容量， 线程池可以根据配置的策略处理此请求。</p>
]]></summary>
    
      <category term="rate limiting" scheme="http://colobu.com/tags/rate-limiting/"/>
    
      <category term="网络编程" scheme="http://colobu.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[子网掩码]]></title>
    <link href="http://colobu.com/2014/11/12/subnet-mask/"/>
    <id>http://colobu.com/2014/11/12/subnet-mask/</id>
    <published>2014-11-12T07:34:12.000Z</published>
    <updated>2014-11-12T08:44:22.000Z</updated>
    <content type="html"><![CDATA[<p>互联网是由许多小型网络构成的，每个网络上都有许多主机，这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，以便于IP地址的寻址操作。</p>
<p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。 1 的部分代表网络号，掩码为 0的部分代表主机号。其中 A类地址的默认子网掩码为 255.0.0.0；B类地址的默认子网掩码为 255.255.0.0；C类地址的默认子网掩码为：255.255.255.0。</p>
<p>同一个网络内的主机的IP地址与掩码 “AND”操作后的结果必然相同。</p>
<a id="more"></a>

<h4 id="网络地址划分">网络地址划分</h4>
<p>internate诞生之初一种IP地址的划分方法。 它将IP地址分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。</p>
<table><tbody><tr><th>Class</th><th>Leading<br>bits</th><th>Size of<i>network<br>number</i> bit field</th><th>Size of<i>rest</i><br>bit field</th><th>Number<br>of networks</th><th>Addresses<br>per network</th><th>Start address</th><th>End address</th></tr><tr><td>Class A</td><td>&nbsp;&nbsp;&nbsp;&nbsp;0</td><td>&nbsp;&nbsp;&nbsp;&nbsp;8</td><td>&nbsp;&nbsp;&nbsp;&nbsp;24</td><td>&nbsp;&nbsp;&nbsp;&nbsp;128 (2<sup>7</sup>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;16,777,216 (2<sup>24</sup>)</td><td>0.0.0.0</td><td>127.255.255.255</td></tr><tr><td>Class B</td><td>&nbsp;&nbsp;&nbsp;&nbsp;10</td><td>&nbsp;&nbsp;&nbsp;&nbsp;16</td><td>&nbsp;&nbsp;&nbsp;&nbsp;16</td><td>&nbsp;&nbsp;&nbsp;&nbsp;16,384 (2<sup>14</sup>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;65,536 (2<sup>16</sup>)</td><td>128.0.0.0</td><td>191.255.255.255</td></tr><tr><td>Class C</td><td>&nbsp;&nbsp;&nbsp;&nbsp;110</td><td>&nbsp;&nbsp;&nbsp;&nbsp;24</td><td>&nbsp;&nbsp;&nbsp;&nbsp;8</td><td>&nbsp;&nbsp;&nbsp;&nbsp;2,097,152 (2<sup>21</sup>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;256 (2<sup>8</sup>)</td><td>192.0.0.0</td><td>223.255.255.255</td></tr><tr><td>Class D (<a href="/wiki/Multicast" title="Multicast">multicast</a>)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;1110</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>224.0.0.0</td><td>239.255.255.255</td></tr><tr><td>Class E (reserved)</td><td>&nbsp;&nbsp;&nbsp;&nbsp;1111</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>&nbsp;&nbsp;&nbsp;&nbsp;not defined</td><td>240.0.0.0</td><td>255.255.255.255</td></tr></tbody></table>            

<h4 id="CIDR"><a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="external">CIDR</a></h4>
<p>CIDR 对原来用于分配A类、B类和C类地址的划分进行了重新设计。CIDR用变长的前缀取代了原来地址结构对地址网络部分的限制（3类地址的网络部分分别被限制为8位、16位和24位），从而能更好地满足机构对地址的特殊需求。<br>CIDR 地址中包含标准的32位IP地址和有关网络前缀位数的信息。以CIDR地址222.80.18.18/25为例，其中“/25”表示其前面地址中的前25位代表网络部分，其余位代表主机部分。</p>
<p>CIDR (无类别域间路由选择)表格</p>
<table class="wikitable"><caption>IPv4 CIDR</caption><tbody><tr><th>IP/CIDR</th><th>Δ to last IP addr</th><th>Mask</th><th>Hosts (*)</th><th>Size</th><th>Restrictions on a/b/c/d<br>(0..255 unless noted)</th></tr><tr><td>a.b.c.d<b>/32</b></td><td>+0.0.0.0</td><td>255.255.255.255</td><td>1</td><td>1/256 C</td><td></td></tr><tr><td>a.b.c.d<b>/31</b></td><td>+0.0.0.1</td><td>255.255.255.254</td><td>2</td><td>1/128 C</td><td>d = 0 … (2n) … 254</td></tr><tr><td>a.b.c.d<b>/30</b></td><td>+0.0.0.3</td><td>255.255.255.252</td><td>4</td><td>1/64 C</td><td>d = 0 … (4n) … 252</td></tr><tr><td>a.b.c.d<b>/29</b></td><td>+0.0.0.7</td><td>255.255.255.248</td><td>8</td><td>1/32 C</td><td>d = 0 … (8n) … 248</td></tr><tr><td>a.b.c.d<b>/28</b></td><td>+0.0.0.15</td><td>255.255.255.240</td><td>16</td><td>1/16 C</td><td>d = 0 … (16n) … 240</td></tr><tr><td>a.b.c.d<b>/27</b></td><td>+0.0.0.31</td><td>255.255.255.224</td><td>32</td><td>⅛ C</td><td>d = 0 … (32n) … 224</td></tr><tr><td>a.b.c.d<b>/26</b></td><td>+0.0.0.63</td><td>255.255.255.192</td><td>64</td><td>¼ C</td><td>d = 0, 64, 128, 192</td></tr><tr><td>a.b.c.d<b>/25</b></td><td>+0.0.0.127</td><td>255.255.255.128</td><td>128</td><td>½ C</td><td>d = 0, 128</td></tr><tr><td>a.b.c.0<b>/24</b></td><td>+0.0.0.255</td><td>255.255.255.000</td><td>256</td><td>1 C</td><td></td></tr><tr><td>a.b.c.0<b>/23</b></td><td>+0.0.1.255</td><td>255.255.254.000</td><td>512</td><td>2 C</td><td>c = 0 … (2n) … 254</td></tr><tr><td>a.b.c.0<b>/22</b></td><td>+0.0.3.255</td><td>255.255.252.000</td><td>1,024</td><td>4 C</td><td>c = 0 … (4n) … 252</td></tr><tr><td>a.b.c.0<b>/21</b></td><td>+0.0.7.255</td><td>255.255.248.000</td><td>2,048</td><td>8 C</td><td>c = 0 … (8n) … 248</td></tr><tr><td>a.b.c.0<b>/20</b></td><td>+0.0.15.255</td><td>255.255.240.000</td><td>4,096</td><td>16 C</td><td>c = 0 … (16n) … 240</td></tr><tr><td>a.b.c.0<b>/19</b></td><td>+0.0.31.255</td><td>255.255.224.000</td><td>8,192</td><td>32 C</td><td>c = 0 … (32n) … 224</td></tr><tr><td>a.b.c.0<b>/18</b></td><td>+0.0.63.255</td><td>255.255.192.000</td><td>16,384</td><td>64 C</td><td>c = 0, 64, 128, 192</td></tr><tr><td>a.b.c.0<b>/17</b></td><td>+0.0.127.255</td><td>255.255.128.000</td><td>32,768</td><td>128 C</td><td>c = 0, 128</td></tr><tr><td>a.b.0.0<b>/16</b></td><td>+0.0.255.255</td><td>255.255.000.000</td><td>65,536</td><td>256 C = 1 B</td><td></td></tr><tr><td>a.b.0.0<b>/15</b></td><td>+0.1.255.255</td><td>255.254.000.000</td><td>131,072</td><td>2 B</td><td>b = 0 … (2n) … 254</td></tr><tr><td>a.b.0.0<b>/14</b></td><td>+0.3.255.255</td><td>255.252.000.000</td><td>262,144</td><td>4 B</td><td>b = 0 … (4n) … 252</td></tr><tr><td>a.b.0.0<b>/13</b></td><td>+0.7.255.255</td><td>255.248.000.000</td><td>524,288</td><td>8 B</td><td>b = 0 … (8n) … 248</td></tr><tr><td>a.b.0.0<b>/12</b></td><td>+0.15.255.255</td><td>255.240.000.000</td><td>1,048,576</td><td>16 B</td><td>b = 0 … (16n) … 240</td></tr><tr><td>a.b.0.0<b>/11</b></td><td>+0.31.255.255</td><td>255.224.000.000</td><td>2,097,152</td><td>32 B</td><td>b = 0 … (32n) … 224</td></tr><tr><td>a.b.0.0<b>/10</b></td><td>+0.63.255.255</td><td>255.192.000.000</td><td>4,194,304</td><td>64 B</td><td>b = 0, 64, 128, 192</td></tr><tr><td>a.b.0.0<b>/9</b></td><td>+0.127.255.255</td><td>255.128.000.000</td><td>8,388,608</td><td>128 B</td><td>b = 0, 128</td></tr><tr><td>a.0.0.0<b>/8</b></td><td>+0.255.255.255</td><td>255.000.000.000</td><td>16,777,216</td><td>256 B = 1 A</td><td></td></tr><tr><td>a.0.0.0<b>/7</b></td><td>+1.255.255.255</td><td>254.000.000.000</td><td>33,554,432</td><td>2 A</td><td>a = 0 … (2n) … 254</td></tr><tr><td>a.0.0.0<b>/6</b></td><td>+3.255.255.255</td><td>252.000.000.000</td><td>67,108,864</td><td>4 A</td><td>a = 0 … (4n) … 252</td></tr><tr><td>a.0.0.0<b>/5</b></td><td>+7.255.255.255</td><td>248.000.000.000</td><td>134,217,728</td><td>8 A</td><td>a = 0 … (8n) … 248</td></tr><tr><td>a.0.0.0<b>/4</b></td><td>+15.255.255.255</td><td>240.000.000.000</td><td>268,435,456</td><td>16 A</td><td>a = 0 … (16n) … 240</td></tr><tr><td>a.0.0.0<b>/3</b></td><td>+31.255.255.255</td><td>224.000.000.000</td><td>536,870,912</td><td>32 A</td><td>a = 0 … (32n) … 224</td></tr><tr><td>a.0.0.0<b>/2</b></td><td>+63.255.255.255</td><td>192.000.000.000</td><td>1,073,741,824</td><td>64 A</td><td>a = 0, 64, 128, 192</td></tr><tr><td>a.0.0.0<b>/1</b></td><td>+127.255.255.255</td><td>128.000.000.000</td><td>2,147,483,648</td><td>128 A</td><td>a = 0, 128</td></tr><tr><td>0.0.0.0<b>/0</b></td><td>+255.255.255.255</td><td>000.000.000.000</td><td>4,294,967,296</td><td>256 A</td><td></td></tr></tbody></table>

<h4 id="IPV6子网划分">IPV6子网划分</h4>
<p>IPv4地址是类似 A.B.C.D 的格式，它是32位，用”.”分成四段，用10进制表示；而IPv6地址类似X:X:X:X:X:X:X:X的格式，它是128位的，用”:”分 成8段，用16进制表示；<br>为了简化其表示法， rfc2373提出每段中前面的0可以省略，连续的0可省略为”::”，但只能出现一次。例如：<br>1080:0:0:0:8:800: 200C : 417A 可简写为 1080::8:800:200C:417A<br>FF01:0:0:0:0:0:0:101 可简写为 FF01::101<br>0:0:0:0:0:0:0:1 可简写为 ::1<br>0:0:0:0:0:0:0:0 可简写为 :: </p>
<p>子网掩码只有一种表示（ipv6已经不叫子网掩码，叫前缀，前缀表示网络位）。<br><code>inet6 addr: fe80::a00:27ff:fe0c:4cf9/64</code><br>后面的前缀“64”表示128位中的前64位表示网络位，</p>
<table width="\&quot;80%\&quot;" border="1" cellpadding="0" cellspacing="0"><tbody><tr><td><p><strong>IPv4地址</strong></p></td><td><p><strong>IPv6地址</strong></p></td></tr><tr><td><p>组播地址（ 224.0.0.0/4）</p></td><td><p>IPv6组播地址（FF00::/8）</p></td></tr><tr><td><p>广播地址</p></td><td><p>无，只有任播（ anycast）地址</p></td></tr><tr><td><p>未指定地址为 0.0.0 .0</p></td><td><p>未指定地址为 ::</p></td></tr><tr><td><p>回路地址为 127.0.0.1</p></td><td><p>回路地址为 ::1</p></td></tr><tr><td><p>公用 IP地址</p></td><td><p>可汇聚全球单播地址</p></td></tr><tr><td><p>私有地址（ 10.0.0 .0/8、172.16.0.0/12和192.168.0.0/16）</p></td><td><p>本地站点地址（ FEC0::/48）</p></td></tr><tr><td><p>Microsoft自动专用IP寻址自动配置的地址（169.254.0.0/16）</p></td><td><p>本地链路地址（ FE80::/64）</p></td></tr><tr><td><p>表达方式：点分十进制</p></td><td><p>表达方式：冒号十六进制式（取消前置零、零压缩）</p></td></tr><tr><td><p>子网掩码表示：以点阵十进制表示法或前缀长度表示法（ CIDR）</p></td><td><p>子网掩码表示：仅使用前缀长度表示法（ CIDR）</p></td></tr></tbody></table>            

<h4 id="IPv6地址作用域和地址分类">IPv6地址作用域和地址分类</h4>
<ul>
<li>IPv6地址指定给接口，一个接口可以指定多个地址。</li>
<li><p>IPv6地址有作用域：<br>link local地址 本链路有效<br>site local地址 本区域（站点）内有效，一个site通常是个校园网<br>global地址 全球有效，即可汇聚全球单播地址</p>
</li>
<li><p>IPv6地址分类：<br>unicast 单播（单点传送）地址<br>multicast 组播（多点传送）地址<br>anycast 任播（任意点传送）地址</p>
</li>
</ul>
<p>IPv6没有定义广播地址，其功能由组播地址替代 </p>
<h4 id="常见的IPv6地址及其前缀">常见的IPv6地址及其前缀</h4>
<ul>
<li>::/128  即0:0:0:0:0:0:0:0，只能作为尚未获得正式地址的主机的源地址，不能作为目的地址，不能分配给真实的网络接口。</li>
<li>::1/128 即0:0:0:0:0:0:0:1，回环地址，相当于IPv4中的localhost（127.0.0.1），ping locahost可得到此地址。</li>
<li>2001::/16  全球可聚合地址，由 IANA 按地域和ISP进行分配，是最常用的IPv6地址，属于单播地址。</li>
<li>2002::/16  6 to 4 地址，用于6to4自动构造隧道技术的地址，属于单播地址。</li>
<li>3ffe::/16   早期开始的IPv6 6bone试验网 地址，属于单播地址。</li>
<li>fe80::/10   本地链路地址，用于单一链路，适用于自动配置、邻机发现等，路由器不转发以fe80开头的地址。</li>
<li>ff00::/8  组播地址。</li>
<li>::A.B.C.D  兼容IPv4的IPv6地址，其中<a.b.c.d>代表IPv4地址。自动将IPv6包以隧道方式在IPv4网络中传送的IPv4/IPv6节点将使用这些地址。</a.b.c.d></li>
<li>::FFFF:A.B.C.D   是IPv4映射过来的IPv6地址，其中<a.b.c.d>代表IPv4地址，例如 ::ffff:202.120.2.30 ，它是在不支持IPv6的网上用于表示IPv4节点。 </a.b.c.d></li>
</ul>
<h4 id="参考">参考</h4>
<ol>
<li>wikipedia</li>
<li><a href="http://ipv6.tsinghua.edu.cn/technology/ipv6-di-zhi-jie-shao/" target="_blank" rel="external">http://ipv6.tsinghua.edu.cn/technology/ipv6-di-zhi-jie-shao/</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>互联网是由许多小型网络构成的，每个网络上都有许多主机，这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，以便于IP地址的寻址操作。</p>
<p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。 1 的部分代表网络号，掩码为 0的部分代表主机号。其中 A类地址的默认子网掩码为 255.0.0.0；B类地址的默认子网掩码为 255.255.0.0；C类地址的默认子网掩码为：255.255.255.0。</p>
<p>同一个网络内的主机的IP地址与掩码 “AND”操作后的结果必然相同。</p>
]]></summary>
    
      <category term="网络编程" scheme="http://colobu.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux组播设置以及netty设置]]></title>
    <link href="http://colobu.com/2014/11/07/linux-muticast-setting-with-netty/"/>
    <id>http://colobu.com/2014/11/07/linux-muticast-setting-with-netty/</id>
    <published>2014-11-07T09:25:52.000Z</published>
    <updated>2014-11-12T01:23:36.000Z</updated>
    <content type="html"><![CDATA[<p>Java 7增加NIO multicast的支持， netty 4中也增加了对multicast的支持: <a href="https://github.com/netty/netty/issues/216" target="_blank" rel="external">Issue #216</a>。<br>实际在使用中需要对环境和Netty的代码进行相应的配置。<br><a id="more"></a></p>
<h2 id="检查Linux环境是否支持multicast">检查Linux环境是否支持multicast</h2>
<p>运行<code>ifconfig -a</code>, 如果在输出中有如下的信息，则当前的内核支持multicast。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">UP</span> BROADCAST RUNNING MULTICAST</div></pre></td></tr></table></figure>

<p>如果没有这样的信息， 尝试下面的命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ifconfig</span> eth0 multicast</div></pre></td></tr></table></figure>

<p>再运行<code>ifconfig -a</code>, 如果的确没有<code>UP BROADCAST RUNNING MULTICAST</code>， 需要重新编译内核。<br>设置内核配置如下：</p>
<ul>
<li>CONFIG_IP_MULTICAST=y</li>
<li>CONFIG_IP_ROUTER=y</li>
<li>CONFIG_IP_MROUTE=y</li>
<li>CONFIG_NET_IPIP=y<br>默认Red Hat / Fedora/ Cent OS内核都支持multicast。</li>
</ul>
<h2 id="配置多播路由">配置多播路由</h2>
<p>命令<code>route -n</code>可以查看配置的路由信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># route -n</span></div><div class="line"><span class="title">Kernel</span> IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line"><span class="number">192.168.204.0</span>   <span class="number">0.0.0.0</span>         <span class="number">255.255.252.0</span>   U     <span class="number">1</span>      <span class="number">0</span>        <span class="number">0</span> eth0</div><div class="line"><span class="number">224.0.0.0</span>       <span class="number">0.0.0.0</span>         <span class="number">224.0.0.0</span>       U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> lo</div><div class="line"><span class="number">0.0.0.0</span>         <span class="number">192.168.204.1</span>   <span class="number">0.0.0.0</span>         UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</div></pre></td></tr></table></figure>

<p>或者<code>/sbin/ip route show</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># /sbin/ip route show</span></div><div class="line"><span class="number">192.168</span><span class="number">.204</span><span class="number">.0</span>/<span class="number">22</span> dev eth0  proto kernel  scope link  src <span class="number">192.168</span><span class="number">.204</span><span class="number">.49</span>  metric <span class="number">1</span> </div><div class="line"><span class="number">224.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">3</span> dev lo  scope link </div><div class="line"><span class="default"><span class="keyword">default</span> via 192.168.204.1 dev eth0  proto stati</span></div></pre></td></tr></table></figure>

<p>如果你的网卡或者lo没有配置<code>224.0.0.0</code>这样的行， 需要配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">route</span> add -net <span class="number">224.0.0.0</span> netmask <span class="number">240.0.0.0</span> dev lo</div></pre></td></tr></table></figure>

<p>我在本机测试， 这里使用的是lo本地回环接口 (local loopback interface)。</p>
<p>移除路由</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">route</span> del -net <span class="number">224.0.0.0</span> netmask <span class="number">240.0.0.0</span> dev eth0</div></pre></td></tr></table></figure>

<p>你可以在<code>/etc/rc.d/rc.local</code>中加上下面的一行， 这样服务器每次启动会自动配置路由。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">route</span> add -net <span class="number">224.0.0.0</span> netmask <span class="number">240.0.0.0</span> lo</div></pre></td></tr></table></figure>

<p>IPv4 多播地址由<code>1110</code>开始, 这类地址为D类地址。  CIDR为 224.0.0.0/4. 包含的地址范围为 224.0.0.0 到 239.255.255.255.  RFC 5771 和IETF BCP 51对地址有相应的定义.<br><code>240.0.0.0</code> 二进制形式为<code>11110000 00000000 00000000 00000000</code>。</p>
<p>检查多播地址<br><code>netstat -gn</code><br>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@colobu smallnest]<span class="preprocessor"># netstat -gn</span></div><div class="line">IPv6/IPv4 <span class="keyword">Group</span> Memberships</div><div class="line"><span class="keyword">Interface</span>       RefCnt <span class="keyword">Group</span></div><div class="line">--------------- ------ ---------------------</div><div class="line">lo              <span class="number">2</span>      <span class="number">224.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">eth0            <span class="number">1</span>      <span class="number">224.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">lo              <span class="number">1</span>      ff02::<span class="number">1</span></div><div class="line">eth0            <span class="number">1</span>      ff02::<span class="number">1</span>:ff0c:<span class="number">4</span>cf9</div><div class="line">eth0            <span class="number">1</span>      ff02::<span class="number">1</span></div></pre></td></tr></table></figure>

<p>可以看到<code>224.0.0.1</code>这个IP地址。</p>
<h2 id="Netty的多播设置">Netty的多播设置</h2>
<p>Netty下UDP多播的设置和UDP单播基本类似，只是增加了额外的参数。<br>Netty本身提供了多播的<a href="DatagramMulticastTest.java">单元测试</a>， 可以参考应用，非常简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMulticast</span>(Bootstrap sb, Bootstrap cb) <span class="keyword">throws</span> Throwable {</div><div class="line">    MulticastTestHandler mhandler = <span class="keyword">new</span> MulticastTestHandler();</div><div class="line"></div><div class="line">    sb.handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;Object&gt;() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span>(ChannelHandlerContext ctx, Object msg) <span class="keyword">throws</span> Exception {</div><div class="line">            <span class="comment">// Nothing will be sent.</span></div><div class="line">        }</div><div class="line">    });</div><div class="line"></div><div class="line">    cb.handler(mhandler);</div><div class="line"></div><div class="line">    sb.option(ChannelOption.IP_MULTICAST_IF, NetUtil.LOOPBACK_IF);</div><div class="line">    sb.option(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>);</div><div class="line">    cb.option(ChannelOption.IP_MULTICAST_IF, NetUtil.LOOPBACK_IF);</div><div class="line">    cb.option(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>);</div><div class="line">    cb.localAddress(addr.getPort());</div><div class="line"></div><div class="line">    Channel sc = sb.bind().sync().channel();</div><div class="line">    <span class="keyword">if</span> (sc <span class="keyword">instanceof</span> OioDatagramChannel) {</div><div class="line">        <span class="comment">// skip the test for OIO, as it fails because of</span></div><div class="line">        <span class="comment">// No route to host which makes no sense.</span></div><div class="line">        <span class="comment">// Maybe a JDK bug ?</span></div><div class="line">        sc.close().awaitUninterruptibly();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    DatagramChannel cc = (DatagramChannel) cb.bind().sync().channel();</div><div class="line"></div><div class="line">    String group = <span class="string">"230.0.0.1"</span>;</div><div class="line">    InetSocketAddress groupAddress = <span class="keyword">new</span> InetSocketAddress(group, addr.getPort());</div><div class="line"></div><div class="line">    cc.joinGroup(groupAddress, NetUtil.LOOPBACK_IF).sync();</div><div class="line"></div><div class="line">    sc.writeAndFlush(<span class="keyword">new</span> DatagramPacket(Unpooled.copyInt(<span class="number">1</span>), groupAddress)).sync();</div><div class="line">    assertTrue(mhandler.await());</div><div class="line"></div><div class="line">    <span class="comment">// leave the group</span></div><div class="line">    cc.leaveGroup(groupAddress, NetUtil.LOOPBACK_IF).sync();</div><div class="line"></div><div class="line">    <span class="comment">// sleep a second to make sure we left the group</span></div><div class="line">    Thread.sleep(<span class="number">1000</span>);</div><div class="line"></div><div class="line">    <span class="comment">// we should not receive a message anymore as we left the group before</span></div><div class="line">    sc.writeAndFlush(<span class="keyword">new</span> DatagramPacket(Unpooled.copyInt(<span class="number">1</span>), groupAddress)).sync();</div><div class="line">    mhandler.await();</div><div class="line"></div><div class="line">    sc.close().awaitUninterruptibly();</div><div class="line">    cc.close().awaitUninterruptibly();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你的多播地址绑定的网卡不是lo回环接口， 你需要用你绑定的网卡设置<code>sb.option(ChannelOption.IP_MULTICAST_IF, NetUtil.LOOPBACK_IF);</code></p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://www.hiperworks.com/pirdoc/cglx-doc/setup/network.html" target="_blank" rel="external">http://www.hiperworks.com/pirdoc/cglx-doc/setup/network.html</a></li>
<li><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialNetworking.html#MULTICAST" target="_blank" rel="external">http://www.yolinux.com/TUTORIALS/LinuxTutorialNetworking.html#MULTICAST</a></li>
<li><a href="http://yiluohuanghun.blog.51cto.com/3407300/1083094" target="_blank" rel="external">Linux下多播的配置</a></li>
<li><a href="http://en.wikipedia.org/wiki/Multicast_address" target="_blank" rel="external">http://en.wikipedia.org/wiki/Multicast_address</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>Java 7增加NIO multicast的支持， netty 4中也增加了对multicast的支持: <a href="https://github.com/netty/netty/issues/216" target="_blank" rel="external">Issue #216</a>。<br>实际在使用中需要对环境和Netty的代码进行相应的配置。<br>]]></summary>
    
      <category term="multicast" scheme="http://colobu.com/tags/multicast/"/>
    
      <category term="网络编程" scheme="http://colobu.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 Lambda 揭秘]]></title>
    <link href="http://colobu.com/2014/11/06/secrets-of-java-8-lambda/"/>
    <id>http://colobu.com/2014/11/06/secrets-of-java-8-lambda/</id>
    <published>2014-11-06T02:48:39.000Z</published>
    <updated>2014-11-06T09:18:07.000Z</updated>
    <content type="html"><![CDATA[<p>再了解了Java 8 Lambda的一些基本概念和应用后， 我们会有这样的一个问题: <em>Lambda表达式被编译成了什么？</em>。 这是一个有趣的问题，涉及到JDK的具体的实现。 本文将介绍OpenJDK对Lambda表达式的转换细节， 读者可以了解Java 8 Lambda表达式背景知识。<br><a id="more"></a></p>
<h2 id="Lambda表达式的转换策略">Lambda表达式的转换策略</h2>
<p><a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CB0QFjAA&amp;url=%68%74%74%70%73%3a%2f%2f%74%77%69%74%74%65%72%2e%63%6f%6d%2f%42%72%69%61%6e%47%6f%65%74%7a&amp;ei=9v9aVJCEGcn28QXsrIHwBQ&amp;usg=AFQjCNHu9y69SvQVsjuMqyBv3PMELARZ5Q&amp;bvm=bv.78677474,d.dGc" target="_blank" rel="external">Brian Goetz</a>是Oracle的Java语言架构师， JSR 335(Lambda Expression)规范的lead, 写了几篇Lambda设计方面的文章， 其中之一就是<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html" target="_blank" rel="external">Translation of Lambda Expressions</a>。 这篇文章介绍了Java 8 Lambda设计时的考虑以及实现方法。</p>
<p>他提到， Lambda表达式可以通过内部类， method handle, dynamic proxy等方式实现， 但是这些方法各有优劣。 真正要实现Lambda表达式， 必须兼顾两个目标： 一是不引入特定策略，以期为将来的优化提供最大的灵活性， 二是保持类文件格式的稳定。 通过Java 7中引入的<strong>invokedynamic</strong> （<a href="https://jcp.org/en/jsr/detail?id=292" target="_blank" rel="external">JSR 292</a>）, 可以很好的兼顾这两个目标。</p>
<p><strong>invokedynamic</strong> 在缺乏静态类型信息的情况下可以支持有效的灵活的方法调用。主要是为了日益增长的运行在JVM上的动态类型语言， 如Groovy, JRuby。<br><strong>invokedynamic</strong>将Lambda表达式的转换策略推迟到运行时， 这也意味着我们现在编译的代码在将来的转换策略改变的情况下也能正常运行。<br>编译器在编译的时候， 会将Lambda表达式的表达式体 (lambda body)脱糖(desugar) 成一个方法，此方法的参数列表和返回类型和lambda表达式一致， 如果有捕获参数， 脱糖的方法的参数可能会更多一些， 并会产生一个<strong>invokedynamic</strong>调用， 调用一个call site。 这个call site被调用时会返回lambda表达式的目标类型(functional interface)的一个实现类。 这个call site称为这个lambda表达式的<em>lambda factory</em>。 <em>lambda factory</em>的bootstrap方法是一个标准方法， 叫做<em>lambda metafactory</em>。</p>
<p>编译器在转换lambda表达式时， 可以推断出表达式的参数类型，返回类型以及异常， 称之为<code>natural signature</code>， 我们将目标类型的方法签名称之为<code>lambda descriptor</code>, lambda factory的返回对象实现了函数式接口， 并且关联的表达式的代码逻辑， 称之为<code>lambda object</code>。</p>
<h2 id="转换举例">转换举例</h2>
<p>以上的解释有点晦涩， 简单来说</p>
<ul>
<li>编译时<ul>
<li>Lambda 表达式会生成一个方法， 方法实现了表达式的代码逻辑</li>
<li>生成invokedynamic指令， 调用bootstrap方法， 由java.lang.invoke.LambdaMetafactory.metafactory方法实现</li>
</ul>
</li>
<li>运行时<ul>
<li>invokedynamic指令调用metafactory方法。 它会返回一个CallSite, 此CallSite返回目标类型的一个匿名实现类， 此类关联编译时产生的方法</li>
<li>lambda表达式调用时会调用匿名实现类关联的方法。</li>
</ul>
</li>
</ul>
<p>最简单的一个lambda表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda1</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</div><div class="line">		c.accept(<span class="string">"hello lambda"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用javap查看生成的字节码 <code>javap -c -p -v com/colobu/lambda/chapter5/Lambda1.class</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">[</span>root@colobu bin<span class="preprocessor">]</span><span class="markup"># javap -c -p -v com/colobu/lambda/chapter5/Lambda1.class </span></div><div class="line">Classfile /mnt/eclipse/Lambda/bin/com/colobu/lambda/chapter5/Lambda1.class</div><div class="line">  Last modified Nov 6, 2014; size 1401 bytes</div><div class="line">  MD5 checksum fe2b2d3f039a9ba4209c488a8c4b4ea8</div><div class="line">  Compiled from "Lambda1.java"</div><div class="line">public class com.colobu.lambda.chapter5.Lambda1</div><div class="line">  SourceFile: "Lambda1.java"</div><div class="line">  BootstrapMethods:</div><div class="line">    0: #57 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</div><div class="line">      Method arguments:</div><div class="line">        #58 (Ljava/lang/Object;)V</div><div class="line">        #61 invokestatic com/colobu/lambda/chapter5/Lambda1.lambda$0:(Ljava/lang/String;)V</div><div class="line">        #62 (Ljava/lang/String;)V</div><div class="line">  InnerClasses:</div><div class="line">       public static final #68= #64 of #66; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</div><div class="line">  minor version: 0</div><div class="line">  major version: 52</div><div class="line">  flags: ACC_PUBLIC, ACC_SUPER</div><div class="line">Constant pool:</div><div class="line">   #1 = Class              #2             //  com/colobu/lambda/chapter5/Lambda1</div><div class="line">   #2 = Utf8               com/colobu/lambda/chapter5/Lambda1</div><div class="line">   #3 = Class              #4             //  java/lang/Object</div><div class="line">   #4 = Utf8               java/lang/Object</div><div class="line">   #5 = Utf8               &lt;init&gt;</div><div class="line">   #6 = Utf8               ()V</div><div class="line">   #7 = Utf8               Code</div><div class="line">   #8 = Methodref          #3.#9          //  java/lang/Object."&lt;init&gt;":()V</div><div class="line">   #9 = NameAndType        #5:#6          //  "&lt;init&gt;":()V</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               LocalVariableTable</div><div class="line">  #12 = Utf8               this</div><div class="line">  #13 = Utf8               Lcom/colobu/lambda/chapter5/Lambda1;</div><div class="line">  #14 = Utf8               main</div><div class="line">  #15 = Utf8               (<span class="preprocessor">[</span>Ljava/lang/<span class="built_in">String</span>;)V</div><div class="line">  <span class="variable">#16</span> <span class="subst">=</span> NameAndType        <span class="variable">#17</span>:<span class="variable">#18</span>        <span class="comment">//  accept:()Ljava/util/function/Consumer;</span></div><div class="line">  <span class="variable">#17</span> <span class="subst">=</span> Utf8               accept</div><div class="line">  <span class="variable">#18</span> <span class="subst">=</span> Utf8               ()Ljava/util/function/Consumer;</div><div class="line">  <span class="variable">#19</span> <span class="subst">=</span> InvokeDynamic      <span class="variable">#0</span>:<span class="variable">#16</span>         <span class="comment">//  #0:accept:()Ljava/util/function/Consumer;</span></div><div class="line">  <span class="variable">#20</span> <span class="subst">=</span> <span class="built_in">String</span>             <span class="variable">#21</span>            <span class="comment">//  hello lambda</span></div><div class="line">  <span class="variable">#21</span> <span class="subst">=</span> Utf8               hello lambda</div><div class="line">  <span class="variable">#22</span> <span class="subst">=</span> InterfaceMethodref <span class="variable">#23</span><span class="built_in">.</span><span class="variable">#25</span>        <span class="comment">//  java/util/function/Consumer.accept:(Ljava/lang/Object;)V</span></div><div class="line">  <span class="variable">#23</span> <span class="subst">=</span> Class              <span class="variable">#24</span>            <span class="comment">//  java/util/function/Consumer</span></div><div class="line">  <span class="variable">#24</span> <span class="subst">=</span> Utf8               java/util/function/Consumer</div><div class="line">  <span class="variable">#25</span> <span class="subst">=</span> NameAndType        <span class="variable">#17</span>:<span class="variable">#26</span>        <span class="comment">//  accept:(Ljava/lang/Object;)V</span></div><div class="line">  <span class="variable">#26</span> <span class="subst">=</span> Utf8               (Ljava/lang/Object;)V</div><div class="line">  <span class="variable">#27</span> <span class="subst">=</span> Utf8               args</div><div class="line">  <span class="variable">#28</span> <span class="subst">=</span> Utf8               <span class="preprocessor">[</span>Ljava/lang/<span class="built_in">String</span>;</div><div class="line">  <span class="variable">#29</span> <span class="subst">=</span> Utf8               c</div><div class="line">  <span class="variable">#30</span> <span class="subst">=</span> Utf8               Ljava/util/function/Consumer;</div><div class="line">  <span class="variable">#31</span> <span class="subst">=</span> Utf8               LocalVariableTypeTable</div><div class="line">  <span class="variable">#32</span> <span class="subst">=</span> Utf8               Ljava/util/function/Consumer<span class="subst">&lt;</span>Ljava/lang/<span class="built_in">String</span>;<span class="subst">&gt;</span>;</div><div class="line">  <span class="variable">#33</span> <span class="subst">=</span> Utf8               lambda$<span class="number">0</span></div><div class="line">  <span class="variable">#34</span> <span class="subst">=</span> Utf8               (Ljava/lang/<span class="built_in">String</span>;)V</div><div class="line">  <span class="variable">#35</span> <span class="subst">=</span> Fieldref           <span class="variable">#36</span><span class="built_in">.</span><span class="variable">#38</span>        <span class="comment">//  java/lang/System.out:Ljava/io/PrintStream;</span></div><div class="line">  <span class="variable">#36</span> <span class="subst">=</span> Class              <span class="variable">#37</span>            <span class="comment">//  java/lang/System</span></div><div class="line">  <span class="variable">#37</span> <span class="subst">=</span> Utf8               java/lang/System</div><div class="line">  <span class="variable">#38</span> <span class="subst">=</span> NameAndType        <span class="variable">#39</span>:<span class="variable">#40</span>        <span class="comment">//  out:Ljava/io/PrintStream;</span></div><div class="line">  <span class="variable">#39</span> <span class="subst">=</span> Utf8               out</div><div class="line">  <span class="variable">#40</span> <span class="subst">=</span> Utf8               Ljava/io/PrintStream;</div><div class="line">  <span class="variable">#41</span> <span class="subst">=</span> Methodref          <span class="variable">#42</span><span class="built_in">.</span><span class="variable">#44</span>        <span class="comment">//  java/io/PrintStream.println:(Ljava/lang/String;)V</span></div><div class="line">  <span class="variable">#42</span> <span class="subst">=</span> Class              <span class="variable">#43</span>            <span class="comment">//  java/io/PrintStream</span></div><div class="line">  <span class="variable">#43</span> <span class="subst">=</span> Utf8               java/io/PrintStream</div><div class="line">  <span class="variable">#44</span> <span class="subst">=</span> NameAndType        <span class="variable">#45</span>:<span class="variable">#34</span>        <span class="comment">//  println:(Ljava/lang/String;)V</span></div><div class="line">  <span class="variable">#45</span> <span class="subst">=</span> Utf8               println</div><div class="line">  <span class="variable">#46</span> <span class="subst">=</span> Utf8               s</div><div class="line">  <span class="variable">#47</span> <span class="subst">=</span> Utf8               Ljava/lang/<span class="built_in">String</span>;</div><div class="line">  <span class="variable">#48</span> <span class="subst">=</span> Utf8               SourceFile</div><div class="line">  <span class="variable">#49</span> <span class="subst">=</span> Utf8               Lambda1<span class="built_in">.</span>java</div><div class="line">  <span class="variable">#50</span> <span class="subst">=</span> Utf8               BootstrapMethods</div><div class="line">  <span class="variable">#51</span> <span class="subst">=</span> Methodref          <span class="variable">#52</span><span class="built_in">.</span><span class="variable">#54</span>        <span class="comment">//  java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></div><div class="line">  <span class="variable">#52</span> <span class="subst">=</span> Class              <span class="variable">#53</span>            <span class="comment">//  java/lang/invoke/LambdaMetafactory</span></div><div class="line">  <span class="variable">#53</span> <span class="subst">=</span> Utf8               java/lang/invoke/LambdaMetafactory</div><div class="line">  <span class="variable">#54</span> <span class="subst">=</span> NameAndType        <span class="variable">#55</span>:<span class="variable">#56</span>        <span class="comment">//  metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></div><div class="line">  <span class="variable">#55</span> <span class="subst">=</span> Utf8               metafactory</div><div class="line">  <span class="variable">#56</span> <span class="subst">=</span> Utf8               (Ljava/lang/invoke/MethodHandles<span class="variable">$Lookup</span>;Ljava/lang/<span class="built_in">String</span>;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</div><div class="line">  <span class="variable">#57</span> <span class="subst">=</span> MethodHandle       <span class="variable">#6</span>:<span class="variable">#51</span>         <span class="comment">//  invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></div><div class="line">  <span class="variable">#58</span> <span class="subst">=</span> MethodType         <span class="variable">#26</span>            <span class="comment">//  (Ljava/lang/Object;)V</span></div><div class="line">  <span class="variable">#59</span> <span class="subst">=</span> Methodref          <span class="variable">#1</span><span class="built_in">.</span><span class="variable">#60</span>         <span class="comment">//  com/colobu/lambda/chapter5/Lambda1.lambda$0:(Ljava/lang/String;)V</span></div><div class="line">  <span class="variable">#60</span> <span class="subst">=</span> NameAndType        <span class="variable">#33</span>:<span class="variable">#34</span>        <span class="comment">//  lambda$0:(Ljava/lang/String;)V</span></div><div class="line">  <span class="variable">#61</span> <span class="subst">=</span> MethodHandle       <span class="variable">#6</span>:<span class="variable">#59</span>         <span class="comment">//  invokestatic com/colobu/lambda/chapter5/Lambda1.lambda$0:(Ljava/lang/String;)V</span></div><div class="line">  <span class="variable">#62</span> <span class="subst">=</span> MethodType         <span class="variable">#34</span>            <span class="comment">//  (Ljava/lang/String;)V</span></div><div class="line">  <span class="variable">#63</span> <span class="subst">=</span> Utf8               InnerClasses</div><div class="line">  <span class="variable">#64</span> <span class="subst">=</span> Class              <span class="variable">#65</span>            <span class="comment">//  java/lang/invoke/MethodHandles$Lookup</span></div><div class="line">  <span class="variable">#65</span> <span class="subst">=</span> Utf8               java/lang/invoke/MethodHandles<span class="variable">$Lookup</span></div><div class="line">  <span class="variable">#66</span> <span class="subst">=</span> Class              <span class="variable">#67</span>            <span class="comment">//  java/lang/invoke/MethodHandles</span></div><div class="line">  <span class="variable">#67</span> <span class="subst">=</span> Utf8               java/lang/invoke/MethodHandles</div><div class="line">  <span class="variable">#68</span> <span class="subst">=</span> Utf8               Lookup</div><div class="line">{</div><div class="line">  <span class="keyword">public</span> com<span class="built_in">.</span>colobu<span class="built_in">.</span>lambda<span class="built_in">.</span>chapter5<span class="built_in">.</span>Lambda1();</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      <span class="built_in">stack</span><span class="subst">=</span><span class="number">1</span>, locals<span class="subst">=</span><span class="number">1</span>, args_size<span class="subst">=</span><span class="number">1</span></div><div class="line">         <span class="number">0</span>: aload_0       </div><div class="line">         <span class="number">1</span>: invokespecial <span class="variable">#8</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></div><div class="line">         <span class="number">4</span>: <span class="keyword">return</span>        </div><div class="line">      LineNumberTable:</div><div class="line">        line <span class="number">7</span>: <span class="number">0</span></div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">               <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  this   Lcom/colobu/lambda/chapter5/Lambda1;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> static <span class="literal">void</span> main(java<span class="built_in">.</span>lang<span class="built_in">.</span><span class="built_in">String</span><span class="preprocessor">[</span><span class="preprocessor">]</span><span class="markup">);</span></div><div class="line">    flags: ACC_PUBLIC, ACC_STATIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=2, args_size=1</div><div class="line">         0: invokedynamic #19,  0             // InvokeDynamic #0:accept:()Ljava/util/function/Consumer;</div><div class="line">         5: astore_1      </div><div class="line">         6: aload_1       </div><div class="line">         7: ldc           #20                 // String hello lambda</div><div class="line">         9: invokeinterface #22,  2           // InterfaceMethod java/util/function/Consumer.accept:(Ljava/lang/Object;)V</div><div class="line">        14: return        </div><div class="line">      LineNumberTable:</div><div class="line">        line 10: 0</div><div class="line">        line 11: 6</div><div class="line">        line 12: 14</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">               0      15     0  args   <span class="preprocessor">[</span>Ljava/lang/<span class="built_in">String</span>;</div><div class="line">               <span class="number">6</span>       <span class="number">9</span>     <span class="number">1</span>     c   Ljava/util/function/Consumer;</div><div class="line">      LocalVariableTypeTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">            <span class="number">6</span>       <span class="number">9</span>     <span class="number">1</span>     c   Ljava/util/function/Consumer<span class="subst">&lt;</span>Ljava/lang/<span class="built_in">String</span>;<span class="subst">&gt;</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> static <span class="literal">void</span> lambda$<span class="number">0</span>(java<span class="built_in">.</span>lang<span class="built_in">.</span><span class="built_in">String</span>);</div><div class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</div><div class="line">    Code:</div><div class="line">      <span class="built_in">stack</span><span class="subst">=</span><span class="number">2</span>, locals<span class="subst">=</span><span class="number">1</span>, args_size<span class="subst">=</span><span class="number">1</span></div><div class="line">         <span class="number">0</span>: getstatic     <span class="variable">#35</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></div><div class="line">         <span class="number">3</span>: aload_0       </div><div class="line">         <span class="number">4</span>: invokevirtual <span class="variable">#41</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></div><div class="line">         <span class="number">7</span>: <span class="keyword">return</span>        </div><div class="line">      LineNumberTable:</div><div class="line">        line <span class="number">10</span>: <span class="number">0</span></div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">               <span class="number">0</span>       <span class="number">8</span>     <span class="number">0</span>     s   Ljava/lang/<span class="built_in">String</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到， Lambda表达式体被生成一个称之为<code>lambda$0</code>的方法。 看字节码知道它调用System.out.println输出传入的参数。<br>原lambda表达式处产生了一条<code>invokedynamic #19,  0</code>。它会调用<code>bootstrap</code>方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>: <span class="variable">#57</span> invokestatic java/lang/invoke/LambdaMetafactory<span class="built_in">.</span>metafactory:(Ljava/lang/invoke/MethodHandles<span class="variable">$Lookup</span>;Ljava/lang/<span class="built_in">String</span>;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</div><div class="line">      Method arguments:</div><div class="line">        <span class="variable">#58</span> (Ljava/lang/Object;)V</div><div class="line">        <span class="variable">#61</span> invokestatic com/colobu/lambda/chapter5/Lambda1<span class="built_in">.</span>lambda$<span class="number">0</span>:(Ljava/lang/<span class="built_in">String</span>;)V</div><div class="line">        <span class="variable">#62</span> (Ljava/lang/<span class="built_in">String</span>;)V</div></pre></td></tr></table></figure>

<p>如果Lambda表达式写成<code>Consumer&lt;String&gt; c = (Consumer&lt;String&gt; &amp; Serializable)s -&gt; System.out.println(s);</code>, 则BootstrapMethods的字节码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BootstrapMethods:</div><div class="line">    <span class="number">0</span>: #<span class="number">108</span> invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</div><div class="line">      Method arguments:</div><div class="line">        #<span class="number">109</span> (Ljava/lang/Object;)V</div><div class="line">        #<span class="number">112</span> invokestatic com/colobu/lambda/chapter5/Lambda1.lambda$<span class="number">0</span>:(Ljava/lang/String;)V</div><div class="line">        #<span class="number">113</span> (Ljava/lang/String;)V</div><div class="line">        #<span class="number">114</span> <span class="number">1</span></div></pre></td></tr></table></figure>

<p>它调用的是<code>LambdaMetafactory.altMetafactory</code>,和上面的调用的方法不同。<br><code>#114 1</code>意味着要实现<code>Serializable</code>接口。</p>
<p>如果Lambda表达式写成``,则BootstrapMethods的字节码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BootstrapMethods:</div><div class="line">  <span class="number">0</span>: #<span class="number">57</span> invokestatic java/lang/invoke/LambdaMetafactory.altMetafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;</div><div class="line">    Method arguments:</div><div class="line">      #<span class="number">58</span> (Ljava/lang/Object;)V</div><div class="line">      #<span class="number">61</span> invokestatic com/colobu/lambda/chapter5/Lambda1.lambda$<span class="number">0</span>:(Ljava/lang/String;)V</div><div class="line">      #<span class="number">62</span> (Ljava/lang/String;)V</div><div class="line">      #<span class="number">63</span> <span class="number">2</span></div><div class="line">      #<span class="number">64</span> <span class="number">1</span></div><div class="line">      #<span class="number">65</span> com/colobu/lambda/chapter5/ABC</div></pre></td></tr></table></figure>

<p><code>#63 2</code>意味着要实现额外的接口。<code>#64 1</code>意味着要实现额外的接口的数量为1。</p>
<p>字节码的指令含义可以参考这篇文章：<a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="external">Java bytecode instruction listings</a>。</p>
<p>可以看到， Lambda表达式具体的转换是通过java.lang.invoke.LambdaMetafactory.metafactory实现的， 静态参数依照lambda表达式和目标类型不同而不同。</p>
<h2 id="LambdaMetafactory-metafactory">LambdaMetafactory.metafactory</h2>
<p>现在我们可以重点关注以下 <code>LambdaMetafactory.metafactory</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">metafactory</span>(MethodHandles.Lookup caller,</div><div class="line">                                       String invokedName,</div><div class="line">                                       MethodType invokedType,</div><div class="line">                                       MethodType samMethodType,</div><div class="line">                                       MethodHandle implMethod,</div><div class="line">                                       MethodType instantiatedMethodType)</div><div class="line">            <span class="keyword">throws</span> LambdaConversionException {返回值类型</div><div class="line">        AbstractValidatingLambdaMetafactory mf;</div><div class="line">        mf = <span class="keyword">new</span> InnerClassLambdaMetafactory(caller, invokedType,</div><div class="line">                                             invokedName, samMethodType,</div><div class="line">                                             implMethod, instantiatedMethodType,</div><div class="line">                                             <span class="keyword">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</div><div class="line">        mf.validateMetafactoryArgs();</div><div class="line">        <span class="keyword">return</span> mf.buildCallSite();</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>实际是由<code>InnerClassLambdaMetafactory</code>的<code>buildCallSite</code>来生成。 生成之前会调用<code>validateMetafactoryArgs</code>方法校验目标类型(SAM)方法的参数/和产生的方法的参数/返回值类型是否一致。</p>
<p><code>metaFactory</code>方法的参数：</p>
<ul>
<li>caller: 由JVM提供的lookup context</li>
<li>invokedName: JVM提供的NameAndType</li>
<li>invokedType: JVM提供的期望的CallSite类型</li>
<li>samMethodType: 函数式接口定义的方法的签名</li>
<li>implMethod: 编译时产生的那个实现方法</li>
<li>instantiatedMethodType: 强制的方法签名和返回类型， 一般和samMethodType相同或者是它的一个特例</li>
</ul>
<p>上面的代码基本上是<code>InnerClassLambdaMetafactory.buildCallSite</code>的包装，下面看看这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CallSite buildCallSite() <span class="keyword">throws</span> LambdaConversionException {</div><div class="line">       <span class="keyword">final</span> Class&lt;?&gt; innerClass = spinInnerClass();</div><div class="line">       <span class="keyword">if</span> (invokedType.parameterCount() == <span class="number">0</span>) {</div><div class="line">		..... <span class="comment">//调用构造函数初始化一个SAM的实例</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(MethodHandles.constant(samBase, inst));</div><div class="line">       } <span class="keyword">else</span> {</div><div class="line">           UNSAFE.ensureClassInitialized(innerClass);</div><div class="line">               <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(</div><div class="line">                       MethodHandles.Lookup.IMPL_LOOKUP</div><div class="line">                            .findStatic(innerClass, NAME_FACTORY, invokedType));</div><div class="line">       }</div><div class="line">   }</div></pre></td></tr></table></figure>

<p>其中<code>spinInnerClass</code>调用<code>asm</code>框架动态的产生SAM的实现类， 这个实现类的的方法将会调用编译时产生的那个实现方法。<br>你可以在编译的时候加上参数<code>-Djdk.internal.lambda.dumpProxyClasses</code>, 这样编译的时候会自动产生运行时<code>spinInnerClass</code>产生的类。<br>你可以访问OpenJDK的bug系统了解这个功能。 <a href="https://bugs.openjdk.java.net/browse/JDK-8023524" target="_blank" rel="external">JDK-8023524</a> </p>
<h2 id="重复的lambda表达式">重复的lambda表达式</h2>
<p>下面的代码中，在一个循环中重复生成调用lambda表达式，只会生成同一个lambda对象， 因为只有同一个<code>invokedynamic</code>指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++){</div><div class="line">	Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</div><div class="line">	System.out.println(c.hashCode());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是下面的代码会生成两个lambda对象, 因为它会生成两个<code>invokedynamic</code>指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</div><div class="line">System.out.println(c.hashCode());</div><div class="line">Consumer&lt;String&gt; c2 = s -&gt; System.out.println(s);</div><div class="line">System.out.println(c2.hashCode());</div></pre></td></tr></table></figure>

<h2 id="生成的类名">生成的类名</h2>
<p>既然LambdaMetafactory会使用<code>asm</code>框架生成一个匿名类， 那么这个类的类名有什么规律的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</div><div class="line">System.out.println(c.getClass().getName());</div><div class="line">System.out.println(c.getClass().getSimpleName());</div><div class="line">System.out.println(c.getClass().getCanonicalName());</div></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">com.colobu.lambda.chapter5.Lambda3$<span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">640070680</span></div><div class="line">Lambda3$<span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">640070680</span></div><div class="line">com.colobu.lambda.chapter5.Lambda3$<span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">640070680</span></div></pre></td></tr></table></figure>

<p>类名格式如 &lt;包名&gt;.&lt;类名&gt;$$Lambda$<number>/<nn>.<br>number是由一个计数器生成counter.incrementAndGet()。<br>后缀<code>/&lt;NN&gt;</code>中的数字是一个hash值, 那就是类对象的hash值<code>c.getClass().hashCode()</code>。<br>在<code>Klass::external_name()</code>中生成。</nn></number></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sprintf</span>(hash_buf, <span class="string">"/"</span> UINTX_FORMAT, (uintx)hash);</div></pre></td></tr></table></figure>

<h2 id="直接调用生成的方法">直接调用生成的方法</h2>
<p>上面提到， Lambda表达式体会由编译器生成一个方法，名字格式如<code>Lambda$XXX</code>。<br>既然是类中的实实在在的方法，我们就可以直接调用。当然， 你在代码中直接写<code>lambda$0()</code>编译通不过， 因为Lambda表达式体还没有被抽取成方法。<br>但是在运行中我们可以通过反射的方式调用。 下面的例子使用发射和MethodHandle两种方式调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Throwable {</div><div class="line">	Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</div><div class="line"></div><div class="line">	Method m = Lambda4.class.getDeclaredMethod(<span class="string">"lambda$0"</span>, String.class);</div><div class="line">	m.invoke(<span class="keyword">null</span>, <span class="string">"hello reflect"</span>);</div><div class="line"></div><div class="line">	MethodHandle mh = MethodHandles.lookup().findStatic(Lambda4.class, <span class="string">"lambda$0"</span>, MethodType.methodType(<span class="keyword">void</span>.class, String.class));</div><div class="line">	mh.invoke(<span class="string">"hello MethodHandle"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="捕获的变量等价于’final’">捕获的变量等价于’final’</h2>
<p>我们知道，在匿名类中调用外部的参数时，参数必须声明为<code>final</code>。<br>Lambda体内也可以引用上下文中的变量，变量可以不声明成<code>final</code>的，但是必须等价于<code>final</code>。<br>下面的例子中变量capturedV等价与<code>final</code>， 并没有在上下文中重新赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda5</span> </span>{</div><div class="line">	String greeting = <span class="string">"hello"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Throwable {</div><div class="line">		</div><div class="line">		Lambda5 capturedV = <span class="keyword">new</span> Lambda5();</div><div class="line">		Consumer&lt;String&gt; c = s -&gt; System.out.println(capturedV.greeting + <span class="string">" "</span> + s);</div><div class="line"></div><div class="line">		c.accept(<span class="string">"captured variable"</span>);</div><div class="line">		<span class="comment">//capturedV = null; //Local variable capturedV defined in an enclosing scope must be final or effectively final</span></div><div class="line">		<span class="comment">//capturedV.greeting = "hi";</span></div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果反注释<code>capturedV = null;</code>编译出错，因为capturedV在上下文中被改变。<br>但是如果反注释<code>capturedV.greeting = &quot;hi&quot;;</code> 则没问题， 因为capturedV没有被重新赋值， 只是它指向的对象的属性有所变化。</p>
<h2 id="方法引用">方法引用</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Throwable {</div><div class="line">	</div><div class="line">	Consumer&lt;String&gt; c  = System.out::println;</div><div class="line">	c.accept(<span class="string">"hello"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码不会产生一个类似”Lambda$0”新方法。 因为LambdaMetafactory会直接使用这个引用的方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BootstrapMethods:</div><div class="line">  <span class="number">0</span>: <span class="variable">#51</span> invokestatic java/lang/invoke/LambdaMetafactory<span class="built_in">.</span>metafactory:(Ljava/lang/invoke/MethodHandles<span class="variable">$Lookup</span>;Ljava/lang/<span class="built_in">String</span>;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</div><div class="line">    Method arguments:</div><div class="line">      <span class="variable">#52</span> (Ljava/lang/Object;)V</div><div class="line">      <span class="variable">#59</span> invokevirtual java/io/PrintStream<span class="built_in">.</span>println:(Ljava/lang/<span class="built_in">String</span>;)V</div><div class="line">      <span class="variable">#60</span> (Ljava/lang/<span class="built_in">String</span>;)V</div></pre></td></tr></table></figure>

<p><code>#59</code>指示实现方法为System.out::println</p>
]]></content>
    <summary type="html"><![CDATA[<p>再了解了Java 8 Lambda的一些基本概念和应用后， 我们会有这样的一个问题: <em>Lambda表达式被编译成了什么？</em>。 这是一个有趣的问题，涉及到JDK的具体的实现。 本文将介绍OpenJDK对Lambda表达式的转换细节， 读者可以了解Java 8 Lambda表达式背景知识。<br>]]></summary>
    
      <category term="Lambda" scheme="http://colobu.com/tags/Lambda/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[kernel 101 - 动手写内核]]></title>
    <link href="http://colobu.com/2014/11/05/kernel-101-lets-write-a-kernel/"/>
    <id>http://colobu.com/2014/11/05/kernel-101-lets-write-a-kernel/</id>
    <published>2014-11-05T08:33:21.000Z</published>
    <updated>2014-11-05T09:18:19.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://arjunsreedharan.org/" target="_blank" rel="external">Arjun Sreedharan</a>写的内核编写教程。 超级简单。<br>目前写了两篇：<br><a href="http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel" target="_blank" rel="external">Kernel 101 – Let’s write a Kernel</a><br><a href="http://arjunsreedharan.org/post/99370248137/kernel-201-lets-write-a-kernel-with-keyboard-and" target="_blank" rel="external">Kernel 201 - Let’s write a Kernel with keyboard and screen support</a></p>
<p>国内也有人翻译了，如</p>
<ul>
<li><a href="http://www.geekfan.net/8663/" target="_blank" rel="external">内核代号101 — 动手写自己的内核</a></li>
<li><a href="http://noalgo.info/649.html" target="_blank" rel="external">编写最简单的内核：HelloWorld</a></li>
</ul>
<p>以下是我根据上面的文章整理的翻译。<br><a id="more"></a><br>Hi, 大家好。</p>
<p>在这篇文章中，我们将从零开始，动手编写一个可以用GRUB来引导的简单x86内核，该内核会在屏幕上打印一条信息后挂起。<br><img src="http://static.tumblr.com/gltvynn/MDYn443cj/one-does-not-kernel.jpg" alt=""></p>
<h3 id="X86机器是怎样启动的？">X86机器是怎样启动的？</h3>
<p>在我们思考怎样写一个内核之前，让我们先看一下x86机器从启动到把控制权交给内核的过程是怎样的：<br>x86 CPU在机器启动之后就会从地址 <strong>[0xFFFFFFF0]</strong>处开始执行，这个地址就是在32位寻址空间中的最后16个字节处，这里存放了一条跳转指令，会跳转到内存中BIOS代码起始处。<br>接着，cpu就开始开始执行BIOS代码块了，BIOS首先会在我们配置好的启动设备序列中，通过检查一个特定的魔数，找到第一个可以引导的设备。<br>一旦BIOS找到一个可以引导的设备后，它就会把该设备第一个扇区的代码复制到物理内存的<strong>[0x7c00]</strong>的位置，然后跳转到这个地址开始执行这一段代码，我们习惯把这一段代码叫作<code>bootloader</code>。<br>Bootloader会将内核代码加载到物理内存<strong>[0x100000]</strong>的位置，[0x100000]这个地址是所有x86机器宏内核代码的起始地址。</p>
<h3 id="我们需要哪一些工具？">我们需要哪一些工具？</h3>
<ul>
<li>一个x86构架的计算机</li>
<li>Linux</li>
<li>NASM 汇编器</li>
<li>GCC</li>
<li>LD(GNU 连接器)</li>
<li>GRUB </li>
</ul>
<h3 id="源码">源码</h3>
<p>源代码可以在我的Github找到 <a href="http://github.com/arjun024/mkernel" target="_blank" rel="external">Github repository - mkernel</a></p>
<h3 id="用汇编代码来编写内核入口">用汇编代码来编写内核入口</h3>
<p>我们喜欢用c来做所有的事情，但是我们无可避免地需要用到一点儿汇编，我们将会写一小段x86的汇编代码来作为内核入口，这一段汇编代码会在调用我们的c代码后停止整个程序流程。<br>我们怎样确认汇编代码会作为内核的起始点呢？</p>
<blockquote>
<p>我们将用一个连接器脚本将这些目标文件链接成我们最终的内核程序（稍后解释更多），在连接器脚本里，我们指定了这段二进制代码会被加载到内存 [0x100000]处。这个地址就是我之前说过的，内核所希望的起始地址。</p>
</blockquote>
<p>汇编代码如下：</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;;kernel.asm</span></div><div class="line"><span class="built_in">bits</span> <span class="number">32</span>			<span class="comment">;nasm directive - 32 bit</span></div><div class="line"><span class="built_in">section</span> <span class="string">.text</span></div><div class="line"></div><div class="line"><span class="built_in">global</span> start</div><div class="line"><span class="built_in">extern</span> kmain	        <span class="comment">;kmain is defined in the c file</span></div><div class="line"><span class="label"></span></div><div class="line">start:</div><div class="line">  <span class="keyword">cli</span> 			<span class="comment">;block interrupts</span></div><div class="line">  <span class="keyword">call</span> kmain</div><div class="line">  <span class="keyword">hlt</span>		 	<span class="comment">;halt the CPU</span></div></pre></td></tr></table></figure>

<p>第一条指令 <code>bit32</code> 不是x86汇编指令，它是一条NASM 指令，指定nasm汇编器产生32位的程序，这条语句并不是必不可少的，但加上它是一个好的编程习惯。<br>第二行是text段(代码段)的开始，在这里存放着我们的代码块。<br><code>global</code>是另外一个NASM指令，用将一个符号设置为全局符号。这样做连接器才会知道符号<code>start</code>在哪儿开始，start是我们程序的入口地址。<br><code>kmain</code>是我们定义在kernel.c文件中的函数。<br><code>extern</code>关键字声明了该函数定义在别的文件中。<br>到这里，我们的函数start调用kmian函数之后就会使用<code>hlt</code>指令将CPU挂起,中断会cpu从<code>hlt</code>指令中唤醒，我们要在挂起之前用<code>cli</code>指令来关闭系统的中断响应，<code>cli</code>指令是清除中断(clear-interrupts)的缩写。</p>
<h3 id="用C实现的内核">用C实现的内核</h3>
<p>在<code>kernle.asm</code>中，我们调用了<code>kmain()</code>函数，所以我们的c代码将会在<code>kmain()</code>中开始运行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*  kernel.c</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> kmain(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">	<span class="keyword">char</span> *str = <span class="string">"my first kernel"</span>;</div><div class="line">	<span class="keyword">char</span> *vidptr = (<span class="keyword">char</span>*)<span class="number">0xb8000</span>; 	<span class="comment">//video mem begins here.</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">	<span class="comment">//clear all</span></div><div class="line">	<span class="keyword">while</span>(j &lt; <span class="number">80</span> * <span class="number">25</span> * <span class="number">2</span>) {</div><div class="line">		<span class="comment">//blank character</span></div><div class="line">		vidptr[j] = <span class="string">' '</span>;</div><div class="line">		<span class="comment">//attribute-byte: light grey on black screen	</span></div><div class="line">		vidptr[j+<span class="number">1</span>] = <span class="number">0x07</span>; 		</div><div class="line">		j = j + <span class="number">2</span>;</div><div class="line">	}</div><div class="line">	j = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(str[j] != <span class="string">'\0'</span>) {</div><div class="line">		vidptr[i] = str[j];</div><div class="line">		vidptr[i+<span class="number">1</span>] = <span class="number">0x07</span>;</div><div class="line">		++j;</div><div class="line">		i = i + <span class="number">2</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们的内核首先会清空整个屏幕，然后打印出字符串。<br>首先，我们用一个<code>vidptr</code>指针，指向地址<strong>[0xb8000]</strong>, 这个地址是保护模式下显存的起始地址。屏幕的文本内容对应着的内存空间中一个内存段，即屏幕的输出输出映射到了内存中地址[0xb8000]的地方，整个屏幕共支持25行，每行80个ASCII字符。<br>在文本内存中每一个字符由16bits(2个字节)表示，这不像我们以前使用8bits来定义。其中第一个字节是该字符的ASCII码，第二个字节是属性字节<code>attribute-byte</code>， 它描述了字符的表现形式，包括了字符颜色等属性。<br>为了在黑色的背景下打印绿色字符<code>s</code>，我们将字符<code>s</code>放在显存中的第一个字节，接着将[0x02]放在第二个字节中, 其中 <code>0</code>表示黑色背景，<code>2</code>表示绿色前景。</p>
<p>下面是不同颜色的定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> - <span class="keyword">Black</span>, <span class="number">1</span> - <span class="keyword">Blue</span>, <span class="number">2</span> - <span class="keyword">Green</span>, <span class="number">3</span> - <span class="keyword">Cyan</span>, <span class="number">4</span> - <span class="keyword">Red</span>, <span class="number">5</span> - <span class="keyword">Magenta</span>, <span class="number">6</span> - <span class="keyword">Brown</span>, <span class="number">7</span> - Light Grey, <span class="number">8</span> - Dark Grey, <span class="number">9</span> - Light <span class="keyword">Blue</span>, <span class="number">10</span>/a - Light <span class="keyword">Green</span>, <span class="number">11</span>/b - Light <span class="keyword">Cyan</span>, <span class="number">12</span>/c - Light <span class="keyword">Red</span>, <span class="number">13</span>/d - Light <span class="keyword">Magenta</span>, <span class="number">14</span>/e - Light <span class="keyword">Brown</span>, <span class="number">15</span>/f – <span class="keyword">White</span>.</div></pre></td></tr></table></figure>

<p>在我们的内核中，我们将字符颜色设置为灰色，将背景颜色设定为黑色，因此我们的属性字节的值是[0x07].<br>在第一个while循环中，程序将属性值为[0x07]的空格字符(‘  ’)写到整个屏幕中(共25行，每行80个字符)，这样就会将整个屏幕清空了。<br>在第二个while循环中，我们将null结尾的字符串 “my first kernel” ，从显存的起始处开始写入。<br>这样字符串就打印在屏幕上了</p>
<h3 id="链接部分">链接部分</h3>
<p>我们用NASM，GCC分别将<code>kernale.asm</code>，<code>kernel.c</code>编译成目标文件，接着将这些目标文件链接成一个可引导的内核程序。<br>我们指定ld连接器按照我们脚本规定来进行链接。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/<span class="keyword">*</span></div><div class="line"><span class="keyword">*</span>  link.ld</div><div class="line"><span class="keyword">*</span>/</div><div class="line">OUTPUT_FORMAT(elf32-i386)</div><div class="line">ENTRY(start)</div><div class="line">SECTIONS</div><div class="line"> {</div><div class="line">   . = 0x100000;</div><div class="line">   .text : { <span class="keyword">*</span>(.text) }</div><div class="line">   .data : { <span class="keyword">*</span>(.data) }</div><div class="line">   .bss  : { <span class="keyword">*</span>(.bss)  }</div><div class="line"> }</div></pre></td></tr></table></figure>

<p>脚本指定了输出格式为 32位的ELF文件格式. ELF（<a href="http://elinux.org/Executable_and_Linkable_Format_(ELF" target="_blank" rel="external">Executable and Linkable Format</a>)）是x86构架的类Unix系统标准的二进制格式。<br><strong>ENTRY</strong> 接收一个参数。它指定了可执行文件的入口符号。<br><strong>SECTIONS</strong>  对我们来讲是最重要的。在这里，我们定义即将生成的可执行文件的布局。我们可以定义各个段链接融合的方式以及放置的位置。<br>在<strong>SECTIONS</strong> 后的花括号中，符号 (.) 表示的是一个位置计数器。它通常会被初始化为<strong>[0x0]</strong>，作为SECTIONS 块的起始地址 ，它的值是可以被修改的。 之前我说过，内核代码需要在地址<strong>[0x100000]</strong>处，所以我们将它修改为<strong>[0x100000]</strong>。</p>
<p>接着看下一行的 <strong>.text : { *(.text) }</strong><br>星号( <em> )是一个通配符，表示所有的文件名。`</em>(.text)<code>表示将所有输入文件的</code>.text` 段<br>因此，按照这个设定，连接器将所有目标文件的text段融合到最终可执行文件的text 段中，即在位置计数器所标识的地址处 (<strong>[0x100000]</strong>)。<br>在连接器将处理好输出的text段后，地址计数器的值会变为<strong>[0x100000]</strong>+text段的长度。</p>
<p>类似的，data段和bss段也会相应得融合后放置到地址计数器所标识的位置。</p>
<h3 id="Grub和多重引导">Grub和多重引导</h3>
<p>现在我们已经准备好所有制作内核所需的文件了，但我们还有一步工作，我们还需要用<a href="http://www.gnu.org/software/grub/" target="_blank" rel="external">grub Bootloader</a>来启动我们的内核。<br>在按照Mutileboot 规范来编译我们的内核后，它就可以被GRUB引导了。<br>按照Mutileboot 的规范说明，内核必须在起始的8KB中包含这一个多引导项头（<a href="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html" target="_blank" rel="external">Multiboot header</a>)。<br>而且，这个多引导项头里面必须有3个4字节对齐的块。</p>
<ul>
<li>一个魔术块：包含了魔数<strong>[0x1BADB002]</strong>，是多引导项头结构的定义值。</li>
<li>一个标志块：我们不关心这个块的内容，我们简单设定为0。</li>
<li>一个校检块：校检块，魔术块和标志块的数值的总和必须是0。</li>
</ul>
<p>因此，我们的内核代码如下：</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;;kernel.asm</span></div><div class="line"></div><div class="line"><span class="comment">;nasm directive - 32 bit</span></div><div class="line"><span class="built_in">bits</span> <span class="number">32</span></div><div class="line"><span class="built_in">section</span> <span class="string">.text</span></div><div class="line">        <span class="comment">;multiboot spec</span></div><div class="line">        <span class="preprocessor">align</span> <span class="number">4</span></div><div class="line">        <span class="pseudo">dd</span> <span class="number">0x1BADB002</span>            <span class="comment">;magic</span></div><div class="line">        <span class="pseudo">dd</span> <span class="number">0x00</span>                  <span class="comment">;flags</span></div><div class="line">        <span class="pseudo">dd</span> - (<span class="number">0x1BADB002</span> + <span class="number">0x00</span>) <span class="comment">;checksum. m+f+c should be zero</span></div><div class="line"></div><div class="line"><span class="built_in">global</span> start</div><div class="line"><span class="built_in">extern</span> kmain	        <span class="comment">;kmain is defined in the c file</span></div><div class="line"><span class="label"></span></div><div class="line">start:</div><div class="line">  <span class="keyword">cli</span> 			<span class="comment">;block interrupts</span></div><div class="line">  <span class="keyword">call</span> kmain</div><div class="line">  <span class="keyword">hlt</span>		 	<span class="comment">;halt the CPU</span></div></pre></td></tr></table></figure>

<p>dd 指令定义了个4字节的双字。</p>
<h3 id="生成内核">生成内核</h3>
<p>我们现在开始将kernel.asm和kernel.c编译成目标文件，接着将它们根据我们的连接器脚本的设定链接到一起：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nasm <span class="operator">-f</span> elf32 kernel.asm -o kasm.o</div></pre></td></tr></table></figure>

<p>启动NASM汇编器将kernel.asm编译成ELF-32位格式的目标文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -m32 -<span class="built_in">c</span> kernel.<span class="built_in">c</span> -o kc.o</div></pre></td></tr></table></figure>

<p>-c选项告知GCC编译器在将源文件编译成目标文件后，不要对它们进行链接。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ld -<span class="keyword">m</span> elf_i386 -T <span class="keyword">link</span>.ld -o kernel kasm.o kc.o</div></pre></td></tr></table></figure>

<p>启动链接器，根据我们的链接脚本生成一个名为<strong>kernel</strong>的可执行的文件。</p>
<h3 id="配置grub,_启动内核">配置grub, 启动内核</h3>
<p>GRUB 需要以<code>kernel-&lt;version&gt;</code>的形式来命名内核程序，所以，我将它重名为kernel-701.<br>接着将它放在/boot目录下，这一步需要你需要拥有超级用户权限才能够进行操作。<br>在你的GRUB配置文件<code>grub.cfg</code>中加上一个引导入口，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title myKernel</div><div class="line">	root (hd0,0)</div><div class="line">	kernel /boot/kernel-701 ro</div></pre></td></tr></table></figure>

<p>如果存在一个<code>hiddenmenu</code>的指令，记得要把它移除掉。<br>重启电脑，你就能够看到你的内核也在启动选择项列表中了。<br>选择启动它之后，结果如下：<br><img src="http://static.tumblr.com/gltvynn/yOdn443dr/mkernel.png" alt=""></p>
<p>好了，你实现了一个简单的内核。</p>
<p>PS:</p>
<ul>
<li>建议你在虚拟机中进行你所有内核hacking。</li>
<li><p>在一些新的发行版中，使用了grub2作为默认的bootloader，你需要向下面这样来配置你的配置文件。</p>
<p>（感谢 Rubén Laguna提供了grub2的配置）</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">menuentry</span> <span class="string">'kernel 7001'</span> {</div><div class="line">	<span class="title">set</span> root=<span class="string">'hd0,msdos1'</span></div><div class="line">	multiboot /boot/kernel-<span class="number">7001</span> ro</div><div class="line">}</div></pre></td></tr></table></figure>


<ul>
<li>如果你想用<code>qemu</code>模拟器代替GRUB来启动你的内核程序的话，你可以怎么做：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">qemu-<span class="built_in">system</span>-i386 -kernel kernel</div></pre></td></tr></table></figure>

<p>本系列的下一篇文章。<br><a href="http://arjunsreedharan.org/post/99370248137/kernel-201-lets-write-a-kernel-with-keyboard-and" target="_blank" rel="external">Kernel 201 - Let’s write a Kernel with keyboard and screen support</a></p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="http://arjunsreedharan.org/" target="_blank" rel="external">Arjun Sreedharan</a>写的内核编写教程。 超级简单。<br>目前写了两篇：<br><a href="http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel" target="_blank" rel="external">Kernel 101 – Let’s write a Kernel</a><br><a href="http://arjunsreedharan.org/post/99370248137/kernel-201-lets-write-a-kernel-with-keyboard-and" target="_blank" rel="external">Kernel 201 - Let’s write a Kernel with keyboard and screen support</a></p>
<p>国内也有人翻译了，如</p>
<ul>
<li><a href="http://www.geekfan.net/8663/" target="_blank" rel="external">内核代号101 — 动手写自己的内核</a></li>
<li><a href="http://noalgo.info/649.html" target="_blank" rel="external">编写最简单的内核：HelloWorld</a></li>
</ul>
<p>以下是我根据上面的文章整理的翻译。<br>]]></summary>
    
      <category term="kernel" scheme="http://colobu.com/tags/kernel/"/>
    
      <category term="Linux" scheme="http://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 默认方法和多继承]]></title>
    <link href="http://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/"/>
    <id>http://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/</id>
    <published>2014-11-04T07:55:41.000Z</published>
    <updated>2014-11-06T09:18:00.000Z</updated>
    <content type="html"><![CDATA[<p>以前经常谈论的Java对比c++的一个优势是Java中没有多继承的问题。 因为Java中子类只能继承(extends)单个父类， 尽管可以实现(implements)多个接口，但是接口中只有抽象方法，方法体是空的，没有具体的方法实现，不会有方法冲突的问题。</p>
<p>这些都是久远的说法了，自从今年Java 8发布后， 接口中也可以定义方法了(default method)。 之所以打破以前的设计在接口中<br>增加具体的方法， 是为了既有的成千上万的Java类库的类增加新的功能， 且不必对这些类重新进行设计。 比如， 只需在Collection接口中<br>增加<code>default Stream&lt;E&gt; stream()</code>, 相应的<code>Set</code>和<code>List</code>接口以及它们的子类都包含此的方法， 不必为每个子类都重新copy这个方法。</p>
<p>这是一个折衷的设计，带来的问题就是为Java引入了多继承的问题。 我们知道， 接口可以继承接口， 类可以继承类和实现接口。 一旦继承的类和实现的接口中有<br>相同签名的方法， 会出现什么样的状况呢？ 本文将探讨各种情况的多继承， 以便能清楚的理解Java多继承的规则。<br><a id="more"></a></p>
<h2 id="接口继承多个父接口">接口继承多个父接口</h2>
<p>假定有三个接口Interface A, Interface B, Interface C,  继承关系如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>         <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line"><span class="comment">|</span>  <span class="comment">Interface</span> <span class="comment">A</span>  <span class="comment">|</span>         <span class="comment">|Interface</span> <span class="comment">B</span> <span class="comment">|</span></div><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">^</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>         <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">^</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line">            <span class="comment">|</span>                 <span class="comment">|</span>         </div><div class="line">            <span class="comment">|</span>                 <span class="comment">|</span>         </div><div class="line">            <span class="comment">|</span>                 <span class="comment">|</span>         </div><div class="line">            <span class="literal">+</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>         </div><div class="line">              <span class="comment">|</span> <span class="comment">Interface</span> <span class="comment">C|</span>            </div><div class="line">              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div></pre></td></tr></table></figure>

<p>A,B拥有相同签名的默认方法<code>default String say(String name)</code>, 如果接口C没有override这个方法， 则编译出错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">   interface A {</div><div class="line">	<span class="keyword">default</span> String say(String name) {</div><div class="line">		<span class="keyword">return</span> <span class="string">"hello "</span> + name;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface B {</div><div class="line">	<span class="keyword">default</span> String say(String name) {</div><div class="line">		<span class="keyword">return</span> <span class="string">"hi "</span> + name;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface C extends A,B{</div><div class="line">	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>错误信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Lambda\src&gt;javac -J-Duser.country=US com\colobu\lambda\chap</div><div class="line">ter3\MultipleInheritance1.java</div><div class="line">com\colobu\lambda\chapter3\MultipleInheritance1.java:<span class="number">17</span>: error: <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="title">inherits</span> <span class="title">unrelated</span> <span class="title">defaults</span> <span class="title">for</span> <span class="title">say</span>(<span class="title">String</span>) <span class="title">from</span> <span class="title">types</span> <span class="title">A</span> <span class="title">and</span> <span class="title">B</span></span></div><div class="line">        <span class="title">static</span> <span class="title">interface</span> <span class="title">C</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">A</span>,<span class="title">B</span>{</div><div class="line">               ^</div><div class="line"><span class="number">1</span> error</div></pre></td></tr></table></figure>

<p>我们可以在子接口<code>C</code>中覆盖override这个方法, 这样编译就不会出错了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   interface C extends A,B{</div><div class="line">	<span class="keyword">default</span> String say(String name) {</div><div class="line">		<span class="keyword">return</span> <span class="string">"greet "</span> + name;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意方法签名不包括方法的返回值， 也就是仅仅返回值不同的两个方法的签名也是相同的。<br>下面的代码编译不会出错，因为<code>A</code>和<code>B</code>的默认方法不同， C隐式继承了两个默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">interface A {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> name) {</div><div class="line">		</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface B {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(String name) {</div><div class="line">		</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface C extends A,B{</div><div class="line">	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是有的情况下即使是不同签名的方法也是很难分辨的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">interface A {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> a) {</div><div class="line">		System.out.println(<span class="string">"A"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface B {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">short</span> a) {</div><div class="line">		System.out.println(<span class="string">"B"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface C extends A,B{</div><div class="line">	</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> class D implements C {</div><div class="line">	</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">	D d = <span class="keyword">new</span> D();</div><div class="line">	<span class="keyword">byte</span> a = <span class="number">1</span>;</div><div class="line">	d.say(a); <span class="comment">//B</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Java会选择最适合的方法， 请参看<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5" target="_blank" rel="external">Java规范 15.12.2.5</a></p>
<h2 id="接口多层继承">接口多层继承</h2>
<p>下面看一下多层继承的问题。 继承关系如下图， A2继承A1, C继承A2。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="code">+---------------+</span> </div><div class="line">|  Interface A1 | </div><div class="line"><span class="code">+--------+</span>------+ </div><div class="line"><span class="code">         |        </span></div><div class="line"><span class="code">         |        </span></div><div class="line"><span class="code">         |        </span></div><div class="line"><span class="code">+--------+</span>------+ </div><div class="line">|  Interface A2 | </div><div class="line"><span class="code">+-------+</span>-------+ </div><div class="line"><span class="code">        |         </span></div><div class="line"><span class="code">        |         </span></div><div class="line"><span class="header">        |         </span></div><div class="line">+-------+--------+</div><div class="line"><span class="header">|   Interface C  |</span></div><div class="line">+----------------+</div></pre></td></tr></table></figure>

<p>基于我们以前对类继承的认识， 很容易知道C会继承A2的默认方法，包括直接定义的默认方法， 覆盖的默认方法，以及隐式继承于A1接口的默认方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>{</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> a) {</div><div class="line">		System.out.println(<span class="string">"A"</span>);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> run() {</div><div class="line">		System.out.println(<span class="string">"A.run"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">A</span></span>{</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> a) {</div><div class="line">		System.out.println(<span class="string">"B"</span>);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> play() {</div><div class="line">		System.out.println(<span class="string">"B.play"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">A</span>,<span class="title">B</span></span>{</div><div class="line">	</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="多层多继承">多层多继承</h2>
<p>上面一个例子还是单继承的例子， 如果如下图的多继承呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="code">+---------------+</span>                          </div><div class="line">|  Interface A1 |                          </div><div class="line"><span class="code">+--------+</span>------+                          </div><div class="line"><span class="code">         |                                 </span></div><div class="line"><span class="code">         |                                 </span></div><div class="line"><span class="code">         |                                 </span></div><div class="line"><span class="code">+--------+</span>------<span class="code">+         +</span>---------------+</div><div class="line">|  Interface A2 |         |  Interface B  |</div><div class="line"><span class="code">+-------+</span>-------<span class="code">+         +</span>---------<span class="code">+-----+</span></div><div class="line"><span class="code">        |       +---------+---------^      </span></div><div class="line"><span class="code">        |       |                          </span></div><div class="line"><span class="code">        |       |                          </span></div><div class="line"><span class="code">+-------+</span>-------++                         </div><div class="line"><span class="header">|   Interface C  |                         </span></div><div class="line">+----------------+</div></pre></td></tr></table></figure>

<p>如果A2和B拥有相同签名的方法，这和第一个例子一样。 如果不想编译出错，可以覆盖父接口的默认方法，还可以调用指定父接口的默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">interface A1 {</div><div class="line">		<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> a) {</div><div class="line">			System.out.println(<span class="string">"A1"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	interface A2 extends A1 {</div><div class="line">		</div><div class="line">	}</div><div class="line">	</div><div class="line">	interface B {</div><div class="line">		<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> a) {</div><div class="line">			System.out.println(<span class="string">"B"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	interface C extends A2,B{</div><div class="line">		<span class="keyword">default</span> <span class="keyword">void</span> say(<span class="keyword">int</span> a) {</div><div class="line">			B.<span class="keyword">super</span>.say(a);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h2 id="更复杂的多层多继承">更复杂的多层多继承</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> +--------------+              </div><div class="line"> <span class="string">| Interface A1 |              </span></div><div class="line"> +------+------++              </div><div class="line">        <span class="string">|      ^+-------+      </span></div><div class="line">        <span class="string">|               |      </span></div><div class="line">+-------+-------+       <span class="string">|      </span></div><div class="line"><span class="string">|  Interface A2 |       |      </span></div><div class="line">+------------+--+       <span class="string">|      </span></div><div class="line">             ^--++      <span class="string">|      </span></div><div class="line">                 <span class="string">|      |      </span></div><div class="line">              +--+------+-----+</div><div class="line">              <span class="string">|  Interface C  |</span></div><div class="line">              +---------------+</div></pre></td></tr></table></figure>

<p>接口A2继承A1， 接口C继承A2和A1。 代码如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">interface A1 {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say() {</div><div class="line">		System.out.println(<span class="string">"A1"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">interface A2 extends A1 {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say() {</div><div class="line">		System.out.println(<span class="string">"A2"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">interface C extends A2,A1{</div><div class="line">	</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> class D implements C {</div><div class="line">	</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">	D d = <span class="keyword">new</span> D();</div><div class="line">	d.say();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上代码不会编译出错，运行输出<code>A2</code>。<br>可以看到接口C会隐式继承子接口的方法， 也就是子接口A2的默认方法。</p>
<h2 id="类继承">类继承</h2>
<p>如果继承关系类型全部是类， 那么由于类依然是单继承的， 不会有多继承的问题。</p>
<h2 id="类和接口混杂">类和接口混杂</h2>
<p>我们把第一个例子中的其中一个接口换成类，会出现什么现象呢。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>       <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line"><span class="comment">|</span> <span class="comment">Interface</span> <span class="comment">A</span> <span class="comment">|</span>       <span class="comment">|</span>  <span class="comment">Class</span> <span class="comment">B</span>  <span class="comment">|</span></div><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">+</span>       <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line">            <span class="comment">^</span><span class="literal">-</span><span class="literal">+</span>    <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">^</span>      </div><div class="line">              <span class="comment">|</span>    <span class="comment">|</span>               </div><div class="line">          <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">+</span>             </div><div class="line">          <span class="comment">|</span>  <span class="comment">Class</span> <span class="comment">C</span> <span class="comment">|</span>             </div><div class="line">          <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div></pre></td></tr></table></figure>

<p>以下代码不会编译出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">interface A {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say() {</div><div class="line">		System.out.println(<span class="string">"A"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> class B {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>() {</div><div class="line">		System.out.println(<span class="string">"B"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> class C extends B implements A{</div><div class="line">	</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">	C c = <span class="keyword">new</span> C();</div><div class="line">	c.say(); <span class="comment">//B</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>结果输出<code>B</code>。<br>可以看出， 子类优先继承父类的方法， 如果父类没有相同签名的方法，才继承接口的默认方法。</p>
<h2 id="结论">结论</h2>
<p>更复杂的继承关系可以简化成以上的继承关系。<br>根据以上的例子， 可以得出以下的结论：</p>
<ul>
<li>类优先于接口。 如果一个子类继承的父类和接口有相同的方法实现。 那么子类继承父类的方法</li>
<li>子类型中的方法优先于父类型中的方法。 </li>
<li>如果以上条件都不满足， 则必须显示覆盖/实现其方法，或者声明成abstract。</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>以前经常谈论的Java对比c++的一个优势是Java中没有多继承的问题。 因为Java中子类只能继承(extends)单个父类， 尽管可以实现(implements)多个接口，但是接口中只有抽象方法，方法体是空的，没有具体的方法实现，不会有方法冲突的问题。</p>
<p>这些都是久远的说法了，自从今年Java 8发布后， 接口中也可以定义方法了(default method)。 之所以打破以前的设计在接口中<br>增加具体的方法， 是为了既有的成千上万的Java类库的类增加新的功能， 且不必对这些类重新进行设计。 比如， 只需在Collection接口中<br>增加<code>default Stream&lt;E&gt; stream()</code>, 相应的<code>Set</code>和<code>List</code>接口以及它们的子类都包含此的方法， 不必为每个子类都重新copy这个方法。</p>
<p>这是一个折衷的设计，带来的问题就是为Java引入了多继承的问题。 我们知道， 接口可以继承接口， 类可以继承类和实现接口。 一旦继承的类和实现的接口中有<br>相同签名的方法， 会出现什么样的状况呢？ 本文将探讨各种情况的多继承， 以便能清楚的理解Java多继承的规则。<br>]]></summary>
    
      <category term="Lambda" scheme="http://colobu.com/tags/Lambda/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8函数式接口functional interface的秘密]]></title>
    <link href="http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/"/>
    <id>http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/</id>
    <published>2014-10-28T07:42:53.000Z</published>
    <updated>2014-11-06T09:17:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong>函数式接口(Functional Interface)</strong>是Java 8对一类特殊类型的接口的称呼。 这类接口只定义了唯一的抽象方法的接口（除了隐含的Object对象的公共方法）， 因此最开始也就做<strong>SAM</strong>类型的接口（Single Abstract Method）。</p>
<p>为什么会单单从接口中定义出此类接口呢？ 原因是在Java Lambda的实现中， 开发组不想再为Lambda表达式单独定义一种特殊的Structural函数类型，称之为箭头类型（arrow type）， 依然想采用Java既有的类型系统(class, interface, method等)， 原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的Java类型，并对成千上万的Java类库造成严重的影响。 权衡利弊， 因此最终还是利用SAM 接口作为 Lambda表达式的目标类型。</p>
<p>JDK中已有的一些接口本身就是函数式接口，如<code>Runnable</code>。 JDK 8中又增加了<code>java.util.function</code>包， 提供了常用的函数式接口。</p>
<p>函数式接口代表的一种契约， 一种对某个特定函数类型的契约。 在它出现的地方，实际期望一个符合契约要求的函数。 Lambda表达式不能脱离上下文而存在，它必须要有一个明确的目标类型，而这个目标类型就是某个函数式接口。</p>
<p><a id="more"></a><br>当然， Java 8发布快一年了， 你对以上的概念也应该有所了解了，这篇文章也不会介绍这些基础的东西， 而是想深入的探讨函数式接口的定义和应用。</p>
<h2 id="JDK_8之前已有的函数式接口">JDK 8之前已有的函数式接口</h2>
<ul>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.security.PrivilegedAction</li>
<li>java.util.Comparator</li>
<li>java.io.FileFilter</li>
<li>java.nio.file.PathMatcher</li>
<li>java.lang.reflect.InvocationHandler</li>
<li>java.beans.PropertyChangeListener</li>
<li>java.awt.event.ActionListener</li>
<li>javax.swing.event.ChangeListener</li>
</ul>
<h2 id="新定义的函数式接口">新定义的函数式接口</h2>
<p><code>java.util.function</code>中定义了几组类型的函数式接口以及针对基本数据类型的子接口。</p>
<ul>
<li>Predicate<t> — 传入一个参数，返回一个bool结果， 方法为<code>boolean test(T t)</code></t></li>
<li>Consumer<t> — 传入一个参数，无返回值，纯消费。 方法为<code>void accept(T t)</code></t></li>
<li>Function<t,r> — 传入一个参数，返回一个结果，方法为<code>R apply(T t)</code></t,r></li>
<li>Supplier<t> — 无参数传入，返回一个结果，方法为<code>T get()</code></t></li>
<li>UnaryOperator<t> — 一元操作符， 继承Function<t,t>,传入参数的类型和返回类型相同。</t,t></t></li>
<li>BinaryOperator<t> — 二元操作符， 传入的两个参数的类型和返回类型相同， 继承BiFunction<t,t,t></t,t,t></t></li>
</ul>
<p>Java API对函数式接口都已经标明了， 如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">java.lang</div><div class="line"><span class="keyword">Interface</span> Runnable</div><div class="line"></div><div class="line">    All Known Subinterfaces:</div><div class="line">        RunnableFuture&lt;V&gt;, RunnableScheduledFuture&lt;V&gt;</div><div class="line"></div><div class="line">    All Known Implementing Classes:</div><div class="line">        AsyncBoxView.ChildState, ForkJoinWorkerThread, FutureTask, RenderableImageProducer, SwingWorker, Thread, TimerTask</div><div class="line"></div><div class="line">    Functional <span class="keyword">Interface</span>:</div><div class="line">        This <span class="keyword">is</span> a functional <span class="keyword">interface</span> <span class="keyword">and</span> can therefore be used <span class="keyword">as</span> the assignment target <span class="keyword">for</span> a lambda expression <span class="keyword">or</span> <span class="function"><span class="keyword">method</span> <span class="title">reference</span>.</span></div></pre></td></tr></table></figure>

<h2 id="函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样">函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样</h2>
<p>接口最终有确定的类实现， 而类的最终父类是Object。 因此函数式接口可以定义Object的public方法。<br>如以下的接口依然是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectMethodFunctionalInterface</span> </span>{</div><div class="line">	<span class="keyword">void</span> count(<span class="keyword">int</span> i);</div><div class="line">	</div><div class="line">	String toString(); <span class="comment">//same to Object.toString</span></div><div class="line">	<span class="keyword">int</span> hashCode(); <span class="comment">//same to Object.hashCode</span></div><div class="line">	<span class="keyword">boolean</span> equals(Object obj); <span class="comment">//same to Object.equals</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>为什么限定<code>public</code>类型的方法呢？因为接口中定义的方法都是<code>public</code>类型的。 举个例子，下面的接口就不是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface WrongObjectMethodFunctionalInterface {</div><div class="line">	<span class="keyword">void</span> count(<span class="keyword">int</span> i);</div><div class="line">	</div><div class="line">	Object clone(); <span class="comment">//Object.clone is protected</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为<code>Object.clone</code>方法是<code>protected</code>类型。</p>
<h2 id="声明异常">声明异常</h2>
<p>函数式接口的抽象方法可以声明 <code>可检查异常</code>(checked exception)。 在调用目标对象的这个方法时必须catch这个异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> FunctionalInterfaceWithException {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		InterfaceWithException target = i -&gt; {};</div><div class="line">		<span class="keyword">try</span> {</div><div class="line">			target.apply(<span class="number">10</span>);</div><div class="line">		} <span class="keyword">catch</span> (Exception e) {</div><div class="line">			e.printStackTrace();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line">@FunctionalInterface</div><div class="line"><span class="keyword">interface</span> InterfaceWithException {</div><div class="line">	<span class="keyword">void</span> apply(<span class="keyword">int</span> i) throws Exception;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这和以前的接口/方法调用一样。</p>
<p>但是，如果在Lambda表达式中抛出异常， 而目标接口中的抽象函数没有声明这个可检查， 则此接口不能作为此lambda表达式的目标类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceWithException</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		InterfaceWithException target = i -&gt; {<span class="keyword">throw</span> <span class="keyword">new</span> Exception();};</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line">interface InterfaceWithException {</div><div class="line">	<span class="keyword">void</span> apply(<span class="keyword">int</span> i);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的例子中不能编译， 因为lambda表达式要求的目标类型和<code>InterfaceWithException</code>不同。 <code>InterfaceWithException</code>的函数没有声明异常。</p>
<h2 id="静态方法">静态方法</h2>
<p>函数式接口中除了那个抽象方法外还可以包含静态方法。<br>Java 8以前的规范中接口中不允许定义静态方法。 静态方法只能在类中定义。 Java 8中可以定义静态方法。</p>
<p>一个或者多个静态方法不会影响SAM接口成为函数式接口。<br>下面的例子中<code>FunctionalInterfaceWithStaticMethod</code>包含一个SAM: <code>apply</code>,还有一个静态方法<code>sum</code>。 它依然是函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line">interface FunctionalInterfaceWithStaticMethod {</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum(<span class="keyword">int</span>[] array) {</div><div class="line">		<span class="keyword">return</span> Arrays.stream(array).reduce((a, b) -&gt; a+b).getAsInt();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">void</span> apply();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethodFunctionalInterface</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		<span class="keyword">int</span> sum = FunctionalInterfaceWithStaticMethod.sum(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>});</div><div class="line">		</div><div class="line">		FunctionalInterfaceWithStaticMethod f = () -&gt; {};</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="默认方法">默认方法</h2>
<p>Java 8中允许接口实现方法， 而不是简单的声明， 这些方法叫做默认方法，使用特殊的关键字<code>default</code>。<br>因为默认方法不是抽象方法，所以不影响我们判断一个接口是否是函数式接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceWithDefaultMethod</span> </span>{</div><div class="line">	<span class="keyword">void</span> apply(<span class="built_in">Object</span> obj);</div><div class="line">	</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> say(String name) {</div><div class="line">		System.out.println(<span class="string">"hello "</span> + name);</div><div class="line">	}</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceWithDefaultMethod</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {</div><div class="line">		InterfaceWithDefaultMethod i = (o) -&gt; {};</div><div class="line">		i.apply(<span class="literal">null</span>);</div><div class="line">		i.say(<span class="string">"default method"</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>InterfaceWithDefaultMethod</code>仍然是一个函数式接口。</p>
<h2 id="泛型及继承关系">泛型及继承关系</h2>
<p>接口可以继承接口。 如果父接口是一个函数接口， 那么子接口也可能是一个函数式接口。 判断标准依据下面的条件：</p>
<blockquote>
<p>对于接口<code>I</code>, 假定<code>M</code>是接口成员里的所有抽象方法的继承(包括继承于父接口的方法)， 除去具有和Object的public的实例方法签名的方法， 那么我们可以依据下面的条件判断一个接口是否是函数式接口， 这样可以更精确的定义函数式接口。<br>如果存在一个一个方法m， 满足：</p>
<ul>
<li>m的签名（subsignature）是M中每一个方法签名的子签名（signature）</li>
<li>m的返回值类型是M中的每一个方法的返回值类型的替代类型（return-type-substitutable）<br>那么I就是一个函数式接口。 </li>
</ul>
</blockquote>
<p>看几个例子。</p>
<h3 id="1)">1)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface X { <span class="keyword">int</span> m(Iterable&lt;String&gt; arg); }</div><div class="line">interface Y { <span class="keyword">int</span> m(Iterable&lt;String&gt; arg); }</div><div class="line">interface Z extends X, Y {}</div></pre></td></tr></table></figure>

<p>接口<code>Z</code>继承了<code>X</code>,<code>Y</code>接口的<code>m</code>方法，由于这两个方法的签名相同，返回值也一样，所以<code>Z</code>有唯一的一个抽象方法<code>int m(Iterable&lt;String&gt; arg);</code>,可以作为函数式接口。</p>
<h3 id="2)">2)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface X { Iterable m(Iterable&lt;String&gt; arg); }</div><div class="line">interface Y { Iterable&lt;String&gt; m(Iterable arg); }</div><div class="line">interface Z extends X, Y {}</div></pre></td></tr></table></figure>

<p>方法签名<code>Y.m</code> 既满足签名是<code>X.m</code>，并且返回值也满足<code>return-type-substitutable</code>。所以<code>Z</code>是函数式接口，函数类型为<code>Iterable&lt;String&gt; m(Iterable arg)</code>。</p>
<h3 id="3)">3)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface X { <span class="keyword">int</span> m(Iterable&lt;String&gt; arg); }</div><div class="line">interface Y { <span class="keyword">int</span> m(Iterable&lt;Integer&gt; arg); }</div><div class="line">interface Z extends X, Y {}</div></pre></td></tr></table></figure>

<p>编译出错， 没有一个方法的签名是所有方法的子签名：</p>
<h3 id="4)">4)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface X { <span class="keyword">int</span> m(Iterable&lt;String&gt; arg, Class c); }</div><div class="line">interface Y { <span class="keyword">int</span> m(Iterable arg, Class&lt;?&gt; c); }</div><div class="line">interface Z extends X, Y {}</div></pre></td></tr></table></figure>

<p>Compiler error: No method has a subsignature of all abstract methods<br>编译出错， 没有一个方法的签名是所有方法的子签名</p>
<h3 id="5)">5)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface X { <span class="keyword">long</span> m(); }</div><div class="line">interface Y { <span class="keyword">int</span> m(); }</div><div class="line">interface Z extends X, Y {}</div></pre></td></tr></table></figure>

<p>Compiler error: no method is return type substitutable<br>编译出错， 返回值类型不同。</p>
<h3 id="6)">6)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface Foo&lt;T&gt; { <span class="keyword">void</span> m(T arg); }</div><div class="line">interface Bar&lt;T&gt; { <span class="keyword">void</span> m(T arg); }</div><div class="line">interface FooBar&lt;X, Y&gt; extends Foo&lt;X&gt;, Bar&lt;Y&gt; {}</div></pre></td></tr></table></figure>

<p>Compiler error: different signatures, same erasure<br>编译出错</p>
<h3 id="7)">7)</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>{ <span class="keyword">void</span> m(String arg); }</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bar</span>&lt;<span class="title">T</span>&gt; </span>{ <span class="keyword">void</span> m(T arg); }</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooBar</span>&lt;<span class="title">T</span>&gt; <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Foo</span>, <span class="title">Bar</span>&lt;<span class="title">T</span>&gt; </span>{}</div></pre></td></tr></table></figure>

<p>不是一个函数式接口， 两个方法的类型参数不一样。</p>
<h3 id="8)">8)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface X { <span class="keyword">void</span> m() <span class="keyword">throws</span> IOException; }</div><div class="line">interface Y { <span class="keyword">void</span> m() <span class="keyword">throws</span> EOFException; }</div><div class="line">interface Z { <span class="keyword">void</span> m() <span class="keyword">throws</span> ClassNotFoundException; }</div><div class="line">interface XY extends X, Y {}</div><div class="line">interface XYZ extends X, Y, Z {}</div></pre></td></tr></table></figure>

<p><code>X.m</code>,<code>Y.m</code>,<code>Z.m</code>方法签名相同，返回值类型都是void，只是异常列表不同。 <code>EOFException</code>是<code>IOException</code>的子类。<br>在这种情况下<code>XY</code>和<code>XYZ</code>都是函数式接口，但是函数类型不同。<br>// XY has function type ()-&gt;void throws EOFException<br>// XYZ has function type ()-&gt;void (throws nothing)</p>
<h3 id="9)">9)</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>{</div><div class="line">  <span class="keyword">List</span>&lt;String&gt; foo(<span class="keyword">List</span>&lt;String&gt; arg) throws IOException, SQLTransientException;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>{</div><div class="line">  <span class="keyword">List</span> foo(<span class="keyword">List</span>&lt;String&gt; arg) throws EOFException, SQLException, TimeoutException;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>{</div><div class="line">  <span class="keyword">List</span> foo(<span class="keyword">List</span> arg) throws <span class="keyword">Exception</span>;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">A</span>, <span class="title">B</span> </span>{}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span> <span class="keyword">extends</span> <span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span> </span>{}</div></pre></td></tr></table></figure>

<p>// D has function type (List<string>)-&gt;List<string> throws EOFException, SQLTransientException<br>// E has function type (List)-&gt;List throws EOFException, SQLTransientException</string></string></p>
<h3 id="10)">10)</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">G1</span> </span>{</div><div class="line">  &lt;E extends <span class="keyword">Exception</span>&gt; Object m() throws E;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">G2</span> </span>{</div><div class="line">  &lt;F extends <span class="keyword">Exception</span>&gt; String m() throws <span class="keyword">Exception</span>;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">G1</span>, <span class="title">G2</span> </span>{}</div></pre></td></tr></table></figure>

<p>// G has function type <f extends="" exception=""> ()-&gt;String throws F</f></p>
<h2 id="函数式接口的交集">函数式接口的交集</h2>
<h3 id="1)-1">1)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Object o = (I & J) () -&gt; {};</div><div class="line">	}</div><div class="line">}</div><div class="line">interface I {</div><div class="line">	<span class="keyword">void</span> foo();</div><div class="line">}</div><div class="line"></div><div class="line">interface J {</div><div class="line">	<span class="keyword">void</span> foo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>I和J方法的交集依然符合函数式接口的定义。 上述代码可以用JDK中的javac编译通过但是Eclipse报错，这是Eclipse的一个bug。</p>
<h3 id="2)-1">2)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Object o = (I & J) () -&gt; {};</div><div class="line">	}</div><div class="line">}</div><div class="line">interface I {</div><div class="line">	<span class="keyword">void</span> foo();</div><div class="line">}</div><div class="line"></div><div class="line">interface J {</div><div class="line">	<span class="keyword">void</span> foo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述代码Eclipse不会报错但是javac无法编译，javac认为 (I &amp; J)不是一个函数式接口。 看起来javac工作正常， Eclipse处理这样的case还有问题。</p>
<h2 id="@FunctionalInterface">@FunctionalInterface</h2>
<p>Java 不会强制要求你使用@FunctionalInterface注解来标记你的接口是函数式接口， 然而，作为API作者， 你可能倾向使用@FunctionalInterface指明特定的接口为函数式接口， 这只是一个设计上的考虑， 可以让用户很明显的知道一个接口是函数式接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> SimpleFuncInterface {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span>();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你在一个不是函数式的接口使用@FunctionalInterface标记的话，会出现什么情况？编译时出错。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">error: Unexpected <span class="keyword">@FunctionalInterface</span> annotation</div><div class="line"><span class="keyword">@FunctionalInterface</span></div><div class="line">^</div><div class="line">  I <span class="keyword">is</span> not a functional <span class="keyword">interface</span></div><div class="line">    multiple non-overriding <span class="keyword">abstract</span> methods found <span class="keyword">in</span> <span class="keyword">interface</span> I</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p><strong>函数式接口(Functional Interface)</strong>是Java 8对一类特殊类型的接口的称呼。 这类接口只定义了唯一的抽象方法的接口（除了隐含的Object对象的公共方法）， 因此最开始也就做<strong>SAM</strong>类型的接口（Single Abstract Method）。</p>
<p>为什么会单单从接口中定义出此类接口呢？ 原因是在Java Lambda的实现中， 开发组不想再为Lambda表达式单独定义一种特殊的Structural函数类型，称之为箭头类型（arrow type）， 依然想采用Java既有的类型系统(class, interface, method等)， 原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的Java类型，并对成千上万的Java类库造成严重的影响。 权衡利弊， 因此最终还是利用SAM 接口作为 Lambda表达式的目标类型。</p>
<p>JDK中已有的一些接口本身就是函数式接口，如<code>Runnable</code>。 JDK 8中又增加了<code>java.util.function</code>包， 提供了常用的函数式接口。</p>
<p>函数式接口代表的一种契约， 一种对某个特定函数类型的契约。 在它出现的地方，实际期望一个符合契约要求的函数。 Lambda表达式不能脱离上下文而存在，它必须要有一个明确的目标类型，而这个目标类型就是某个函数式接口。</p>
<p>]]></summary>
    
      <category term="Lambda" scheme="http://colobu.com/tags/Lambda/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[循环冗余校验CRC简介]]></title>
    <link href="http://colobu.com/2014/10/22/CRC-introduction/"/>
    <id>http://colobu.com/2014/10/22/CRC-introduction/</id>
    <published>2014-10-22T01:07:24.000Z</published>
    <updated>2014-10-22T01:15:43.000Z</updated>
    <content type="html"><![CDATA[<p>循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据数据包或电脑文件等数据产生简短固定位数校验码的一种散列函數，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。一般来说，循环冗余校验的值都是32位的整数。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。此方是由W. Wesley Peterson于1961年发表。<br>CRC为校验和的一种，是两个字节数据流采用二进制除法（没有借位和进位，使用异或来代替减法）相除所得到的余数。其中被除数是需要计算校验和的信息数据流的二进制表示；除数是一个长度为(n+1)的预定义二进制数，通常用多项式的系数来表示。在做除法之前，要在信息数据之后先加上n个0. 冗余码的位数是n位。<br>冗余码的计算方法是，先将信息码后面补0，补0的个数是生成多项式最高次幂；将补零之后的信息码用模二除法（非二进制除法）除以G(X)对应的2进制码，注意除法过程中所用的减法是模2减法，即没有借位的减法，也就是异或运算。当被除数逐位除完时，得到比除数少一位的余数。此余数即为冗余位,将其添加在信息位后便构成CRC码字。</p>
<p>例如，假设信息码字为<code>11100011</code>，生成多项式G(X)=X^5+X^4+X+1，计算CRC码字。G(X) = X^5+X^4+X+1,也就是<code>110011</code>，因为最高次是5，所以，在信息码字后补5个0，变为1110001100000。用1110001100000模二除法除以110011，余数为<code>11010</code>，即为所求的冗余位。<br>因此发送出去的CRC码字为原始码字11100011末尾加上冗余位11010，即 <code>1110001111010</code>。接收端收到码字后，采用同样的方法验证，即将收到的码字用模二除法除以110011（是G(X)对应的二进制生成码），发现余数是0，则认为码字在传输过程中没有出错。</p>
<p>尽管在错误检测中非常有用，CRC并不能可靠地校验数据完整性（即数据没有发生任何变化），这是因为CRC多项式是线性结构，可以非常容易地故意改变量据而维持CRC不变。</p>
]]></content>
    
    
      <category term="网络编程" scheme="http://colobu.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单播，组播(多播)，广播以及任播]]></title>
    <link href="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/"/>
    <id>http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/</id>
    <published>2014-10-21T05:52:55.000Z</published>
    <updated>2014-11-12T08:41:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>单播</strong>(unicast): 是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。<br><strong>组播</strong>(multicast): 也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。<br><strong>广播</strong>(broadcast):是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。<br><strong>任播</strong>(anycast):是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。</p>
<p>在Linux运行<code>ifconfig</code>, 如果网卡信息中包含<code>UP BROADCAST RUNNING MULTICAST</code>，则支持广播和组播。</p>
<a id="more"></a>

<h2 id="详细介绍">详细介绍</h2>
<p>（来自维基百科）</p>
<ul>
<li><p>单播：<br><img src="100px-Unicast.svg.png" alt=""><br>每次只有两个实体相互通信，发送端和接收端都是唯一确定的。<br>在IPv4网络中，0.0.0.0到223.255.255.255属于单播地址。<br>你对小月月喊“小月月”，那么只有小月月回过头来答应你。</p>
</li>
<li><p>组播<br><img src="100px-Multicast.svg.png" alt=""><br>“组播”这个词通常用来指代IP组播。IP组播是一种通过使用一个组播地址将数据在同一时间以高效的方式发往处于TCP/IP网络上的多个接收者的协议。此外，它还常用来与RTP等音视频协议相结合。<br>互联网架构师戴夫·克拉克是这样描述IP组播的：“你把数据包从一头放进去，网络就会试图将它们传递到想要得到它们的人那里。”<br>组播报文的目的地址使用D类IP地址， D类地址不能出现在IP报文的源IP地址字段。<br>你在大街上大喊一声“美女”， 会有一群女性回头看你。</p>
</li>
<li><p>广播<br><img src="100px-Broadcast.svg.png" alt=""><br>并非所有的计算机网络都支持广播，例如X.25网络和帧中继都不支持广播，而且也没有在“整个互联网范围中”的广播。IPv6亦不支持广播，广播相应的功能由任播(anycast)代替。<br>通常，广播都是限制在局域网中的，比如以太网或令牌环网络。因为广播在局域网中造成的影响远比在广域网中小得多。</p>
<ul>
<li>以太网和IPv4网都用全1的地址表示广播，分别是ff:ff:ff:ff:ff:ff和255.255.255.255。</li>
<li>令牌环网络使用IEEE 802.2控制域中的一个特殊值来表示广播。<br>你在公司大喊一声“放假了”， 全部同事都会响应，大叫爽死了。</li>
</ul>
</li>
<li><p>任播<br><img src="100px-Anycast.svg.png" alt=""><br>任播是与单播、广播和组播不同的方式。</p>
<ul>
<li>在单播中，在网络位址和网络节点之间存在一一对应的关系。</li>
<li>在广播和组播中，在网络位址和网络节点之间存在一对多的关系：每一个目的位址对应一群接收可以复制资讯的节点。</li>
<li>在任播中，在网络位址和网络节点之间存在一对多的关系：每一个位址对应一群接收节点，但在任何给定时间，只有其中之一可以接收到传送端来的资讯。<br>在互联网中，通常使用边界网关协议来实现任播。<br>作为老板，你在公司大喊一声“开发组的过来一个人”， 总会有一个人灰溜溜去响应， 挨批还是发钱啊？</li>
</ul>
</li>
</ul>
<h2 id="组播地址">组播地址</h2>
<p>参考 <a href="http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml#multicast-addresses-2" target="_blank" rel="external">iana</a><br>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为<strong>永久组播组</strong>。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<ul>
<li>224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</li>
<li>224.0.1.0～224.0.1.255是公用组播地址，Internetwork Control Block；</li>
<li>224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</li>
<li>239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。</li>
</ul>
<p><strong>永久的组播地址</strong>：</p>
<ul>
<li>224.0.0.0 基准地址（保留）</li>
<li>224.0.0.1 所有主机的地址 （包括所有路由器地址）</li>
<li>224.0.0.2 所有组播路由器的地址</li>
<li>224.0.0.3 不分配</li>
<li>224.0.0.4 dvmrp路由器</li>
<li>224.0.0.5 所有ospf路由器</li>
<li>224.0.0.6 ospf DR/BDR</li>
<li>224.0.0.7 st路由器</li>
<li>224.0.0.8 st主机</li>
<li>224.0.0.9 rip-2路由器</li>
<li>224.0.0.10 Eigrp路由器</li>
<li>224.0.0.11 活动代理</li>
<li>224.0.0.12 dhcp 服务器/中继代理</li>
<li>224.0.0.13 所有pim路由器</li>
<li>224.0.0.14 rsvp封装</li>
<li>224.0.0.15 所有cbt路由器</li>
<li>224.0.0.16 指定sbm</li>
<li>224.0.0.17 所有sbms</li>
<li>224.0.0.18 vrrp</li>
</ul>
<p>以太网传输单播ip报文的时候，目的mac地址使用的是接收者的mac地址。但是在传输组播报文时，传输目的不再是一个具体的接收者，而是一个成员不确定的组，所以使用的是组播mac地址。组播mac地址是和组播ip地址对应的。iana（internet assigned number authority）规定，组播mac地址的高24bit为0x01005e，mac 地址的低23bit为组播ip地址的低23bit。<br>由于ip组播地址的后28位中只有23位被映射到mac地址，这样就会有32个ip组播地址映射到同一mac地址上。</p>
<h2 id="广播地址">广播地址</h2>
<p>广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，<strong>主机标识段host ID 为全1 的IP 地址为广播地址</strong>，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。<br>本地广播地址为255.255.255.255。</p>
<h2 id="Java，单播，组播与广播">Java，单播，组播与广播</h2>
<h3 id="单播">单播</h3>
<p>UDP协议的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。<br>与所熟知的TCP（传输控制协议）协议一样，UDP协议直接位于IP（网际协议）协议的顶层。根据OSI（开放系统互连）参考模型，UDP和TCP都属于传输层协议。<br>UDP首部字段由4个部分组成，其中两个是可选的。各16bit的来源端口和目的端口用来标记发送和接受的应用进程。因为UDP不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。在目的端口后面是长度固定的以字节为单位的长度域，用来指定UDP数据报包括数据部分的长度，长度最小值为8byte。首部剩下地16bit是用来对首部和数据部分一起做校验和（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。</p>
<p>TCP和UDP的区别。</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP(传输控制协议)</th>
<th>UDP(用户数据报协议)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是否连接</strong></td>
<td>面向连接</td>
<td>面向非连接</td>
</tr>
<tr>
<td><strong>传输可靠性</strong></td>
<td>可靠的</td>
<td>不可靠的</td>
</tr>
<tr>
<td><strong>应用场合</strong></td>
<td>传输大量的数据</td>
<td>少量数据</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>慢</td>
<td>快</td>
</tr>
</tbody>
</table>
<p>单播有UDP和TCP两种方式。 Java中 TCP socket编程就是单播的方式， ServerSocket/Socket。<br>Java中UDP也可以使用单播发送数据报：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//sending data to host and its port</span></div><div class="line">InetAddress address = InetAddress.getByName(host);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize a datagram packet with data and address</span></div><div class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(message, message.length,</div><div class="line">        address, port);</div><div class="line"></div><div class="line">    <span class="comment">// Create a datagram socket, send the packet through it, close it.</span></div><div class="line">    DatagramSocket dsocket = <span class="keyword">new</span> DatagramSocket();</div><div class="line">    dsocket.send(packet);</div><div class="line">    dsocket.close();</div></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//receiving data from its port</span></div><div class="line"> DatagramSocket dsocket = <span class="keyword">new</span> DatagramSocket(port);</div><div class="line"></div><div class="line"> <span class="comment">// Create a buffer to read datagrams into. If a</span></div><div class="line"> <span class="comment">// packet is larger than this buffer, the</span></div><div class="line"> <span class="comment">// excess will simply be discarded!</span></div><div class="line"> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</div><div class="line"></div><div class="line"> <span class="comment">// Create a packet to receive data into the buffer</span></div><div class="line"> DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</div><div class="line"></div><div class="line"> <span class="comment">// Now loop forever, waiting to receive packets and printing them.</span></div><div class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">   <span class="comment">// Wait to receive a datagram</span></div><div class="line">   dsocket.receive(packet);</div><div class="line"></div><div class="line">   <span class="comment">// Convert the contents to a string, and display them</span></div><div class="line">   String msg = <span class="keyword">new</span> String(buffer, <span class="number">0</span>, packet.getLength());</div><div class="line">   System.out.println(packet.getAddress().getHostName() + <span class="string">": "</span></div><div class="line">       + msg);</div><div class="line"></div><div class="line">   <span class="comment">// Reset the length of the packet before reusing it.</span></div><div class="line">   packet.setLength(buffer.length);</div><div class="line"> }</div></pre></td></tr></table></figure>

<h3 id="组播">组播</h3>
<p>多播数据报套接字类用于发送和接收 IP 多播包。MulticastSocket 是一种 (UDP) DatagramSocket，它具有加入 Internet 上其他多播主机的“组”的附加功能。<br>播组通过 D 类 IP 地址和标准 UDP 端口号指定。D 类 IP 地址在 224.0.0.0 和 239.255.255.255 的范围内（包括两者）。地址 224.0.0.0 被保留，不应使用。</p>
<p>可以通过首先使用所需端口创建 MulticastSocket，然后调用 joinGroup(InetAddress groupAddr) 方法来加入多播组： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// join a Multicast group and send the group salutations</span></div><div class="line">...</div><div class="line">String msg = <span class="string">"Hello"</span>;</div><div class="line">InetAddress group = InetAddress.getByName(<span class="string">"228.5.6.7"</span>);</div><div class="line">MulticastSocket s = <span class="keyword">new</span> MulticastSocket(<span class="number">6789</span>);</div><div class="line">s.joinGroup(group);</div><div class="line">DatagramPacket hi = <span class="keyword">new</span> DatagramPacket(msg.getBytes(), msg.length(),</div><div class="line">                            group, <span class="number">6789</span>);</div><div class="line">s.send(hi);</div><div class="line"><span class="comment">// get their responses!</span></div><div class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</div><div class="line">DatagramPacket recv = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</div><div class="line">s.receive(recv);</div><div class="line">...</div><div class="line"><span class="comment">// OK, I'm done talking - leave the group...</span></div><div class="line">s.leaveGroup(group);</div></pre></td></tr></table></figure>

<p>将消息发送到多播组时，该主机和端口的所有预定接收者都将接收到消息（在数据包的生存时间范围内，请参阅下文）。套接字不必成为多播组的成员即可向其发送消息.<br>当套接字预定多播组/端口时，它将接收由该组/端口的其他主机发送的数据报，像该组和端口的所有其他成员一样。套接字通过 leaveGroup(InetAddress addr) 方法放弃组中的成员资格。多个 MulticastSocket 可以同时预定多播组和端口，并且都会接收到组数据报。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UDP servers</span></div><div class="line">InetAddress group = InetAddress.getByName(<span class="string">"228.5.6.7"</span>);  </div><div class="line">MulticastSocket s = <span class="keyword">new</span> MulticastSocket(<span class="number">6789</span>);   </div><div class="line"><span class="keyword">byte</span>[] arb = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </div><div class="line">s.joinGroup(group);<span class="comment">//加入该组  </span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>){  </div><div class="line">    DatagramPacket datagramPacket =<span class="keyword">new</span> DatagramPacket(arb,arb.length);  </div><div class="line">    s.receive(datagramPacket);  </div><div class="line">    System.out.println(arb.length);  </div><div class="line">    System.out.println(<span class="keyword">new</span> String(arb));   </div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UDP sender</span></div><div class="line"><span class="keyword">int</span> port = <span class="number">6789</span>;  </div><div class="line">String sendMessage=<span class="string">"hello multicast"</span>;  </div><div class="line">InetAddress inetAddress = InetAddress.getByName(<span class="string">"228.5.6.7"</span>);  </div><div class="line">DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(sendMessage.getBytes(), sendMessage.length(), inetAddress, port);  </div><div class="line">MulticastSocket multicastSocket = <span class="keyword">new</span> MulticastSocket(); <span class="comment">//it is client, it won't join group</span></div><div class="line">multicastSocket.send(datagramPacket);</div></pre></td></tr></table></figure>

<h3 id="广播">广播</h3>
<p>在Java中，在Java UDP中单播与广播的代码是相同的,要实现具有广播功能的程序只需要使用<strong>广播地址</strong>即可。</p>
<h2 id="Netty与单播，组播">Netty与单播，组播</h2>
<h3 id="广播的例子">广播的例子</h3>
<p>例子<a href="http://netty.io/4.0/xref/io/netty/example/qotm/package-summary.html" target="_blank" rel="external">Quote of the Moment</a>是一个广播的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteOfTheMomentServer</span> </span>{</div><div class="line"> </div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"7686"</span>));</div><div class="line"> </div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">         EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">         <span class="keyword">try</span> {</div><div class="line">             Bootstrap b = <span class="keyword">new</span> Bootstrap();</div><div class="line">             b.group(group)</div><div class="line">              .channel(NioDatagramChannel.class)</div><div class="line">              .option(ChannelOption.SO_BROADCAST, <span class="keyword">true</span>)</div><div class="line">              .handler(<span class="keyword">new</span> QuoteOfTheMomentServerHandler());</div><div class="line"> </div><div class="line">             b.bind(PORT).sync().channel().closeFuture().await();</div><div class="line">         } <span class="keyword">finally</span> {</div><div class="line">             group.shutdownGracefully();</div><div class="line">         }</div><div class="line">     }</div><div class="line"> }</div></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteOfTheMomentClient</span> </span>{</div><div class="line">  </div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"7686"</span>));</div><div class="line">  </div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">  </div><div class="line">          EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">          <span class="keyword">try</span> {</div><div class="line">              Bootstrap b = <span class="keyword">new</span> Bootstrap();</div><div class="line">              b.group(group)</div><div class="line">               .channel(NioDatagramChannel.class)</div><div class="line">               .option(ChannelOption.SO_BROADCAST, <span class="keyword">true</span>)</div><div class="line">               .handler(<span class="keyword">new</span> QuoteOfTheMomentClientHandler());</div><div class="line">  </div><div class="line">              Channel ch = b.bind(<span class="number">0</span>).sync().channel();</div><div class="line">  </div><div class="line">              <span class="comment">// Broadcast the QOTM request to port 8080.</span></div><div class="line">              ch.writeAndFlush(<span class="keyword">new</span> DatagramPacket(</div><div class="line">                      Unpooled.copiedBuffer(<span class="string">"QOTM?"</span>, CharsetUtil.UTF_8),</div><div class="line">                      <span class="keyword">new</span> InetSocketAddress(<span class="string">"255.255.255.255"</span>, PORT))).sync();</div><div class="line">  </div><div class="line">              <span class="comment">// QuoteOfTheMomentClientHandler will close the DatagramChannel when a</span></div><div class="line">              <span class="comment">// response is received.  If the channel is not closed within 5 seconds,</span></div><div class="line">              <span class="comment">// print an error message and quit.</span></div><div class="line">              <span class="keyword">if</span> (!ch.closeFuture().await(<span class="number">5000</span>)) {</div><div class="line">                  System.err.println(<span class="string">"QOTM request timed out."</span>);</div><div class="line">              }</div><div class="line">          } <span class="keyword">finally</span> {</div><div class="line">              group.shutdownGracefully();</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></pre></td></tr></table></figure>

<h3 id="组播-1">组播</h3>
<p><code>SocketOptions</code>定义组播和广播的一些常量。</p>
<ul>
<li>IP_MULTICAST_IF / networkInterface: The name of the interface on which outgoing multicast packets should be sent. When a host has multiple network interfaces, this tends to be quite important.</li>
<li>IP_MULTICAST_IF2 / networkInterface: The same as IP_MULTICAST_IF but defined again for good measure.</li>
<li>IP_MULTICAST_LOOP / loopbackModeDisabled: Defines if multicast packets should be received by the sender of the same.</li>
<li>SO_BROADCAST / broadcast: Enables or disables a DataGramSocket’s ability to send broadcast messages,</li>
</ul>
<p>参照netty的<a href="https://github.com/netty/netty/blob/master/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java" target="_blank" rel="external">测试套件</a>。</p>
<h3 id="单播-1">单播</h3>
<p>参看netty的<a href="https://github.com/netty/netty/blob/master/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java" target="_blank" rel="external">测试套件</a></p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://zh.wikipedia.org/wiki/%E5%96%AE%E6%92%AD" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%96%AE%E6%92%AD</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF)" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF)</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E4%BB%BB%E6%92%AD" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E4%BB%BB%E6%92%AD</a></li>
<li><a href="http://li-sir.iteye.com/blog/837344" target="_blank" rel="external">http://li-sir.iteye.com/blog/837344</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p><strong>单播</strong>(unicast): 是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。<br><strong>组播</strong>(multicast): 也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。<br><strong>广播</strong>(broadcast):是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。<br><strong>任播</strong>(anycast):是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。</p>
<p>在Linux运行<code>ifconfig</code>, 如果网卡信息中包含<code>UP BROADCAST RUNNING MULTICAST</code>，则支持广播和组播。</p>
]]></summary>
    
      <category term="网络编程" scheme="http://colobu.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty5用户指南]]></title>
    <link href="http://colobu.com/2014/10/21/netty-5-x-user-guide/"/>
    <id>http://colobu.com/2014/10/21/netty-5-x-user-guide/</id>
    <published>2014-10-21T00:35:17.000Z</published>
    <updated>2014-10-21T05:44:55.000Z</updated>
    <content type="html"><![CDATA[<p>Netty 是一个NIO client/server 网络编程框架， 可以快速且容易的开发基于协议(protocol)的网络客户端/服务器端的程序。 它极大的简化了TCP和UDP socket编程， 提供流水线化的操作。</p>
<p>‘快速且容易’并不会导致应用难以维护和性能低下。 Netty经过仔细设计， 基于许多协议实现的经验如FTP, SMTP, HTTP以及各种二进制的和基于本文的老的协议， Netty成功的找到一种保证开发，性能，稳定性，灵活性的方式， 毋须折衷.</p>
<p><img src="http://netty.io/images/components.png" alt=""></p>
<h2 id="特性">特性</h2>
<h3 id="设计">设计</h3>
<ul>
<li>为各种传输类型提供统一的API- 阻塞和非阻塞的socket</li>
<li>灵活和可扩展的事件模型， 将关注点分隔</li>
<li>高度可定制化的线程模型- 单线程， 一种或者多个线程池如<a href="http://en.wikipedia.org/wiki/Staged_event-driven_architecture" target="_blank" rel="external">SEDA</a></li>
<li>真正无连接的数据报socket支持(since 3.1)<h3 id="易用">易用</h3>
</li>
<li>提供Javadoc, 用户指南和例子</li>
<li>除了JDK 1.5 (或以上版本)毋须第三方库支持<h3 id="性能">性能</h3>
</li>
<li>更好的吞吐率，低延迟</li>
<li>较少的资源占用</li>
<li>最小化不必要的内存拷贝<h3 id="安全">安全</h3>
</li>
<li>完整的SSL/TLS， StartTLS支持<h3 id="社区">社区</h3>
</li>
<li>早期发布，发布频繁</li>
<li>作者自2003就开始写类似的框架(mina)， 一直收集用户的反馈。<br><a id="more"></a><br>官方的user guide: <a href="http://netty.io/wiki/user-guide-for-5.x.html" target="_blank" rel="external">英文</a><br>阿里的<a href="https://github.com/owenludong" target="_blank" rel="external">owenludong</a>的翻译： <a href="http://www.getsetter.cn/2014/07/15/netty5/" target="_blank" rel="external">中文版</a></li>
</ul>
<p>以下是转载。</p>
<hr>

<h2 id="前言">前言</h2>
<h3 id="问题">问题</h3>
<p>现如今我们使用通用的应用程序或者类库来实现系统之间地互相访问，比如我们经常使用一个HTTP客户端来从web服务器上获取信息，或者通过web service来执行一个远程的调用。<br>然而，一个通用的协议和他的实现有时候并没有覆盖一些场景。比如我们无法使用一个通用的http服务器来对庞大的文件和电子邮件进行交互，再比如也无法处理那种准实时消息比如财务信息和多人游戏数据。我们需要一个高效的协议实现用来处理一些特殊的场景。例如你可以实现一个高效的基于Ajax的聊天应用、媒体流传输或者是大文件传输的http服务器，你甚至可能想自己设计和实现一整个新的协议来准确地定制你自己的需求。</p>
<p>另外不可避免的事情是你不得不处理这些私有协议来确保和原有系统的互通。在这个例子中会告诉你实现一个对应该程序不损耗稳定性和性能的协议是多么的快。</p>
<h2 id="解决方案">解决方案</h2>
<p><a href="http://netty.io/" target="_blank" rel="external">Netty</a>是一个提供异步事件驱动的网络应用框架，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p>
<p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p>
<p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是Netty的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。Netty的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。</p>
<h2 id="入门指南">入门指南</h2>
<p>这个章节会围绕Netty核心的结构并附上一些简单的例子让你快速的入门。当你读完本章节你马上就可以用Netty写出一个客户端和一个服务端。<br>如果你在学习某些东西的时候喜欢自顶向下的方法，你可能想要从第二个章节架构概述开始，然后再回到这里。</p>
<h3 id="开始之前">开始之前</h3>
<p>如果要运行本章节中的2个例子最低要求是：Netty的最新版本(Netty5)和JDK1.6及以上。最新的Netty版本在项目下载页面。为了下载到正确的JDK版本，请到你偏爱的网站下载。<br>当你在读的过程中，你可能有很多关于本章节介绍的类相关的问题，每当你想知道他们的更多的信息那么请参考API说明文档。为了方便，所有文档中涉及到的类名字都会被关联到一个在线的API说明。当然如果有任何错误信息、语法错误或者你有任何好的建议来改进文档说明，那么请联系netty社区。</p>
<h3 id="实现Discard服务器">实现Discard服务器</h3>
<p>世界上最简单的协议不是”Hello,World!”，是<a href="http://tools.ietf.org/html/rfc863" target="_blank" rel="external">DISCARD</a>，他是一种丢弃所有接收的数据，并不做有任何响应的协议。<br>为了实现DISCARD协议，你唯一需要做的就是忽略所有收到的数据。让我们从处理器的实现开始，处理器是由Netty生成用来处理I/O事件的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.discard;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerAdapter;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Handles a server-side channel.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{ <span class="comment">// (1)</span></div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) { <span class="comment">// (2)</span></div><div class="line">        <span class="comment">// Discard the received data silently.</span></div><div class="line">        ((ByteBuf) msg).release(); <span class="comment">// (3)</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span>(ChannelHandlerContext ctx, Throwable cause) { <span class="comment">// (4)</span></div><div class="line">        <span class="comment">// Close the connection when an exception is raised.</span></div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>DiscardServerHandler 继承自 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="external">ChannelHandlerAdapter</a>，这个类实现了<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>接口，<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="external">ChannelHandlerAdapter</a>类而不是你自己去实现接口方法。</li>
<li>这里我们覆盖了<code>chanelRead()</code>事件处理方法。每当从客户端收到新的数据时，这个方法会在收到消息时被调用，这个例子中，收到的消息的类型是<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a></li>
<li>为了实现DISCARD协议，处理器不得不忽略所有接收到的消息。<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>是一个引用计数对象，这个对象必须显示地调用<code>release()</code>方法来释放。请记住处理器的职责是释放所有传递到处理器的引用计数对象。通常，<code>channelRead()</code>方法的实现就像下面的这段代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// Do something with msg</span></div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        ReferenceCountUtil.release(msg);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><code>exceptionCaught()</code>事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</li>
</ol>
<p>到目前为止一切都还比较顺利，我们已经实现了DISCARD服务的一半功能，剩下的需要编写一个main()方法来启动服务端的DiscardServerHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.discard;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</div><div class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</div><div class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</div><div class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</div><div class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Discards any incoming data.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">DiscardServer</span>(<span class="keyword">int</span> port) {</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() <span class="keyword">throws</span> Exception {</div><div class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span></div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></div><div class="line">            b.group(bossGroup, workerGroup)</div><div class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span></div><div class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() { <span class="comment">// (4)</span></div><div class="line">                 <span class="annotation">@Override</span></div><div class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span>(SocketChannel ch) <span class="keyword">throws</span> Exception {</div><div class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</div><div class="line">                 }</div><div class="line">             })</div><div class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></div><div class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></div><div class="line"></div><div class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></div><div class="line">            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></div><div class="line"></div><div class="line">            <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></div><div class="line">            <span class="comment">// shut down your server.</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">            bossGroup.shutdownGracefully();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="keyword">int</span> port;</div><div class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) {</div><div class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            port = <span class="number">8080</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">new</span> DiscardServer(port).run();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a> 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的<code>EventLoopGroup</code>的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个<code>NioEventLoopGroup</code>会被使用。第一个经常被叫做‘boss’，用来接收进来的连接。第二个经常被叫做‘worker’，用来处理已经被接收的连接，一旦‘boss’接收到连接，就会把连接信息注册到‘worker’上。如何知道多少个线程已经被使用，如何映射到已经创建的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channels</a>上都需要依赖于<code>EventLoopGroup</code>的实现，并且可以通过构造函数来配置他们的关系。</li>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a> 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用Channel，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li>
<li>这里我们指定使用<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>类来举例说明一个新的Channel如何接收进来的连接。</li>
<li>这里的事件处理类经常会被用来处理一个最近的已经接收的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a>是一个特殊的处理类，他的目的是帮助使用者配置一个新的Channel。也许你想通过增加一些处理类比如DiscardServerHandle来配置一个新的Channel或者其对应的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到pipline上，然后提取这些匿名类到最顶层的类上。</li>
<li>你可以设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如tcpNoDelay和keepAlive。请参考<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="external">ChannelOption</a>和详细的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelConfig.html" target="_blank" rel="external">ChannelConfig</a>实现的接口文档以此可以对ChannelOptions的有一个大概的认识。</li>
<li>你关注过option()和childOption()吗？option()是提供给<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>用来接收进来的连接。childOption()是提供给由父管道<a href="http://netty.io/5.0/api/io/netty/channel/ServerChannel.html" target="_blank" rel="external">ServerChannel</a>接收到的连接，在这个例子中也是NioServerSocketChannel。</li>
<li>我们继续，剩下的就是绑定端口然后启动服务。这里我们在机器上绑定了机器所有网卡上的8080端口。当然现在你可以多次调用bind()方法(基于不同绑定地址)。</li>
</ol>
<p>恭喜！你已经完成熟练地完成了第一个基于Netty的服务端程序。</p>
<h2 id="处理接收到的数据">处理接收到的数据</h2>
<p>现在我们已经编写出我们第一个服务端，我们需要测试一下他是否真的可以运行。最简单的测试方法是用telnet 命令。例如，你可以在命令行上输入telnet localhost 8080或者其他类型参数。<br>然而我们能说这个服务端是正常运行了吗？事实上我们也不知道因为他是一个discard服务，你根本不可能得到任何的响应。为了证明他仍然是在工作的，让我们修改服务端的程序来打印出他到底接收到了什么。<br>我们已经知道<code>channelRead()</code>方法是在数据被接收的时候调用。让我们放一些代码到<code>DiscardServerHandler</code>类的<code>channelRead()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">    ByteBuf in = (ByteBuf) msg;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">while</span> (in.isReadable()) { <span class="comment">// (1)</span></div><div class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</div><div class="line">            System.out.flush();</div><div class="line">        }</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        ReferenceCountUtil.release(msg); <span class="comment">// (2)</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>这个低效的循环事实上可以简化为:<code>System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</code></li>
<li>或者，你可以在这里调用<code>in.release()</code>。</li>
</ol>
<p>如果你再次运行telnet命令，你将会看到服务端打印出了他所接收到的消息。<br>完整的discard server代码放在了<code>io.netty.example.discard</code>包下面。</p>
<h2 id="实现ECHO服务">实现ECHO服务</h2>
<p>到目前为止，我们虽然接收到了数据，但没有做任何的响应。然而一个服务端通常会对一个请求作出响应。让我们学习怎样在<a href="http://tools.ietf.org/html/rfc862" target="_blank" rel="external">ECHO协议</a>的实现下编写一个响应消息给客户端，这个协议针对任何接收的数据都会返回一个响应。<br>和discard server唯一不同的是把在此之前我们实现的channelRead()方法，返回所有的数据替代打印接收数据到控制台上的逻辑。因此，需要把channelRead()方法修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">    ctx.write(msg); <span class="comment">// (1)</span></div><div class="line">    ctx.flush(); <span class="comment">// (2)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html," target="_blank" rel="external">ChannelHandlerContext</a>对象提供了许多操作，使你能够触发各种各样的I/O事件和操作。这里我们调用了write(Object)方法来逐字地把接收到的消息写入。请注意不同于DISCARD的例子我们并没有释放接收到的消息，这是因为当写入的时候Netty已经帮我们释放了。</li>
<li><code>ctx.write(Object)</code>方法不会使消息写入到通道上，他被缓冲在了内部，你需要调用ctx.flush()方法来把缓冲区中数据强行输出。或者你可以用更简洁的cxt.writeAndFlush(msg)以达到同样的目的。</li>
</ol>
<p>如果你再一次运行telnet命令，你会看到服务端会发回一个你已经发送的消息。<br>完整的echo服务的代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/echo/package-summary.html" target="_blank" rel="external">io.netty.example.echo</a>包下面。</p>
<h2 id="实现TIME服务器">实现TIME服务器</h2>
<p>在这个部分被实现的协议是<a href="http://tools.ietf.org/html/rfc868" target="_blank" rel="external">TIME协议</a>。和之前的例子不同的是他会发送一个含32位的整数的消息，不会接收任何请求数据， 并且一旦消息发送就立即关闭连接， 。在这个例子中，你会学习到如何构建和发送一个消息，然后在完成时主动关闭连接。</p>
<p>因为我们将会忽略任何接收到的数据，而只是在连接被创建发送一个消息，所以这次我们不能使用channelRead()方法了，代替他的是，我们需要覆盖channelActive()方法，下面的就是实现的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span>(<span class="keyword">final</span> ChannelHandlerContext ctx) { <span class="comment">// (1)</span></div><div class="line">        <span class="keyword">final</span> ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (2)</span></div><div class="line">        time.writeInt((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>L + <span class="number">2208988800</span>L));</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(time); <span class="comment">// (3)</span></div><div class="line">        f.addListener(<span class="keyword">new</span> ChannelFutureListener() {</div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span>(ChannelFuture future) {</div><div class="line">                <span class="keyword">assert</span> f == future;</div><div class="line">                ctx.close();</div><div class="line">            }</div><div class="line">        }); <span class="comment">// (4)</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span>(ChannelHandlerContext ctx, Throwable cause) {</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>1.channelActive()方法将会在连接被建立并且准备进行通信时被调用。因此让我们在这个方法里完成一个代表当前时间的32位整数消息的构建工作。<br>2.为了发送一个新的消息，我们需要分配一个包含这个消息的新的缓冲。因为我们需要写入一个32位的整数，因此我们需要一个至少有4个字节的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。通过ChannelHandlerContext.alloc()得到一个当前的ByteBufAllocator，然后分配一个新的缓冲。<br>3.和往常一样我们需要编写一个构建好的消息。但是等一等，flip在哪？难道我们使用NIO发送消息时不是调用java.nio.ByteBuffer.flip()吗？ByteBuf之所以没有这个方法因为有两个指针，一个对应读操作一个对应写操作。当你向ByteBuf里写入数据的时候写指针的索引就会增加，同时读指针的索引没有变化。读指针索引和写指针索引分别代表了消息的开始和结束。<br>比较起来，NIO缓冲并没有提供一种简洁的方式来计算出消息内容的开始和结尾，除非你调用flip方法。当你忘记调用flip方法而引起没有数据或者错误数据被发送时，你会陷入困境。这样的一个错误不会发生在Netty上，因为我们对于不同的操作类型有不同的指针。你会发现这样的使用方法会让你过程变得更加的容易，因为你已经习惯一种没有使用flip的方式。<br>另外一个点需要注意的是ChannelHandlerContext.write()(和writeAndFlush())方法会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>对象，一个<code>ChannelFuture</code>代表了一个还没有发生的I/O操作。这意味着任何一个请求操作都不会马上被执行，因为在Netty里所有的操作都是异步的。举个例子下面的代码中在消息被发送之前可能会先关闭连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Channel ch = ...;</div><div class="line">ch.writeAndFlush(message);</div><div class="line">ch.close();</div></pre></td></tr></table></figure>

<p>因此你需要在write()方法返回的ChannelFuture完成后调用close()方法，然后当他的写操作已经完成他会通知他的监听者。请注意,close()方法也可能不会立马关闭，他也会返回一个<code>ChannelFuture</code>。<br>4.当一个写请求已经完成是如何通知到我们？这个只需要简单地在返回的ChannelFuture上增加一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>。这里我们构建了一个匿名的ChannelFutureListener类用来在操作完成时关闭Channel。<br>或者，你可以使用简单的预定义监听器代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f.addListener(ChannelFutureListener.CLOSE);</div></pre></td></tr></table></figure>

<p>为了测试我们的time服务如我们期望的一样工作，你可以使用UNIX的rdate命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rdate -o &lt;port&gt; -p &lt;host&gt;</div></pre></td></tr></table></figure>

<p>Port是你在main()函数中指定的端口，host使用locahost就可以了。</p>
<h2 id="实现TIME客户端">实现TIME客户端</h2>
<p>不像DISCARD和ECHO的服务端，对于TIME协议我们需要一个客户端, 因为人们不能把一个32位的二进制数据翻译成一个日历日期。在这一部分，我们将会讨论如何确保服务端是正常工作的，并且学习怎样用Netty编写一个客户端。<br>在Netty中,编写服务端和客户端最大的并且唯一不同的使用了不同的BootStrap和Channel的实现。请看一下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        String host = args[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></div><div class="line">            b.group(workerGroup); <span class="comment">// (2)</span></div><div class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></div><div class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></div><div class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</div><div class="line">                <span class="annotation">@Override</span></div><div class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span>(SocketChannel ch) <span class="keyword">throws</span> Exception {</div><div class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</div><div class="line">                }</div><div class="line">            });</div><div class="line"></div><div class="line">            <span class="comment">// Start the client.</span></div><div class="line">            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span></div><div class="line"></div><div class="line">            <span class="comment">// Wait until the connection is closed.</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a>类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的channel。</li>
<li>如果你只指定了一个<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>，那他就会即作为一个‘boss’线程，也会作为一个‘workder’线程，尽管客户端不需要使用到‘boss’线程。</li>
<li>代替<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>的是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" target="_blank" rel="external">NioSocketChannel</a>,这个类在客户端channel被创建时使用。</li>
<li>不像在使用ServerBootstrap时需要用childOption()方法，因为客户端的<a href="http://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html" target="_blank" rel="external">SocketChannel</a>没有父channel的概念。</li>
<li>我们用<code>connect()</code>方法代替了<code>bind()</code>方法。</li>
</ol>
<p>正如你看到的，他和服务端的代码是不一样的。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>是如何实现的?他应该从服务端接受一个32位的整数消息，把他翻译成人们能读懂的格式，并打印翻译好的时间，最后关闭连接:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">        ByteBuf m = (ByteBuf) msg; <span class="comment">// (1)</span></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">long</span> currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L;</div><div class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</div><div class="line">            ctx.close();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            m.release();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span>(ChannelHandlerContext ctx, Throwable cause) {</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>在TCP/IP中，Netty会把读到的数据放到ByteBuf的数据结构中。<br>这样看起来非常简单，并且和服务端的那个例子的代码也相差不多。然而，处理器有时候会因为抛出IndexOutOfBoundsException而拒绝工作。在下个部分我们会讨论为什么会发生这种情况。</li>
</ol>
<h2 id="流数据的传输处理">流数据的传输处理</h2>
<h3 id="一个小的Socket_Buffer问题">一个小的Socket Buffer问题</h3>
<p>在基于流的传输里比如TCP/IP，接收到的数据会先被存储到一个socket接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了2个独立的数据包，操作系统也不会作为2个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取。举个例子，让我们假设操作系统的TCP/TP协议栈已经接收了3个数据包：<br><img src="https://camo.githubusercontent.com/9b6aadee43a4fa15d603a2c4a7695359dad7fdfe/687474703a2f2f696d672e6d6f74642e6b722f756d6c2f676973742f3063643963633636373461366238393561306365" alt=""><br>由于基于流传输的协议的这种普通的性质，在你的应用程序里读取数据的时候会有很高的可能性被分成下面的片段。<br><img src="https://camo.githubusercontent.com/7b68f601941f48944e51524ed2ba16dcd4608667/687474703a2f2f696d672e6d6f74642e6b722f756d6c2f676973742f6233316330626437626266633639666438326436" alt=""><br>因此，一个接收方不管他是客户端还是服务端，都应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的数据。在上面的例子中，接收到的数据应该被构造成下面的格式：<br><img src="https://camo.githubusercontent.com/9b6aadee43a4fa15d603a2c4a7695359dad7fdfe/687474703a2f2f696d672e6d6f74642e6b722f756d6c2f676973742f3063643963633636373461366238393561306365" alt=""></p>
<h3 id="第一种解决方案">第一种解决方案</h3>
<p>现在让我们回到TIME客户端的例子上。这里我们遇到了同样的问题，一个32字节数据是非常小的数据量，他并不见得会被经常拆分到到不同的数据段内。然而，问题是他确实可能会被拆分到不同的数据段内，并且拆分的可能性会随着通信量的增加而增加。<br>最简单的方案是构造一个内部的可积累的缓冲，直到4个字节全部接收到了内部缓冲。下面的代码修改了TimeClientHandler的实现类修复了这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{</div><div class="line">    <span class="keyword">private</span> ByteBuf buf;</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span>(ChannelHandlerContext ctx) {</div><div class="line">        buf = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (1)</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span>(ChannelHandlerContext ctx) {</div><div class="line">        buf.release(); <span class="comment">// (1)</span></div><div class="line">        buf = <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">        ByteBuf m = (ByteBuf) msg;</div><div class="line">        buf.writeBytes(m); <span class="comment">// (2)</span></div><div class="line">        m.release();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (buf.readableBytes() &gt;= <span class="number">4</span>) { <span class="comment">// (3)</span></div><div class="line">            <span class="keyword">long</span> currentTimeMillis = (buf.readInt() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L;</div><div class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</div><div class="line">            ctx.close();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span>(ChannelHandlerContext ctx, Throwable cause) {</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>有2个生命周期的监听方法：handlerAdded()和handlerRemoved()。你可以完成任意初始化任务只要他不会被阻塞很长的时间。</li>
<li>首先，所有接收的数据都应该被累积在buf变量里。</li>
<li>然后，处理器必须检查buf变量是否有足够的数据，在这个例子中是4个字节，然后处理实际的业务逻辑。否则，Netty会重复调用channelRead()当有更多数据到达直到4个字节的数据被积累。</li>
</ol>
<h3 id="第二种解决方案">第二种解决方案</h3>
<p>尽管第一个解决方案已经解决了Time客户端的问题了，但是修改后的处理器看起来不那么的简洁，想象一下如果由多个字段比如可变长度的字段组成的更为复杂的协议时，你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的实现将很快地变得难以维护。</p>
<p>正如你所知的，你可以增加多个<code>ChannelHandler</code>到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a> ,因此你可以把一整个<code>ChannelHandler</code>拆分成多个模块以减少应用的复杂程度，比如你可以把<code>TimeClientHandler</code>拆分成2个处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>{ <span class="comment">// (1)</span></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) { <span class="comment">// (2)</span></div><div class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) {</div><div class="line">            <span class="keyword">return</span>; <span class="comment">// (3)</span></div><div class="line">        }</div><div class="line"></div><div class="line">        out.add(in.readBytes(<span class="number">4</span>)); <span class="comment">// (4)</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>是<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的一个实现类，他可以在处理数据拆分的问题上变得很简单。</li>
<li>每当有新数据接收的时候，<code>ByteToMessageDecoder</code>都会调用<code>decode()</code>方法来处理内部的那个累积缓冲。</li>
<li><code>decode()</code>方法可以决定当累积缓冲里没有足够数据时可以往out对象里放任意数据。当有更多的数据被接收了<code>ByteToMessageDecoder</code>会再一次调用decode()方法。</li>
<li>如果在<code>decode()</code>方法里增加了一个对象到out对象里，这意味着解码器解码消息成功。ByteToMessageDecoder将会丢弃在累积缓冲里已经被读过的数据。请记得你不需要对多条消息调用<code>decode()</code>，<code>ByteToMessageDecoder</code>会持续调用<code>decode()</code>直到不放任何数据到out里。</li>
</ol>
<p>现在我们有另外一个处理器插入到<code>ChannelPipeline</code>里，我们应该在TimeClient里修改<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span>(SocketChannel ch) <span class="keyword">throws</span> Exception {</div><div class="line">        ch.pipeline().addLast(<span class="keyword">new</span> TimeDecoder(), <span class="keyword">new</span> TimeClientHandler());</div><div class="line">    }</div><div class="line">});</div></pre></td></tr></table></figure>

<p>如果你是一个大胆的人，你可能会尝试使用更简单的解码类<a href="http://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html" target="_blank" rel="external">ReplayingDecoder</a>。不过你还是需要参考一下API文档来获取更多的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(</div><div class="line">            ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) {</div><div class="line">        out.add(in.readBytes(<span class="number">4</span>));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此外，Netty还提供了更多可以直接拿来用的解码器使你可以更简单地实现更多的协议，帮助你避免开发一个难以维护的处理器实现。请参考下面的包以获取更多更详细的例子：</p>
<ul>
<li>对于二进制协议请看<a href="http://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html" target="_blank" rel="external">io.netty.example.factorial</a></li>
<li>对于基于文本协议请看<a href="http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html" target="_blank" rel="external">io.netty.example.telnet</a></li>
</ul>
<h2 id="用POJO代替ByteBuf">用POJO代替ByteBuf</h2>
<p>我们已经讨论了所有的例子，到目前为止一个消息的消息都是使用<code>ByteBuf</code>作为一个基本的数据结构。在这一部分，我们会改进TIME协议的客户端和服务端的例子，用POJO替代<code>ByteBuf</code>。<br>在你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>中使用POJO优势是比较明显的。通过从<code>ChannelHandler</code>中提取出<code>ByteBuf</code>的代码，将会使<code>ChannelHandler</code>的实现变得更加可维护和可重用。在TIME客户端和服务端的例子中，我们读取的仅仅是一个32位的整型数据，直接使用<code>ByteBuf</code>不会是一个主要的问题。然后，你会发现当你需要实现一个真实的协议，分离代码变得非常必要。<br>首先，让我们定义一个新的类型叫做UnixTime。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnixTime</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> value;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">UnixTime</span>() {</div><div class="line">        <span class="keyword">this</span>(System.currentTimeMillis() / <span class="number">1000</span>L + <span class="number">2208988800</span>L);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="keyword">long</span> value) {</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">value</span>() {</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date((value() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L).toString();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在我们可以修改下TimeDecoder类，返回一个UnixTime，以替代ByteBuf.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) {</div><div class="line">    <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) {</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    out.add(<span class="keyword">new</span> UnixTime(in.readInt()));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面是修改后的解码器，TimeClientHandler不再有任何的ByteBuf代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(ChannelHandlerContext ctx, Object msg) {</div><div class="line">    UnixTime m = (UnixTime) msg;</div><div class="line">    System.out.println(m);</div><div class="line">    ctx.close();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>是不是变得更加简单和优雅了？相同的技术可以被运用到服务端。让我们修改一下TimeServerHandler的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span>(ChannelHandlerContext ctx) {</div><div class="line">    ChannelFuture f = ctx.writeAndFlush(<span class="keyword">new</span> UnixTime());</div><div class="line">    f.addListener(ChannelFutureListener.CLOSE);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，仅仅需要修改的是ChannelHandler的实现，这里需要把UnixTime对象重新转化为一个ByteBuf。不过这已经是非常简单了，因为当你对一个消息编码的时候，你不需要再处理拆包和组装的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {</div><div class="line">        UnixTime m = (UnixTime) msg;</div><div class="line">        ByteBuf encoded = ctx.alloc().buffer(<span class="number">4</span>);</div><div class="line">        encoded.writeInt(m.value());</div><div class="line">        ctx.write(encoded, promise); <span class="comment">// (1)</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>在这几行代码里还有几个重要的事情。<br>第一， 通过<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPromise.html" target="_blank" rel="external">ChannelPromise</a>，当编码后的数据被写到了通道上Netty可以通过这个对象标记是成功还是失败。<br>第二， 我们不需要调用cxt.flush()。因为处理器已经单独分离出了一个方法void flush(ChannelHandlerContext cxt),如果像自己实现flush方法内容可以自行覆盖这个方法。</li>
</ol>
<p>进一步简化操作，你可以使用<a href="http://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html" target="_blank" rel="external">MessageToByteEncode</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">UnixTime</span>&gt; </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span>(ChannelHandlerContext ctx, UnixTime msg, ByteBuf out) {</div><div class="line">        out.writeInt(msg.value());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后的任务就是在TimeServerHandler之前把TimeEncoder插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>。但这是不那么重要的工作。</p>
<h2 id="关闭你的应用">关闭你的应用</h2>
<p>关闭一个Netty应用往往只需要简单地通过<code>shutdownGracefully()</code>方法来关闭你构建的所有的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a>.当EventLoopGroup被完全地终止,并且对应的所有<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">channel</a>都已经被关闭时，Netty会返回一个<code>Future</code>对象。</p>
<h2 id="总结">总结</h2>
<p>在这一章节中，我们会快速地回顾下如果在熟练掌握Netty的情况下编写出一个健壮能运行的网络应用程序。<br>在Netty接下去的章节中还会有更多更相信的信息。我们也鼓励你去重新复习下在<a href="https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example" target="_blank" rel="external">io.netty.example</a>包下的例子。<br>请注意<a href="http://netty.io/community.html" target="_blank" rel="external">社区</a>一直在等待你的问题和想法以帮助Netty的持续改进，Netty的文档也是基于你们的快速反馈上。</p>
]]></content>
    <summary type="html"><![CDATA[<p>Netty 是一个NIO client/server 网络编程框架， 可以快速且容易的开发基于协议(protocol)的网络客户端/服务器端的程序。 它极大的简化了TCP和UDP socket编程， 提供流水线化的操作。</p>
<p>‘快速且容易’并不会导致应用难以维护和性能低下。 Netty经过仔细设计， 基于许多协议实现的经验如FTP, SMTP, HTTP以及各种二进制的和基于本文的老的协议， Netty成功的找到一种保证开发，性能，稳定性，灵活性的方式， 毋须折衷.</p>
<p><img src="http://netty.io/images/components.png" alt=""></p>
<h2 id="特性">特性</h2>
<h3 id="设计">设计</h3>
<ul>
<li>为各种传输类型提供统一的API- 阻塞和非阻塞的socket</li>
<li>灵活和可扩展的事件模型， 将关注点分隔</li>
<li>高度可定制化的线程模型- 单线程， 一种或者多个线程池如<a href="http://en.wikipedia.org/wiki/Staged_event-driven_architecture" target="_blank" rel="external">SEDA</a></li>
<li>真正无连接的数据报socket支持(since 3.1)<h3 id="易用">易用</h3>
</li>
<li>提供Javadoc, 用户指南和例子</li>
<li>除了JDK 1.5 (或以上版本)毋须第三方库支持<h3 id="性能">性能</h3>
</li>
<li>更好的吞吐率，低延迟</li>
<li>较少的资源占用</li>
<li>最小化不必要的内存拷贝<h3 id="安全">安全</h3>
</li>
<li>完整的SSL/TLS， StartTLS支持<h3 id="社区">社区</h3>
</li>
<li>早期发布，发布频繁</li>
<li>作者自2003就开始写类似的框架(mina)， 一直收集用户的反馈。<br>]]></summary>
    
      <category term="netty" scheme="http://colobu.com/tags/netty/"/>
    
      <category term="网络编程" scheme="http://colobu.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java位操作指南]]></title>
    <link href="http://colobu.com/2014/10/20/java-bitwise-bitshift-operation/"/>
    <id>http://colobu.com/2014/10/20/java-bitwise-bitshift-operation/</id>
    <published>2014-10-20T08:16:36.000Z</published>
    <updated>2014-10-23T02:30:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="原码，反码和补码">原码，反码和补码</h2>
<p>这个是计算机的基础知识了。</p>
<p><code>+3</code>的原码为<code>00000011</code>，<br><code>-3</code>的原码为<code>10000011</code>，<br>第一位是符号位。</p>
<p><code>+3</code>的反码为<code>00000011</code>，<br><code>-3</code>的反码为<code>11111100</code>，<br>正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<p><code>+3</code>的补码为<code>00000011</code>，<br><code>-3</code>的补码为<code>11111101</code>，<br>正数的补码就是其本身<br>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<p>使用补码可以将减法变为加法，而且<code>0</code>的问题也会解决。</p>
<p>Java中使用补码的格式保存byte,short,int,long类型的数据。 （ two’s complement integer.）</p>
<h2 id="位操作符">位操作符</h2>
<ul>
<li><code>&amp;</code> 与。 按补码的每一位进行与操作。</li>
<li><code>|</code> 或。 按补码的每一位进行与操作。</li>
<li><code>^</code> 异或。 按补码的每一位进行与操作。</li>
<li><code>~</code> 取反。 按补码的每一位进行与操作。</li>
<li><code>&gt;&gt;</code>  带符号右移，高位补符号位。 正数右移一位相当于除以2。</li>
<li><code>&gt;&gt;&gt;</code> 无符号右移。高位补<code>0</code>。 正数右移一位相当于除以2。</li>
<li><code>&lt;&lt;</code>  左移,低位补<code>0</code>。 正数左移一位相当于乘以2。</li>
</ul>
<p>除了<code>~</code>是一元操作符外其它都是二元操作符号。</p>
<a id="more"></a>

<h2 id="byte类型转int类型">byte类型转int类型</h2>
<p>Java在将byte类型的数值转为int的过程中，会将符号位扩充， <code>10000000</code> -&gt; <code>11111111111111111111111110000000</code>。 这样数值会保持不变， 如下面的例子中字节类型的-128还是整型的-128。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = -<span class="number">128</span>;</div><div class="line"><span class="keyword">int</span> i1 = b & <span class="number">0xff</span>;</div><div class="line"><span class="keyword">int</span> i2 = b;</div><div class="line">System.out.println(i1); <span class="comment">//128</span></div><div class="line">System.out.println(i2); <span class="comment">//-128</span></div><div class="line">System.out.println(Integer.toBinaryString(i1)); <span class="comment">//10000000</span></div><div class="line">System.out.println(Integer.toBinaryString(i2)); <span class="comment">//11111111111111111111111110000000</span></div></pre></td></tr></table></figure>

<p>但是， 如果byte是无符号的整数， 你就要考虑使用<code>0xff</code>进行与操作。这样得到的结果数值不变，避免Java自动进行符号位扩充。</p>
<p><code>0xff</code>的补码为<code>11111111</code>， 意味着和它与操作将只保留后8位，并且结果总是非负数</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="external">http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/Bitwise_operation#Shifts_in_Java" target="_blank" rel="external">http://en.wikipedia.org/wiki/Bitwise_operation#Shifts_in_Java</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html" target="_blank" rel="external">http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h2 id="原码，反码和补码">原码，反码和补码</h2>
<p>这个是计算机的基础知识了。</p>
<p><code>+3</code>的原码为<code>00000011</code>，<br><code>-3</code>的原码为<code>10000011</code>，<br>第一位是符号位。</p>
<p><code>+3</code>的反码为<code>00000011</code>，<br><code>-3</code>的反码为<code>11111100</code>，<br>正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<p><code>+3</code>的补码为<code>00000011</code>，<br><code>-3</code>的补码为<code>11111101</code>，<br>正数的补码就是其本身<br>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<p>使用补码可以将减法变为加法，而且<code>0</code>的问题也会解决。</p>
<p>Java中使用补码的格式保存byte,short,int,long类型的数据。 （ two’s complement integer.）</p>
<h2 id="位操作符">位操作符</h2>
<ul>
<li><code>&amp;</code> 与。 按补码的每一位进行与操作。</li>
<li><code>|</code> 或。 按补码的每一位进行与操作。</li>
<li><code>^</code> 异或。 按补码的每一位进行与操作。</li>
<li><code>~</code> 取反。 按补码的每一位进行与操作。</li>
<li><code>&gt;&gt;</code>  带符号右移，高位补符号位。 正数右移一位相当于除以2。</li>
<li><code>&gt;&gt;&gt;</code> 无符号右移。高位补<code>0</code>。 正数右移一位相当于除以2。</li>
<li><code>&lt;&lt;</code>  左移,低位补<code>0</code>。 正数左移一位相当于乘以2。</li>
</ul>
<p>除了<code>~</code>是一元操作符外其它都是二元操作符号。</p>
]]></summary>
    
      <category term="Java" scheme="http://colobu.com/tags/Java/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Buffer编程基础]]></title>
    <link href="http://colobu.com/2014/10/20/java-buffer-basic/"/>
    <id>http://colobu.com/2014/10/20/java-buffer-basic/</id>
    <published>2014-10-20T00:39:20.000Z</published>
    <updated>2014-10-27T05:21:42.000Z</updated>
    <content type="html"><![CDATA[<p>Java 1.4中在java.nio包中增加了Buffer类以及一些处理基本数据类型的子类(除了boolean型) ，用来提供为基本数据类型(primitive) 的数据提供一个容器。<br>何谓Buffer? <code>Buffer</code> 是一个线性的有限长度的特定基本数据的序列。 除了基础数据外，它还包括一些基础操作和属性， 比如<code>capacity</code>, <code>limit</code> 和 <code>position</code>。</p>
<p>实际使用中使用特定的子类来处理数据。每个子类都定义了两套get/put的操作。 </p>
<ul>
<li><strong>相对位置操作 （Relative ）</strong>。 从当前位置<code>position</code>读写一个或者多个元素， 并<code>position</code>增加相应的数值。 如果一个get请求的数据超过了<code>limit</code>的位置，会抛出<code>BufferUnderflowException</code>异常。 如果一个put操作超过了<code>limit</code>的限制， 会抛出<code>BufferOverflowException</code>异常。不管上面哪种情况，没有数据被传输。</li>
<li><strong>绝对位置操作 （Absolute ）</strong>。 显式地提供index， 不会影响<code>position</code>的值。 如果索引超过<code>limit</code>会抛出<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<p>数据也可以通过<code>Channel</code>的I/O操作如<code>write</code>,<code>read</code> 写入或者读出。<br>显然， Buffer只有写入了数据才可能有意义的数据读出。</p>
<p>Buffer类并不是线程安全的， 使用时要特别小心， 避免多线程同时读写同一个Buffer。 万不得已， 需要为读写操作加锁。</p>
<p><a id="more"></a></p>
<blockquote>
<p><strong>cache和buffer的区别</strong><br>从应用场景上看：<code>Buffer</code> 更多的(场景)是减小写操作的冲击，而 <code>Cache</code> 主要用于减小读 I/O 的重复开销。</p>
</blockquote>
<h2 id="Buffer抽象类的成员">Buffer抽象类的成员</h2>
<p>Buffer提供了一系列的操作缓冲区的方法以及属性。 但是属性(property)不是以字段<code>field</code>的方式提供，而是以方法<code>method</code>的方式提供。 </p>
<h3 id="属性properties">属性properties</h3>
<ul>
<li><code>capacity()</code> ： 上面提到， Buffer里的元素是有限的。 这个值代表Buffer的元素的最大数量。 这个值不会为负数， 也不会被改变。</li>
<li><code>limit()</code> ： 很多情况下， 缓冲区不是填满的。 <code>limit</code>是第一不应该被读/写的数据的索引位置。 显然这个值不能为负数，也不会超过<code>capacity</code>的值。</li>
<li><code>position()</code> ： 下一个要被读/写的数据的索引。 不能为负值也不会超过<code>limit</code>的值。</li>
<li><code>mark</code> ： 被标记的索引。 调用<code>reset</code>方法会将<code>position</code>的值设为<code>mark</code>的值。 这样可以重新读/写Buffer的数据。 当<code>position</code>或者<code>limit</code>的值小于它的值时，它的值会被丢弃。 它的值不能为负数，也不会超过<code>position</code>的值， 也可能没有设置， 如果没有设置的话调用<code>reset</code>方法会抛出<code>InvalidMarkException</code>异常。 没有直接读取的方法。</li>
<li><code>remaining()</code> ： 返回<code>position</code>和<code>limit</code>之差， 也就是未读/写的数据的数量.</li>
</ul>
<h3 id="操作方法">操作方法</h3>
<ul>
<li><code>reset</code> 重置。 将<code>position</code>的值重置为<code>mark</code>的值。 这个方法不会更改<code>mark</code>的值，也不会将<code>mark</code>的值丢掉。</li>
<li><code>clear</code> 清空。 清空缓冲区。 <code>position</code>的值设为<code>0</code>， <code>limit</code>的值设为<code>capacity</code>，<code>mark</code>的值被丢弃。 在填充Buffer之前一般会调用此方法:<code>buf.clear(); in.read(buf);</code>。 这个方法不会擦除以前填充的数据，但是在实际使用中的情况下功能一样。</li>
<li><code>flip</code> 反转。 反转缓冲区会将<code>limit</code>的值设为<code>position</code>的值， 然后<code>position</code>的值设为<code>0</code>。 如果设置了<code>mark</code>, 则会被丢弃。 一般在填充完缓冲区后读写数据时调用此方法：<code>buf.put(magic);in.read(buf);buf.flip();out.write(buf);</code> </li>
<li><code>rewind</code> 回退。 <code>position</code>设为<code>0</code>, <code>mark</code>值被丢弃, <code>limit</code>的值不变。 和上面的<code>flip</code>类似，但是<code>flip</code>会改变<code>limit</code>的值，但是<code>remind</code>不会。 应用场景: <code>out.write(buf);buf.rewind();  buf.get(array);</code></li>
<li><code>mark()</code> 标记当前位置。 用<code>position</code>的值设置<code>mark</code>。</li>
</ul>
<p><code>clear</code>,<code>flip</code>,<code>limit(newLimit)</code>,<code>mark</code>,<code>position(newPosition)</code>, <code>reset()</code>和<code>rewind</code>返回本身的Buffer， 这意味着你可以使用流式风格， 如<br><code>buffer.flip().position(23).limit(42);</code></p>
<p>请记住以下公式， 下面的不等式在任何时候都成立：<br><em>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</em><br>一个新创建的Buffer的<code>position</code>总是<code>0</code>, mark未定义。 初始的<code>limit</code>可能为<code>0</code>,或者其它正值， 这依赖于buffer的类型以及它是如何创建的。 初始化的Buffer包含零个元素。</p>
<p>另外， Buffer还提供其它的一些成员：</p>
<ul>
<li><code>array</code>： 返回底层的数组实现。 如果底层不是使用数组实现，或者是只读的， 可能会抛出异常<code>ReadOnlyBufferException</code>, <code>UnsupportedOperationException</code>。 一般使用前会调用<code>hasArray</code>判断是否支持数组。 Buffer内容的修改会影响数组的值，反之亦然。</li>
<li><code>arrayOffset</code>： Buffer的<code>position</code>的值<code>p</code>对应 数组的<code>p + arrayOffset()</code>， 也就是Buffer的第一个元素在数组中的偏移值。</li>
<li><code>hasArray</code>： 判断Buffer是否有底层的数组实现。</li>
<li><code>hasRemaining</code>： <code>position</code>和<code>limit</code>之前是否还有元素。</li>
<li><code>isReadOnly</code>： 是否只读。</li>
<li><code>isDirect</code>： buffer是否是直接缓冲区。</li>
</ul>
<p><strong>equals()</strong><br>当满足下列条件时，表示两个Buffer相等：</p>
<ul>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中<em>剩余的</em>byte、char等的个数相等。</li>
<li>Buffer中所有<em>剩余的</em>byte、char等都相同。<br>注意它只比较剩余的部分。</li>
</ul>
<p><strong>compareTo()</strong><br>compareTo()方法比较两个Buffer的<em>剩余</em>元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ul>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>前面的元素都相等，但第一个Buffer剩余的元素比另一个少。</li>
</ul>
<h2 id="Buffer的子类">Buffer的子类</h2>
<p><code>Buffer</code>是一个抽象类。 实际我们使用的是它的子类， 主要是针对基本数据类型做的优化。</p>
<h3 id="ByteBuffer：_最通用的子类，_处理字节数据类型。"><code>ByteBuffer</code>： 最通用的子类， 处理字节数据类型。</h3>
<p>提供了get/put 单个字节或者字节数组的方法， 还是分相对和绝对操作。<br>字节是其它基本数据类型的基础。 比如int类型是32位也就是4个字节。 </p>
<table>
<thead>
<tr>
<th>Data Type</th>
<th>size (byte)</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>所以可以将这些基本数据类型的数据写入到字节缓冲区中或者从中读出。<br>ByteBuffer针对基本数据类型定义了便利的方法， 如<code>getChar()</code>,<code>getInt()</code>,<code>putFloat</code>,<code>putShort</code> …等方法。<br>注意<code>putXXX</code>可能会抛出<code>BufferOverflowException</code>和<code>ReadOnlyBufferException</code>异常， <code>getXXX</code>可能会抛出<code>BufferUnderflowException</code>异常。</p>
<p>同时ByteBuffer还提供了创建视图<code>view</code>的方法。 可以基于ByteBuffer创建其它基本类型的buffer，它们的底层数据指向都一个对象，但是相应的<code>position</code>, <code>limit</code>,  <code>mark</code>都是独立的。例如<code>asIntBuffer()</code>返回一个<code>IntBuffer</code>对象， 返回的<code>IntBuffer</code>对象的第一个元素对应于此<code>ByteBuffer</code>的<code>position</code>的位置的元素。 <code>IntBuffer</code>的<code>position</code>的值为<code>0</code>,<code>capacity</code> 和<code>limit</code>是此<code>ByteBuffer</code>的剩余的字节的数量/4 (int是四个字节)， mark未定义。 当且仅当<code>ByteBuffer</code>是直接缓冲区时此<code>IntBuffer</code>才是直接缓冲区， 当且仅当<code>ByteBuffer</code>是只读的 <code>IntBuffer</code>才是只读的。</p>
<p>注意<code>ByteBuffer</code>依然是抽象类， <code>allocate</code>方法和<code>allocateDirect</code>方法创建缓冲区时实际是创建<code>HeapByteBuffer</code>或者<code>DirectByteBuffer</code>类。</p>
<p>仍然支持流式风格。 <code>bb.putInt(0xCAFEBABE).putShort(3).putShort(45);</code></p>
<p><code>asReadOnlyBuffer()</code>转换成只读缓冲区。新缓冲区的position, limit, 和 mark是独立的。 初始值和原缓冲区相同。<br><code>duplicate</code>复制当前的<code>ByteBuffer</code>,底层的数据是公用的，但是<code>position</code>,<code>capacity</code>,<code>limit</code> ,<code>mark</code>是独立的， 方法返回的<code>ByteBuffer</code>初始拥有和原<code>ByteBuffer</code>相同的<code>position</code>,<code>capacity</code>,<code>limit</code> ,<code>mark</code>。<br><code>slice()</code>也是一个新的byte buffer，和原bye buffer的数据共享。 但是新的byte buffer将自原byte buffer的<code>position</code>的位置开始。 这也就是slice的含义。</p>
<p>提供了<code>allocate(int capacity)</code>和<code>allocateDirect(int capacity)</code>两种方法。<br><code>wrap(byte[] array)</code>, <code>wrap(byte[] array, int offset, int length)</code>将字节数组包装成<code>ByteBuffer</code>。</p>
<p><code>order()</code>和<code>order(ByteOrder bo)</code>用来返回和设置<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="external">字节序</a>： 大端模式（BIG_ENDIAN）和小端模式（LITTLE_ENDIAN）。 默认总是大端模式(BIG_ENDIAN)。</p>
<p><code>compact</code>: 压缩ByteBuffer。 将<code>position</code>和<code>limit</code>的之间的数据复制到缓冲区的开始部分。 比如另p = <code>position</code>,则将 <code>p + 1</code>处的数据复制到<code>index 1</code>， …… <code>limit -1</code>处的数据复制到<code>n = limit -1 -p</code>。 缓冲区的<code>position</code>设置为<code>n+1</code>， limit设置为<code>capacity</code>， mark丢弃. </p>
<p>以下的子类类似ByteBuffer，但是没有转换成其它Buffer的方法和视图。这是容易理解的，因为Byte才是其它基本数据类型的基础单位。<br><code>wrap</code>包装相应基本数据类型的数组。依然有<code>compact</code>, <code>duplicate</code>, <code>slice</code>方法. 流式风格， get/put 单数据操作和批操作， 相对位置操作和绝对位置操作。</p>
<h3 id="CharBuffer"><code>CharBuffer</code></h3>
<p>提供了<code>append</code>方法，等同于put方法。<br><code>charAt(int index)</code>返回指定位置的字符。<br><code>subSequence(int start, int end)</code>返回指定位置的缓冲区。 与原缓冲区共享数据。 <code>capacity</code>相同。 新缓冲区的<code>position</code>为原缓冲区<code>position</code> + start, <code>limit</code>为原缓冲区的<code>position</code> + end。 <code>direct</code>, <code>readonly</code>和原缓冲区相同。</p>
<h3 id="DoubleBuffer"><code>DoubleBuffer</code></h3>
<p>处理double类型数据。</p>
<h3 id="FloatBuffer"><code>FloatBuffer</code></h3>
<p>处理float类型数据。</p>
<h3 id="IntBuffer"><code>IntBuffer</code></h3>
<p>处理<code>int</code>类型数据。</p>
<h3 id="LongBuffer"><code>LongBuffer</code></h3>
<p>处理<code>long</code>类型数据。</p>
<h3 id="ShortBuffer"><code>ShortBuffer</code></h3>
<p>处理<code>short</code>类型数据。</p>
<h3 id="MappedByteBuffer"><code>MappedByteBuffer</code></h3>
<p>继承于<code>ByteBuffer</code>。 它是以内存镜像文件为基础的直接字节缓冲区。 可以通过<code>FileChannel.map</code>创建。<br><code>force()</code>强制对数据的改变写入到存储设备。<br><code>isLoaded()</code> : 缓冲区的数据是否都全部加载到物理内存中。<br><code>load()</code> : 加载缓冲区的数据到物理内存中。</p>
<blockquote>
<p>内存映射文件是一种允许Java程序直接从内存访问的特殊文件。通过将整个文件或者文件的一部分映射到内存中、操作系统负责获取页面请求和写入文件，应用程序就只需要处理内存数据，这样可以实现非常快速的IO操作。用于内存映射文件的内存在Java的堆空间以外。</p>
</blockquote>
<h2 id="Buffer的创建">Buffer的创建</h2>
<ul>
<li>allocate()或者allocateDirect()</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">CharBuffer cb</span> = CharBuffer.allocate(<span class="number">1024</span>);</div><div class="line"><span class="constant">ByteBuffer bb</span> = ByteBuffer.allocateDirect(<span class="number">1024</span>*<span class="number">1024</span>);</div></pre></td></tr></table></figure>

<ul>
<li>包装一个数组</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] bytes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>];</div><div class="line">IntBuffer ib = IntBuffer.wrap(bytes);</div></pre></td></tr></table></figure>

<ul>
<li>内存映射，即调用FileChannel的map()方法</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FileChannel <span class="variable">fc =</span> new RandomAccessFile(<span class="string">"test.data"</span>, <span class="string">"rw"</span>).getChannel();   </div><div class="line">MappedByteBuffer <span class="variable">out =</span> fc.<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, length);</div></pre></td></tr></table></figure>

<h3 id="直接缓冲区和间接缓冲区">直接缓冲区和间接缓冲区</h3>
<p>byte buffer既可以是直接缓冲区可以是非直接缓冲区。 对于直接缓冲区， Java虚拟机极可能的直接执行native I/O操作，避免在操作系统的native I/O操作时还要复制内容到一个中间缓冲区。<br>它使用Native函数库直接分配堆外内存，然后通过一个存储在JAVA堆里面的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。</p>
<p>可以通过<code>allocateDirect</code>工厂方法直接创建直接缓冲区， 内部会创建<code>DirectByteBuffer</code>对象， 通过<code>unsafe.allocateMemory</code>分配内存。 相对而言， 这个方法返回的缓冲区要比非直接缓冲区多少有点更高的分配/销毁的花费 (时间和空间)。 直接缓冲区在垃圾回收堆的外部， 所以建议主要用于大的长时间活动的缓冲区，确实能提高性能的环境中。</p>
<p>也可以通过内存镜像文件的方式使用直接缓冲区 <code>FileChannel.map</code>。 Java平台可选择使用JNI来创建直接缓冲区。 如果Buffer指向一个不能访问的内存区域时， 缓冲区的内容不会被更改， 访问操作可能会导致一个不确定的异常。 </p>
<p>可以通过<code>isDirect</code>方法判断一个缓冲区是否是直接缓冲区。</p>
<p>虽然直接缓冲区是堆外内存，但是由于<code>DirectByteBuffer</code>引用了它，当<code>DirectByteBuffer</code>被垃圾回收时，此堆外内存会被释放掉，不会出现内存泄漏的问题。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/nio/package-summary.html" target="_blank" rel="external">JavaDOC</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/buffers.html#basicusage" target="_blank" rel="external">Java NIO Buffer</a></li>
<li><a href="http://stackoverflow.com/questions/590069/how-would-you-code-an-efficient-circular-buffer-in-java-or-c-sharp?lq=1" target="_blank" rel="external">How would you code an efficient Circular Buffer in Java or C#</a></li>
<li><a href="http://ostermiller.org/utils/CircularBuffer.html" target="_blank" rel="external"> Ostermiller Java Utilities</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>Java 1.4中在java.nio包中增加了Buffer类以及一些处理基本数据类型的子类(除了boolean型) ，用来提供为基本数据类型(primitive) 的数据提供一个容器。<br>何谓Buffer? <code>Buffer</code> 是一个线性的有限长度的特定基本数据的序列。 除了基础数据外，它还包括一些基础操作和属性， 比如<code>capacity</code>, <code>limit</code> 和 <code>position</code>。</p>
<p>实际使用中使用特定的子类来处理数据。每个子类都定义了两套get/put的操作。 </p>
<ul>
<li><strong>相对位置操作 （Relative ）</strong>。 从当前位置<code>position</code>读写一个或者多个元素， 并<code>position</code>增加相应的数值。 如果一个get请求的数据超过了<code>limit</code>的位置，会抛出<code>BufferUnderflowException</code>异常。 如果一个put操作超过了<code>limit</code>的限制， 会抛出<code>BufferOverflowException</code>异常。不管上面哪种情况，没有数据被传输。</li>
<li><strong>绝对位置操作 （Absolute ）</strong>。 显式地提供index， 不会影响<code>position</code>的值。 如果索引超过<code>limit</code>会抛出<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<p>数据也可以通过<code>Channel</code>的I/O操作如<code>write</code>,<code>read</code> 写入或者读出。<br>显然， Buffer只有写入了数据才可能有意义的数据读出。</p>
<p>Buffer类并不是线程安全的， 使用时要特别小心， 避免多线程同时读写同一个Buffer。 万不得已， 需要为读写操作加锁。</p>
<p>]]></summary>
    
      <category term="buffer" scheme="http://colobu.com/tags/buffer/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式系统原理--日志技术Redo Log]]></title>
    <link href="http://colobu.com/2014/10/16/redo-log-in-distribution-systems/"/>
    <id>http://colobu.com/2014/10/16/redo-log-in-distribution-systems/</id>
    <published>2014-10-16T00:56:10.000Z</published>
    <updated>2014-10-16T01:07:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="问题概述">问题概述</h1>
<p>在分布式系统中，宕机是需要考虑的重要组成部分。日志技术是宕机恢复的重要技术之一。日志技术应用广泛，早些更是广泛应用在数据库设计实现中。本文先介绍基本原理概念，最后通过redis介绍生产环境中的实现方法。</p>
<p><a id="more"></a><br>转载: <a href="http://studentdeng.github.io/blog/2014/10/13/log-system/" target="_blank" rel="external">分布式系统原理—日志技术Redo Log</a></p>
<h1 id="Redo_Log">Redo Log</h1>
<p>数据库设计中，需要满足ACID，尤其是在支持事务的系统中。当系统遇到未知错误时，可以恢复到一个稳定可靠的状态。有一个很简单的思路，就是记录所有对数据库的写操作日志。那么一旦发生故障，即使丢失掉内存中所有数据，当下一次启动时，通过复现已经记录的数据库写操作日志，依然可以回到故障之前的状态（如果在写操作作日志的时候发生故障，那么这次数据库操作失败）。</p>
<p>操作流程简单如下（假设每次数据变化，都提交）：</p>
<ol>
<li>更新的操作方式依次记录到磁盘日志文件。</li>
<li>更新内存中的数据。</li>
<li>返回更新成功结果。</li>
</ol>
<p>恢复流程：</p>
<ol>
<li>读取日志文件，依次修改内存中的数据。</li>
</ol>
<p>优点：</p>
<ol>
<li>日志文件有序，可以通过append的方式写入磁盘，性能很高。</li>
<li>简单可靠，应用广泛。可以把内存中的数据，做备份在磁盘中。</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用时间一长，恢复宕机的时间很慢。</li>
</ol>
<h1 id="解决办法">解决办法</h1>
<p>先具体化下，如果我们内存中保留一个a的值，记录了写操作比如 a = 4; a++; a—; 当这些操作上千万、亿之后，恢复非常慢。甚至可能最后一条就是a=0，按照之前的算法，我们却跑了很长时间。<br>那么根据这个场景，很容易想到一个解决方案。</p>
<p>操作流程：</p>
<ol>
<li>日志文件记录<code>begin check point</code></li>
<li>在某个时刻，把内存中的数值，直接snapshot或dump到磁盘上。（比如直接记录a=4）</li>
<li>日志文件记录<code>end check point</code></li>
</ol>
<p>恢复流程：</p>
<ol>
<li>扫描日志文件，找到最后的<code>end check point</code>中配对的<code>begin check point</code>。</li>
<li>读入dump文件。</li>
<li>依次回放记录的日志操作。</li>
</ol>
<p>优点：</p>
<ol>
<li>应用广泛，包括 mysql，oracle。</li>
</ol>
<p>一些棘手的问题：</p>
<ol>
<li>在做snapshot的时候，往往不能停止数据库的服务，那么很可能记录了<code>begin check point</code>之后的日志。那么在重新<code>load begin check</code> point之后的日志时，最后恢复的数据很有可能不对。比如我们记录的是a++这样的日志, 那么重复一条日志，就会让a的值加1。反之如果我们记录是幂等的，比如一直是 a=5 这种操作，那么就对最后结果没有影响。很显然，设计幂等操作系统很麻烦。</li>
<li>设计一个支持snapshot的内存数据结构，也比较麻烦。</li>
</ol>
<p>典型的是通过<code>copy-on-write</code>机制。和操作系统中的概念一样。当这个数据结构被修改，就创建一份真正的copy。老数据增加一份dirty flag。如果没有修改就继续使用之前的内存。这样在做snapshot的时候，保证我们的dump数据是<code>begin check point</code>这个时刻的数据。显然这个也比较麻烦。</p>
<p>还有一种支持snapshot的思路是begin check point后，不动老的数据。内存中的数据在新的地方，日志也写在新的地方。最后在<code>end check point</code>做一次merge。这个实现起来简单，但是内存消耗不小。</p>
<h1 id="Redis是如何解决日志问题的">Redis是如何解决日志问题的</h1>
<p>Redis 是一个基于内存的database，不同于memcached，他支持持久化。另外由于redis处理client request 和 response 都是在一个thread里面，也没有抢占式的调度系统，核心业务都是按照event loop顺序执行，而磁盘写日志又开销很大，所以redis实现日志功能做了很多优化。并且提供2种持久化方案。我们需要在不同的场景下，采用不同的方式配置。</p>
<p><strong>snapshotting</strong><br>某个时刻，redis会把内存中的所有数据snapshot到磁盘文件。更通俗的说法是fork一个child process，把内存中的数据序列化到临时文件，然后在main event loop 中原子的更换文件名。redis，利用了操作系统VM的copy-on-write机制，在不阻塞主线程的情况下，利用子进程和父进程共享的data segment实现snapshot。具体是代码实现在<code>rdb.c</code>, <code>function at rdbSaveBackground</code></p>
<p>优点：</p>
<ol>
<li>简单可靠，如果database 不大，执行的效果非常好。</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果database size 很大，每一次snapshot时间非常长。不得不配置大的间隔，提高了宕机时数据丢失的风险。</li>
</ol>
<p>为了解决上面的问题，redis增加了AOF。</p>
<h1 id="Append_Only_File（AOF）">Append Only File（AOF）</h1>
<p>在database术语中，也被叫做WAL。如果开启的AOF的配置，redis会记录所有写操作到日志文件中。那么redis同样会遇到之前我们提到过的问题。</p>
<ol>
<li>即便是追加写，磁盘的操作依然比内存慢好几个数量级，频繁的操作容易产生瓶颈。</li>
<li>如果数据量操作频繁，会产生大量的重复日志数据，导致恢复时间太长。比如记录一条微博的浏览量，会记录大量重复的<code>+1</code>日志。</li>
</ol>
<p>那么redis是如何解决的呢？</p>
<ol>
<li>文件写操作消耗的时间很长，redis会先把记录日志写在内存buffer中，在每一次event loop 结束之后，根据配置判断是否做写操作。每个buffer的大小有限制，这样每次写操作时间不会太长。</li>
<li>即便是调用write操作，OS并没有立即写入磁盘，redis 同样提供了一些方案决定刷新OS IO buffer的时机（1秒、从不、每次）。</li>
<li>redis 提供一种AOF重写的方式<code>rewriteAppendOnlyFile</code>来处理AOF文件过大情况。</li>
</ol>
<p>前面我们知道了，这种<code>check point</code>的机制还是比较麻烦的。那么redis是这么设计的。</p>
<p><img src="http://i.gyazo.com/314a668a8443b0de126685cfb4197fbc.png" alt=""></p>
<ol>
<li>为了避免加锁，redis 依然创建了一个child process，利用VM的copy-on-write，共享数据。同时保证主线程依然可以处理client请求。</li>
<li>根据KV的类型，先从内存读取数据，然后再写数据到磁盘，和之前的AOF文件无关。</li>
<li>那么当子进程rewrite AOF的过程中，main thread依然可以处理新的client request。新增的数据会被放在rewrite buffer中，而且写到原有的AOF文件中。</li>
<li>child process完成后会通知主线程。主线程有一个定时任务，也就是会不断轮询child process是否已经完成（通过信号量）。</li>
<li>主线程会merge 变化的数据到temp file。</li>
<li>主线程原子的rename到一个新的AOF文件，之前的AOF就不起作用了。</li>
</ol>
<p>优点：</p>
<ol>
<li>除了merge 和 rename需要阻塞主线程，rewrite不会阻塞主线程。（前提是使用bgrewrite command）。</li>
</ol>
<h1 id="最后">最后</h1>
<p>这些都是性能和稳定性之间做的权衡，根据不同场景需要调整。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="http://redis.io/topics/latency" target="_blank" rel="external">Redis latency problems troubleshooting</a></li>
<li><a href="http://wenku.baidu.com/view/53b7505777232f60ddcca1e0.html" target="_blank" rel="external">分布式系统原理介绍</a></li>
<li><a href="http://blog.kennejima.com/post/1226487020/thoughts-on-redis#" target="_blank" rel="external">Thoughts on Redis</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h1 id="问题概述">问题概述</h1>
<p>在分布式系统中，宕机是需要考虑的重要组成部分。日志技术是宕机恢复的重要技术之一。日志技术应用广泛，早些更是广泛应用在数据库设计实现中。本文先介绍基本原理概念，最后通过redis介绍生产环境中的实现方法。</p>
<p>]]></summary>
    
      <category term="高并发编程" scheme="http://colobu.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 同时支持Github和Gitcafe]]></title>
    <link href="http://colobu.com/2014/10/13/hexo-supports-both-github-and-gitcafe/"/>
    <id>http://colobu.com/2014/10/13/hexo-supports-both-github-and-gitcafe/</id>
    <published>2014-10-13T07:16:23.000Z</published>
    <updated>2014-10-13T07:44:06.000Z</updated>
    <content type="html"><![CDATA[<p>Hexo支持同时发布到多个git仓库中。需要修改<code>_config.yml</code>。<br>原来的配置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="label">deploy:</span></div><div class="line"><span class="label">type:</span> github</div><div class="line"><span class="label">repo:</span> github: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git</div><div class="line"><span class="label">branch:</span> master</div></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   type: git</div><div class="line">   repo: </div><div class="line">      github: https:<span class="comment">//github.com/&lt;username&gt;/&lt;username&gt;.github.io.git,master</span></div><div class="line">      gitcafe: https:<span class="comment">//gitcafe.com/&lt;username&gt;/&lt;username&gt;.git,gitcafe-pages</span></div></pre></td></tr></table></figure>

<p>首先需要你在gitcafe创建一个和用户名相同的项目，并为此项目创建一个<code>gitcafe-pages</code>。 静态站点发布到这个分支上。 同时需要绑定你的域名在此项目上。<br>这和<code>github</code>有点不同。 <code>github</code>要求创建一个<code>&lt;username&gt;.github.io</code>的项目，站点发布到master分支即可。</p>
<p><strong>dnspod</strong><br>之所以发布到两个站点， 主要是想让国内的用户直接访问g<code>gircafe</code>上的站点，这样速度快一点。<br>你可以在dnspod上针对不同的线路配置不同的A记录。</p>
<p>参考文档：</p>
<ul>
<li><a href="http://blog.billryan.me/posts/2014/05/multi-deployment-with-hexo.html" target="_blank" rel="external">Hexo多Repo部署——使用Github和GitCafe同时托管博客</a></li>
<li><a href="http://www.autonavi.me/2014/09/09/Hexo%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%85%A2.html" target="_blank" rel="external">HEXO个人博客速度优化</a></li>
<li><a href="http://blog.magiclin.com/2013/12/20/hexo-gitcafe/" target="_blank" rel="external">部署Hexo静态blog到gitcafe</a></li>
</ul>
]]></content>
    
    
      <category term="前端开发" scheme="http://colobu.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript 函数前面的一元操作符]]></title>
    <link href="http://colobu.com/2014/10/13/javascript-function-and-unary-operators/"/>
    <id>http://colobu.com/2014/10/13/javascript-function-and-unary-operators/</id>
    <published>2014-10-13T05:58:05.000Z</published>
    <updated>2014-10-13T06:16:27.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://segmentfault.com/q/1010000000117476" target="_blank" rel="external">segmentfault</a>上的一个问题：</p>
<p>一般看JQuery插件里的写法是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">($)</span> </span>{         </div><div class="line">  <span class="comment">//...  </span></div><div class="line">})(jQuery);</div></pre></td></tr></table></figure>

<p>今天看到bootstrap的javascript组件是这样写的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span><span class="params">( $ )</span></span>{</div><div class="line">  <span class="comment">//...</span></div><div class="line">}( <span class="built_in">window</span>.jQuery );</div></pre></td></tr></table></figure>

<p>为什么要在前面加一个 “ ! “ 呢？<br>原来，使用括号包裹定义函数体，解析器将会以函数表达式的方式去调用定义函数。也就是说，任何能将函数变成一个函数表达式的作法，都可以使解析器正确的调用定义函数。而 ! 就是其中一个，而 + - || 都有这样的功能。<br>另外，用 ! 可能更多的是一个习惯问题，不同的运算符，性能是不同的。<br><a id="more"></a></p>
<p>有一篇非常详细的文章，特意转载： <a href="http://swordair.com/function-and-exclamation-mark/" target="_blank" rel="external">http://swordair.com/function-and-exclamation-mark/</a></p>
<p>最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，@西子剑影抛出的一样的问题：如果在function之前加上感叹号 (!) 会怎么样？比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p>
<p>平时我们可能对添加括号来调用匿名函数的方式更为习惯：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)})()        <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}())        <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>虽然上述两者括号的位置不同，不过效果完全一样。</p>
<p>那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。</p>
<p>回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？</p>
<p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}        <span class="comment">// undefined</span></div></pre></td></tr></table></figure>

<p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// SyntaxError: unexpected_token</span></div></pre></td></tr></table></figure>

<p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 a，就应该以 a(); 的方式调用。</p>
<p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p>
<p>所以，任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="keyword">return</span> <span class="number">10</span>}();        <span class="comment">// undefined  </span></div><div class="line"><span class="number">1</span> && <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="keyword">return</span> <span class="literal">true</span>}();        <span class="comment">// true  </span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}();        <span class="comment">// undefined</span></div></pre></td></tr></table></figure>

<p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些一元运算都是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// true</span></div><div class="line">+<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// NaN</span></div><div class="line">-<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// NaN</span></div><div class="line">~<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// -1</span></div></pre></td></tr></table></figure>

<p>甚至下面这些关键字，都能很好的工作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// undefined  </span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// Object  </span></div><div class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}()        <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)})()        <span class="comment">// undefined</span></div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">'iifksp'</span>)}())        <span class="comment">// undefined</span></div></pre></td></tr></table></figure>

<p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p>
<p>最后讨论下性能。我在jsperf上简单建立了一个测试：<a href="http://jsperf.com/js-funcion-expression-speed" target="_blank" rel="external">http://jsperf.com/js-funcion-expression-speed</a> ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）：</p>
<table><tbody><tr><th rowspan="2">Option</th><th rowspan="2">Code</th><th colspan="4">Ops/sec</th></tr><tr><th>Chrome 13</th><th>Firefox 6</th><th>IE9</th><th>Safari 5</th></tr><tr><th>!</th><td>!function(){;}()</td><td style="text-align:right;">3,773,196</td><td style="text-align:right;">10,975,198</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">2,810,197</td></tr><tr><th>+</th><td>+function(){;}()</td><td style="text-align:right;background:#9cee82;">21,553,847</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">1,812,238</td></tr><tr><th>-</th><td>-function(){;}()</td><td style="text-align:right;background:#9cee82;">21,553,847</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">1,864,155</td></tr><tr><th>~</th><td>~function(){;}()</td><td style="text-align:right;">3,551,136</td><td style="text-align:right;">3,651,652</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">1,876,002</td></tr><tr><th>(1)</th><td>(function(){;})()</td><td style="text-align:right;">3,914,953</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;background:#9cee82;">3,025,608</td></tr><tr><th>(2)</th><td>(function(){;}())</td><td style="text-align:right;">4,075,201</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;background:#9cee82;">3,025,608</td></tr><tr><th>void</th><td>void function(){;}()</td><td style="text-align:right;">4,030,756</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;background:#9cee82;">3,025,608</td></tr><tr><th>new</th><td>new function(){;}()</td><td style="text-align:right;background:#ffc0cb;">619,606</td><td style="text-align:right;background:#ffc0cb;">299,100</td><td style="text-align:right;background:#ffc0cb;">407,104</td><td style="text-align:right;background:#ffc0cb;">816,903</td></tr><tr><th>delete</th><td>delete function(){;}()</td><td style="text-align:right;">4,816,225</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">2,693,524</td></tr><tr><th>=</th><td>var i = function(){;}()</td><td style="text-align:right;">4,984,774</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;">565,982</td><td style="text-align:right;">2,602,630</td></tr><tr><th>&amp;&amp;</th><td>1 &amp;&amp; function(){;}()</td><td style="text-align:right;">5,307,200</td><td style="text-align:right;">4,393,486</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">2,565,645</td></tr><tr><th>||</th><td>0 || function(){;}()</td><td style="text-align:right;">5,000,000</td><td style="text-align:right;">4,406,035</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">2,490,128</td></tr><tr><th>&amp;</th><td>1 &amp; function(){;}()</td><td style="text-align:right;">4,918,209</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">1,705,551</td></tr><tr><th>|</th><td>1 | function(){;}()</td><td style="text-align:right;">4,859,802</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">1,612,372</td></tr><tr><th>^</th><td>1 ^ function(){;}()</td><td style="text-align:right;">4,654,916</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">1,579,778</td></tr><tr><th>,</th><td>1, function(){;}()</td><td style="text-align:right;">4,878,193</td><td style="text-align:right;background:#9cee82;">12,135,960</td><td style="text-align:right;background:#9cee82;">572,694</td><td style="text-align:right;">2,281,186</td></tr></tbody></table>

<p>可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。</p>
<p>但我们还是可以从中找出很多共性：new方法永远最慢——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观传统的括号，在测试里表现始终很快，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。加减号在chrome表现惊人，而且在其他浏览器下也普遍很快，相比感叹号效果更好。</p>
<p>当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。</p>
<p>但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘——</p>
<p>当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。</p>
<p>2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="http://segmentfault.com/q/1010000000117476" target="_blank" rel="external">segmentfault</a>上的一个问题：</p>
<p>一般看JQuery插件里的写法是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">($)</span> </span>{         </div><div class="line">  <span class="comment">//...  </span></div><div class="line">})(jQuery);</div></pre></td></tr></table></figure>

<p>今天看到bootstrap的javascript组件是这样写的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span><span class="params">( $ )</span></span>{</div><div class="line">  <span class="comment">//...</span></div><div class="line">}( <span class="built_in">window</span>.jQuery );</div></pre></td></tr></table></figure>

<p>为什么要在前面加一个 “ ! “ 呢？<br>原来，使用括号包裹定义函数体，解析器将会以函数表达式的方式去调用定义函数。也就是说，任何能将函数变成一个函数表达式的作法，都可以使解析器正确的调用定义函数。而 ! 就是其中一个，而 + - || 都有这样的功能。<br>另外，用 ! 可能更多的是一个习惯问题，不同的运算符，性能是不同的。<br>]]></summary>
    
      <category term="javascript" scheme="http://colobu.com/tags/javascript/"/>
    
      <category term="前端开发" scheme="http://colobu.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gitbook简明教程]]></title>
    <link href="http://colobu.com/2014/10/09/gitbook-quickstart/"/>
    <id>http://colobu.com/2014/10/09/gitbook-quickstart/</id>
    <published>2014-10-09T07:12:20.000Z</published>
    <updated>2014-10-09T08:24:44.000Z</updated>
    <content type="html"><![CDATA[<p>Gitbook是一个命令行工具(node.js库)， 使用Github/Git创建漂亮的图书。 你可以看一些用它编写的图书的例子： <a href="https://www.gitbook.io/book/GitBookIO/javascript" target="_blank" rel="external">学习Javascript</a>. 你也可以很容易的通过<a href="https://www.gitbook.io" target="_blank" rel="external">gitbook.io</a>网站发布在线图书。 <a href="https://github.com/GitbookIO/editor" target="_blank" rel="external">editor</a> 是一个图形化的编辑工具， 提供Windows, Mac 和Linux的版本. 关注Twitter帐号 <a href="https://twitter.com/GitBookIO" target="_blank" rel="external">@GitBookIO</a>. 这篇文章只是一个起步教程， 完整的文档可以在<a href="http://help.gitbook.io/" target="_blank" rel="external">help.gitbook.io</a>网站找到.<br><a id="more"></a><br><img src="https://raw.github.com/GitbookIO/gitbook/master/preview.png" alt="Image"></p>
<h2 id="怎么用:">怎么用:</h2>
<p>GitBook 可以通过 <strong>NPM</strong> 安装:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>npm install gitbook -g</div></pre></td></tr></table></figure>

<p>你可以将一个<code>repository</code>作为一本书:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>gitbook serve ./repository</div></pre></td></tr></table></figure>

<p>或者简单的生成静态网站:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">$ gitbook build ./repository --output</span>=<span class="string">./outputFolder</span></div></pre></td></tr></table></figure>

<p>命令 <code>build</code> 和 <code>serve</code> 的参数为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"><span class="input"><span class="prompt">o, --output &lt;directory&gt;</span>  输出文件件, 默认为 ./_book</span></span></div><div class="line">-<span class="ruby"><span class="input"><span class="prompt">f, --format &lt;name&gt;</span>       产生的书籍的类型, 默认为静态站点, 可用的格式为<span class="symbol">:</span> site, page, ebook, json</span></span></div><div class="line">-<span class="ruby"><span class="input"><span class="prompt">-config &lt;config file&gt;</span>    配置文件, 默认为 book.js 或 book.json</span></span></div></pre></td></tr></table></figure>

<p>GitBook 会从仓库中的<code>book.json</code>文件加载默认的配置，前提是此文件存在.</p>
<p>下面是此文件的一些配置项:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">    <span class="comment">// 输出文件夹</span></div><div class="line">    <span class="comment">// 注意: 它会覆盖命令行传入的参数</span></div><div class="line">    <span class="comment">// 不建议在此文件中配置</span></div><div class="line">    <span class="string">"output"</span>: <span class="literal">null</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 产生的书籍的类型</span></div><div class="line">    <span class="comment">// 注意: 它会覆盖命令行传入的参数</span></div><div class="line">    <span class="comment">// 不建议在此文件中配置</span></div><div class="line">    <span class="string">"generator"</span>: <span class="string">"site"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 图书标题和描述 (默认从README抽取)</span></div><div class="line">    <span class="string">"title"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="string">"description"</span>: <span class="literal">null</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 对于ebook格式, 扩展名the extension to use for generation (default is detected from output extension)</span></div><div class="line">    <span class="comment">// "epub", "pdf", "mobi"</span></div><div class="line">    <span class="comment">// 注意: 它会覆盖命令行传入的参数</span></div><div class="line">    <span class="comment">// 不建议在此文件中配置</span></div><div class="line">    <span class="string">"extension"</span>: <span class="literal">null</span>,</div><div class="line"></div><div class="line">    <span class="comment">// GitHub 信息(defaults are extracted using git)</span></div><div class="line">    <span class="string">"github"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="string">"githubHost"</span>: <span class="string">"https://github.com/"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 插件列表, can contain "-name" for removing default plugins</span></div><div class="line">    <span class="string">"plugins"</span>: [],</div><div class="line"></div><div class="line">    <span class="comment">// 插件通用配置</span></div><div class="line">    <span class="string">"pluginsConfig"</span>: {</div><div class="line">        <span class="string">"fontSettings"</span>: {</div><div class="line">            <span class="string">"theme"</span>: <span class="string">"sepia"</span>, <span class="string">"night"</span> or <span class="string">"white"</span>,</div><div class="line">            <span class="string">"family"</span>: <span class="string">"serif"</span> or <span class="string">"sans"</span>,</div><div class="line">            <span class="string">"size"</span>: <span class="number">1</span> to <span class="number">4</span></div><div class="line">        }</div><div class="line">    },</div><div class="line"></div><div class="line">    <span class="comment">// 模版中的链接 (null: default, false: remove, string: new value)</span></div><div class="line">    <span class="string">"links"</span>: {</div><div class="line">    	<span class="comment">// Custom links at top of sidebar</span></div><div class="line">    	<span class="string">"sidebar"</span>: {</div><div class="line">    	    <span class="string">"Custom link name"</span>: <span class="string">"https://customlink.com"</span></div><div class="line">    	},</div><div class="line"></div><div class="line">        <span class="comment">// Sharing links</span></div><div class="line">        <span class="string">"sharing"</span>: {</div><div class="line">            <span class="string">"google"</span>: <span class="literal">null</span>,</div><div class="line">            <span class="string">"facebook"</span>: <span class="literal">null</span>,</div><div class="line">            <span class="string">"twitter"</span>: <span class="literal">null</span>,</div><div class="line">            <span class="string">"weibo"</span>: <span class="literal">null</span>,</div><div class="line">            <span class="string">"all"</span>: <span class="literal">null</span></div><div class="line">        }</div><div class="line">    },</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// PDF 参数</span></div><div class="line">    <span class="string">"pdf"</span>: {</div><div class="line">        <span class="comment">// Add toc at the end of the file</span></div><div class="line">        <span class="string">"toc"</span>: <span class="literal">true</span>,</div><div class="line"></div><div class="line">        <span class="comment">// Add page numbers to the bottom of every page</span></div><div class="line">        <span class="string">"pageNumbers"</span>: <span class="literal">false</span>,</div><div class="line"></div><div class="line">        <span class="comment">// Font size for the fiel content</span></div><div class="line">        <span class="string">"fontSize"</span>: <span class="number">12</span>,</div><div class="line"></div><div class="line">        <span class="comment">// Paper size for the pdf</span></div><div class="line">        <span class="comment">// Choices are [u’a0’, u’a1’, u’a2’, u’a3’, u’a4’, u’a5’, u’a6’, u’b0’, u’b1’, u’b2’, u’b3’, u’b4’, u’b5’, u’b6’, u’legal’, u’letter’]</span></div><div class="line">        <span class="string">"paperSize"</span>: <span class="string">"a4"</span>,</div><div class="line"></div><div class="line">        <span class="comment">// Margin (in pts)</span></div><div class="line">        <span class="comment">// Note: 72 pts equals 1 inch</span></div><div class="line">        <span class="string">"margin"</span>: {</div><div class="line">            <span class="string">"right"</span>: <span class="number">62</span>,</div><div class="line">            <span class="string">"left"</span>: <span class="number">62</span>,</div><div class="line">            <span class="string">"top"</span>: <span class="number">36</span>,</div><div class="line">            <span class="string">"bottom"</span>: <span class="number">36</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="输出格式">输出格式</h2>
<p>GitBook可以产生下列类型的图书:</p>
<ul>
<li><strong>静态站点</strong>: 默认格式. 创建一个完全交互式的静态网站，可以发布到GitHub Pages等网站.</li>
<li><strong>eBook</strong>: 图书完成后可以使用它创建电子书. 创建命令: <code>gitbook ebook ./myrepo</code>. 你需要安装 <a href="http://manual.calibre-ebook.com/cli/ebook-convert.html" target="_blank" rel="external">ebook-convert</a>. 输出格式可以是 <strong>PDF</strong>, <strong>ePub</strong> 或 <strong>MOBI</strong>.</li>
<li><strong>单页网页</strong>: 可以生成一个单页的HTML网页。这个格式可以用来转换PDF或者eBook. 创建命令: <code>gitbook build ./myrepo -f page</code>.</li>
<li><strong>JSON</strong>: 此格式用来调试或者抽取图书的元数据. 创建命令: <code>gitbook build ./myrepo -f json</code>.</li>
</ul>
<h2 id="图书格式">图书格式</h2>
<p>一本图书就是一个Git repository， 至少包含两个文件: <code>README.md</code> 和 <code>SUMMARY.md</code>.</p>
<h4 id="README-md">README.md</h4>
<p>典型的, 它应该是你的图书的介绍. 它可以自动的被加到最终的summary中.</p>
<h4 id="SUMMARY-md">SUMMARY.md</h4>
<p><code>SUMMARY.md</code> 定义了你的图书的结构. 它应该包含章节的列表,以及它们的链接.</p>
<p>例如:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="header"># Summary</span></div><div class="line"></div><div class="line">This is the summary of my book.</div><div class="line"></div><div class="line"><span class="bullet">* </span>[<span class="link_label">section 1</span>](<span class="link_url">section1/README.md</span>)</div><div class="line"><span class="code">    * [example 1](section1/example1.md)</span></div><div class="line"><span class="code">    * [example 2](section1/example2.md)</span></div><div class="line"><span class="bullet">* </span>[<span class="link_label">section 2</span>](<span class="link_url">section2/README.md</span>)</div><div class="line"><span class="code">    * [example 1](section2/example1.md)</span></div></pre></td></tr></table></figure>

<p>不被<code>SUMMARY.md</code>包含的文件不会被<code>gitbook</code>处理.</p>
<h4 id="多语言">多语言</h4>
<p>GitBook 支持使用多种语言编写图书. 每种语言应该是一个子目录， 遵循正常gitbook格式, <code>LANGS.md</code>文件应该被放到repository的根文件夹， 格式如下:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>[<span class="link_label">English</span>](<span class="link_url">en/</span>)</div><div class="line"><span class="bullet">* </span>[<span class="link_label">French</span>](<span class="link_url">fr/</span>)</div><div class="line"><span class="bullet">* </span>[<span class="link_label">Español</span>](<span class="link_url">es/</span>)</div></pre></td></tr></table></figure>

<p>看个例子 <a href="https://github.com/GitbookIO/git" target="_blank" rel="external">学习 Git</a>.</p>
<h4 id="词汇表">词汇表</h4>
<p>允许你列出条目以及它们的定义. 基于这些条目 <code>gitbook</code>会自动创建一个索引，并在页面中加亮这些条目.</p>
<p><code>GLOSSARY.md</code> 格式很简单 :</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="header"># term</span></div><div class="line">Definition for this term</div><div class="line"></div><div class="line"><span class="header"># Another term</span></div><div class="line">With it's definition, this can contain bold text and all other kinds of inline markup ...</div></pre></td></tr></table></figure>

<h4 id="忽略文件和文件夹">忽略文件和文件夹</h4>
<p>GitBook 读取<code>.gitignore</code>, <code>.bookignore</code> 和 <code>.ignore</code> 得到需要忽略的文件/文件夹的列表. (文件的格式和 <code>.gitignore</code>一样).</p>
<p> <code>.gitignore</code>最佳实践是忽略build文件，这些文件来自 <a href="https://github.com/github/gitignore/blob/master/Node.gitignore" target="_blank" rel="external"><strong>node.js</strong></a> (<code>node_modules</code>, …) 和GitBook的build文件: <code>_book</code>, <code>*.epub</code>, <code>*.mobi</code> and <code>*.pdf</code>.</p>
<h4 id="封面">封面</h4>
<p>封面文件为: <strong>/cover.jpg</strong>.<br>尺寸为 <strong>1800x2360</strong>. 插件 <a href="https://github.com/GitbookIO/plugin-autocover" target="_blank" rel="external">autocover</a>可以自动创建一个文件.</p>
<p>封面的小尺寸图形为: <strong>/cover_small.jpg</strong>.</p>
<h4 id="发布图书">发布图书</h4>
<p>平台 <a href="https://www.gitbook.io/" target="_blank" rel="external">GitBook.io</a>就像”Heroku for books”: 你可以在它上面创建图书 (公开的, 付费的, 或者私有的)， 并且使用 <strong>git push</strong> 就可以更新.</p>
<h4 id="插件">插件</h4>
<p>P插件可以扩展图书的功能. 查看插件介绍 <a href="https://github.com/GitbookIO/plugin" target="_blank" rel="external">GitbookIO/plugin</a>来了解如何创建一个插件.</p>
<h5 id="官方插件:">官方插件:</h5>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-exercises" target="_blank" rel="external">exercises</a></td>
<td>Add interactive exercises to your book.</td>
</tr>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-quizzes" target="_blank" rel="external">quizzes</a></td>
<td>Add interactive quizzes to your book.</td>
</tr>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-mathjax" target="_blank" rel="external">mathjax</a></td>
<td>Displays mathematical notation in the book.</td>
</tr>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-mixpanel" target="_blank" rel="external">mixpanel</a></td>
<td>Mixpanel tracking for your book</td>
</tr>
</tbody>
</table>
<h5 id="其它插件:">其它插件:</h5>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-ga" target="_blank" rel="external">Google Analytics</a></td>
<td>Google Analytics tracking for your book</td>
</tr>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-disqus" target="_blank" rel="external">Disqus</a></td>
<td>Disqus comments integration in your book</td>
</tr>
<tr>
<td><a href="https://github.com/GitbookIO/plugin-autocover" target="_blank" rel="external">Autocover</a></td>
<td>Generate a cover for your book</td>
</tr>
<tr>
<td><a href="https://github.com/erixtekila/gitbook-plugin-richquotes" target="_blank" rel="external">Transform annoted quotes to notes</a></td>
<td>Allow extra markdown markup to render blockquotes as nice notes</td>
</tr>
<tr>
<td><a href="https://github.com/erixtekila/gitbook-plugin-toconsole" target="_blank" rel="external">Send code to console</a></td>
<td>Evaluate javascript block in the browser inspector’s console</td>
</tr>
<tr>
<td><a href="https://github.com/mrpotes/gitbook-plugin-reveal" target="_blank" rel="external">Revealable sections</a></td>
<td>Reveal sections of the page using buttons made from the first title in each section</td>
</tr>
<tr>
<td><a href="https://github.com/mrpotes/gitbook-plugin-nestedmd" target="_blank" rel="external">Markdown within HTML</a></td>
<td>Process markdown within HTML blocks - allows custom layout options for individual pages</td>
</tr>
<tr>
<td><a href="https://github.com/mrpotes/gitbook-plugin-bootstrapjs" target="_blank" rel="external">Bootstrap JavaScript plugins</a></td>
<td>Use the <a href="http://getbootstrap.com/javascript" target="_blank" rel="external">Bootstrap JavaScript plugins</a> in your online GitBook</td>
</tr>
<tr>
<td><a href="https://github.com/emmanuel-keller/gitbook-plugin-piwik" target="_blank" rel="external">Piwik Open Analytics</a></td>
<td>Piwik Open Analytics tracking for your book</td>
</tr>
<tr>
<td><a href="https://github.com/rlmv/gitbook-plugin-anchors" target="_blank" rel="external">Heading Anchors</a></td>
<td>Add linkable Github-style anchors to headings</td>
</tr>
<tr>
<td><a href="https://github.com/jcouyang/gitbook-plugin-jsbin" target="_blank" rel="external">JSBin</a></td>
<td>Embedded jsbin frame into your book</td>
</tr>
</tbody>
</table>
<h4 id="调试">调试</h4>
<p>增加环境变量 <code>DEBUG=true</code> 来得到更好的错误信息(包含错误堆栈). 例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>export <span class="constant">DEBUG</span>=<span class="keyword">true</span></div><div class="line"><span class="variable">$ </span>gitbook build ./</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>Gitbook是一个命令行工具(node.js库)， 使用Github/Git创建漂亮的图书。 你可以看一些用它编写的图书的例子： <a href="https://www.gitbook.io/book/GitBookIO/javascript" target="_blank" rel="external">学习Javascript</a>. 你也可以很容易的通过<a href="https://www.gitbook.io" target="_blank" rel="external">gitbook.io</a>网站发布在线图书。 <a href="https://github.com/GitbookIO/editor" target="_blank" rel="external">editor</a> 是一个图形化的编辑工具， 提供Windows, Mac 和Linux的版本. 关注Twitter帐号 <a href="https://twitter.com/GitBookIO" target="_blank" rel="external">@GitBookIO</a>. 这篇文章只是一个起步教程， 完整的文档可以在<a href="http://help.gitbook.io/" target="_blank" rel="external">help.gitbook.io</a>网站找到.<br>]]></summary>
    
      <category term="gitbook" scheme="http://colobu.com/tags/gitbook/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用FastJson作为JAX-RS的序列化/反序列化框架]]></title>
    <link href="http://colobu.com/2014/09/30/using-fastjson-as-JAX-RS-data-binding/"/>
    <id>http://colobu.com/2014/09/30/using-fastjson-as-JAX-RS-data-binding/</id>
    <published>2014-09-30T05:37:30.000Z</published>
    <updated>2014-09-30T23:12:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="external">FastJson</a>是阿里巴巴的<a href="https://github.com/wenshao" target="_blank" rel="external">温少</a>开发的一个JSON的序列化和反序列化的框架。 我前面的文章: <a href="http://colobu.com/2014/08/26/java-serializer-comparison/" target="_blank" rel="external">Java序列化框架性能比较</a>中也提到， 我使用第三方的序列化测试框架<a href="https://github.com/eishay/jvm-serializers" target="_blank" rel="external">jvm-serializers</a>表明， FastJson是最快的JSON序列化框架之一， 优于Jackson。</p>
<p><a href="https://jax-rs-spec.java.net/" target="_blank" rel="external">JAX-RS</a>是一个Java编程语言的应用程序接口,支持按照 表象化状态转变 (REST)架构风格创建Web服务Web服务. JAX-RS使用了Java SE 5引入的Java 标注来简化Web服务客户端和服务端的开发和部署。<br>JAX-RS的实现包括：</p>
<ul>
<li>Apache CXF，开源的Web服务框架。</li>
<li>Jersey， 由Sun提供的JAX-RS的参考实现。</li>
<li>RESTEasy，JBoss的实现。</li>
<li>Restlet，由Jerome Louvel和Dave Pawson开发，是最早的REST框架，先于JAX-RS出现。</li>
<li>Apache Wink，一个Apache软件基金会孵化器中的项目，其服务模块实现JAX-RS规范</li>
</ul>
<p>如果项目中使用JAX-RS传递JSON格式的数据， 可以利用FastJson提高序列化的性能。 但是FastJson并没有提供JAX-RS的集成（ <a href="https://github.com/alibaba/fastjson/issues/65" target="_blank" rel="external">Issue #65</a>, <a href="https://github.com/alibaba/fastjson/issues/138" target="_blank" rel="external">Issue #138</a> ）。</p>
<p>我实现了一个FastJson的JAX-RS集成框架： <a href="https://github.com/smallnest/fastjson-jaxrs-json-provider" target="_blank" rel="external">fastjson-jaxrs-json-provider
</a>,可以方便在在JAX-RS项目中使用。<br><a id="more"></a></p>
<h3 id="前言">前言</h3>
<p><code>FastJsonProvider</code> is a standard entity provider that follows JAX-RS 2.0 spec.<br>According to different JAX-RS implementations such as CXF, Jersey, maybe you use <code>FastJsonProvider</code> in appropriate styles.<br><code>FastJsonProvider</code> can serialize/deserialize specific types including:</p>
<ul>
<li>all types: <code>public FastJsonProvider()</code> (default constructor)</li>
<li>all type annotated with <code>FastJsonType</code>: <code>public FastJsonProvider(boolean annotated)</code></li>
<li>all type annotated in specific packages : <code>public FastJsonProvider(String[] scanpackages)</code></li>
<li>all type annotated in specific packages with <code>FastJsonType</code>: <code>public FastJsonProvider(String[] scanpackages, boolean annotated)</code></li>
<li>all type  in specific classes: <code>public FastJsonProvider(Class&lt;?&gt;[] clazzes)</code></li>
</ul>
<p>You can <code>init</code> this provider instance with a FastJsonConfig object which is used to configure FastJson features, SerializeConfig, ParserConfig and SerializeFilter. Any parameters can be null and will be default.</p>
<h4 id="Maven">Maven</h4>
<p><em>stable version: 0.1.0</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.colobu<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>fastjson-jaxrs-json-provider<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div></pre></td></tr></table></figure>

<p><em>snapshot version: 0.2.0-0.2.0-SNAPSHOT</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.colobu<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>fastjson-jaxrs-json-provider<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>0.2.0-SNAPSHOT<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="Jersey_configuration">Jersey configuration</h3>
<p>Please check the test and maybe you need to create a FastJsonFeature to override MessageBodyReader and MessageBodyWriter.</p>
<h3 id="CXF_confguration">CXF confguration</h3>
<p>You can use JAXRSServerFactoryBean.setProviders to add a <code>FastJsonProvider</code> instance.</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="external">FastJson</a>是阿里巴巴的<a href="https://github.com/wenshao" target="_blank" rel="external">温少</a>开发的一个JSON的序列化和反序列化的框架。 我前面的文章: <a href="http://colobu.com/2014/08/26/java-serializer-comparison/" target="_blank" rel="external">Java序列化框架性能比较</a>中也提到， 我使用第三方的序列化测试框架<a href="https://github.com/eishay/jvm-serializers" target="_blank" rel="external">jvm-serializers</a>表明， FastJson是最快的JSON序列化框架之一， 优于Jackson。</p>
<p><a href="https://jax-rs-spec.java.net/" target="_blank" rel="external">JAX-RS</a>是一个Java编程语言的应用程序接口,支持按照 表象化状态转变 (REST)架构风格创建Web服务Web服务. JAX-RS使用了Java SE 5引入的Java 标注来简化Web服务客户端和服务端的开发和部署。<br>JAX-RS的实现包括：</p>
<ul>
<li>Apache CXF，开源的Web服务框架。</li>
<li>Jersey， 由Sun提供的JAX-RS的参考实现。</li>
<li>RESTEasy，JBoss的实现。</li>
<li>Restlet，由Jerome Louvel和Dave Pawson开发，是最早的REST框架，先于JAX-RS出现。</li>
<li>Apache Wink，一个Apache软件基金会孵化器中的项目，其服务模块实现JAX-RS规范</li>
</ul>
<p>如果项目中使用JAX-RS传递JSON格式的数据， 可以利用FastJson提高序列化的性能。 但是FastJson并没有提供JAX-RS的集成（ <a href="https://github.com/alibaba/fastjson/issues/65" target="_blank" rel="external">Issue #65</a>, <a href="https://github.com/alibaba/fastjson/issues/138" target="_blank" rel="external">Issue #138</a> ）。</p>
<p>我实现了一个FastJson的JAX-RS集成框架： <a href="https://github.com/smallnest/fastjson-jaxrs-json-provider" target="_blank" rel="external">fastjson-jaxrs-json-provider
</a>,可以方便在在JAX-RS项目中使用。<br>]]></summary>
    
      <category term="FastJson" scheme="http://colobu.com/tags/FastJson/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[发布开源项目到Maven Central]]></title>
    <link href="http://colobu.com/2014/09/30/deploy-a-project-to-maven-central/"/>
    <id>http://colobu.com/2014/09/30/deploy-a-project-to-maven-central/</id>
    <published>2014-09-30T05:20:31.000Z</published>
    <updated>2014-10-01T22:56:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近准备将新开发的一个项目<a href="https://github.com/smallnest/fastjson-jaxrs-json-provider/blob/master/LICENSE" target="_blank" rel="external">fastjson-jaxrs-json-provider</a>发布的Maven central repository中（sonatype respository）, 这样其它人可以方便的下载编译好的库使用。 具体步骤可以参考<a href="http://central.sonatype.org/pages/ossrh-guide.html" target="_blank" rel="external">官方文档</a>。</p>
<p>搜索了一下，发现阿里的王福强的一篇文档介绍的很详细，特此转载记录以下。<br><a id="more"></a><br>原文地址： <a href="http://afoo.me/posts/2013-07-18-publishing-oss-release-to-maven-central-repo.html" target="_blank" rel="external">发布开源项目到Maven Central</a></p>
<p>过程比较繁琐曲折，其实按照官方文档一步一步做，大部分情况下是可以搞定的， 不过，为了方便后面查阅，简单整理为此文档。</p>
<h1 id="总体路线概述">总体路线概述</h1>
<p>直接发布到central repo其实是不行的，所以，其实我们是发布到sonatype的repository， 然后sonatype的repository会定期把我们的artifacts同步到maven的central repo中。</p>
<p>基本上，如果我们的项目是第一次发布到sonatype，那么需要申请一个账号，并提交New Project的Ticket等待审批，审批之后，就可以开始准备发布项目所需的各项要求了。当然，因为Ticket审批需要2个工作日，那么，其实可以在这段时间就把准备工作做掉。</p>
<p>初次发布，POM文件需要规范为sonatype要求的格式，该添加的element还是要添加一下，另外， 因为需要对要发布的artifacts做签名，也需要安装一下GnuPGP，并将public key上传到指定的key server上去(hkp://pool.sks-keyservers.net)， 并在.m2/settings.xml中添加相应的passphrase配置。</p>
<p>所有这些事儿搞定之后，就可以执行命令开始发布， 总体流程大体如此。</p>
<h1 id="申请账号并提交Ticket">申请账号并提交Ticket</h1>
<p>这一步没啥难度，参考官方文档的说明即可：</p>
<ol>
<li>到<a href="https://issues.sonatype.org/申请账号" target="_blank" rel="external">https://issues.sonatype.org/申请账号</a></li>
<li>到通过’+Create Issue’创建新的Ticket， 类型为New Project, 其它信息按照人家要求填写就行了<br>Ticket提交完了就等着就好了，人家说了要2个工作日才能审批完成，运气好估计会快点儿吧， 偶第一次因为SB网速，提交了2个相同的Ticket…</li>
</ol>
<h1 id="规范POM">规范POM</h1>
<p>这些element人家说了，必须要：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">modelVersion</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">packaging</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">url</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">licenses</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">scm</span>&gt;</span><span class="tag">&lt;<span class="title">url</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">scm</span>&gt;</span><span class="tag">&lt;<span class="title">connection</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">developers</span>&gt;</span></div></pre></td></tr></table></figure>

<p>另外， 除了二进制jar包，相对应的-sources.jar和-javadoc.jar也是必须的，所有这些jar以及pom.xml都需要通过PGP签名，所以，我们需要在pom.xml里添加相应的maven插件来帮助我们搞定这些：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">charset</span>&gt;</span>${file_encoding}<span class="tag">&lt;/<span class="title">charset</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">encoding</span>&gt;</span>${file_encoding}<span class="tag">&lt;/<span class="title">encoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div></pre></td></tr></table></figure>

<p>我们不想任何时候都做pgp签名，这样会比较耗费时间，一般只是在发布的时候才执行pgp前面，所以，我们将maven的pgp插件放入pom.xml里单独的一个profile中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">profiles</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">profile</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">id</span>&gt;</span>release-sign-artifacts<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">activation</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">property</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="title">name</span>&gt;</span>performRelease<span class="tag">&lt;/<span class="title">name</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="title">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">activation</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">build</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-gpg-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="title">executions</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="title">id</span>&gt;</span>sign-artifacts<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="title">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></div><div class="line">                                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>sign<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">profile</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">profiles</span>&gt;</span></div></pre></td></tr></table></figure>

<p>除此之外， 我们的pom应该继承自sonatype oss:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">parent</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.sonatype.oss<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>oss-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>7<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">parent</span>&gt;</span></div></pre></td></tr></table></figure>

<p>并且，有关SCM的信息需要严格填写， maven将在发布的时候自动checkout并打标发布。</p>
<h1 id="配置PGP">配置PGP</h1>
<p>如果发布机上没有安装，需要安装一下， 俺本地因为是mac，所以直接下了pgptools，一键安装， very easy～</p>
<p>安装后，创建一个pgp key，并发布到指定的key server - <code>hkp://pool.sks-keyservers.net</code>， 因为pgptools默认是发布到gnu的key server，所以，需要在PGP Keychain Access.app的Preferences里将key server选择为hkp://pool.sks-keyservers.net</p>
<p>所有这些搞定之后，在~/.m2/settings.xml中添加：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">settings</span>&gt;</span></div><div class="line">  ...</div><div class="line">  <span class="tag">&lt;<span class="title">servers</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">server</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">id</span>&gt;</span>sonatype-nexus-snapshots<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">username</span>&gt;</span>your-jira-id<span class="tag">&lt;/<span class="title">username</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">password</span>&gt;</span>your-jira-pwd<span class="tag">&lt;/<span class="title">password</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">server</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">server</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">id</span>&gt;</span>sonatype-nexus-staging<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">username</span>&gt;</span>your-jira-id<span class="tag">&lt;/<span class="title">username</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">password</span>&gt;</span>your-jira-pwd<span class="tag">&lt;/<span class="title">password</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">server</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">servers</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="title">settings</span>&gt;</span></div></pre></td></tr></table></figure>

<p>用户名和密码在一开始已经申请过了，填上即可。</p>
<p>更详细步骤参看 <a href="https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven" target="_blank" rel="external">https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven</a></p>
<h1 id="发布SNAPSHOT版本">发布SNAPSHOT版本</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>mvn clean deploy</div></pre></td></tr></table></figure>

<h1 id="发布Staging版本">发布Staging版本</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mvn <span class="operator"><span class="keyword">release</span>:clean</span></div><div class="line">$ mvn <span class="keyword">release</span>:<span class="keyword">prepare</span></div><div class="line">$ mvn <span class="keyword">release</span>:perform</div></pre></td></tr></table></figure>

<p>期间会提示需要输入pgp key的passphrase，照办就是了。<br>哥的Ticket当天没批下来，所以，运行会告诉我没有权限上传artifacts: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ERROR] Failed to <span class="operator"><span class="keyword">execute</span> goal org.apache.maven.plugins:maven-deploy-<span class="keyword">plugin</span>:<span class="number">2.5</span>:deploy (<span class="keyword">default</span>-deploy) <span class="keyword">on</span> project cobar-client: </span></div><div class="line">Failed <span class="keyword">to</span> deploy artifacts: Could <span class="keyword">not</span> transfer artifact com.alibaba.cobar:cobar-client:jar:<span class="number">1.0</span><span class="number">.5</span> <span class="keyword">from</span>/<span class="keyword">to</span> </div><div class="line">sonatype-nexus-staging (https://oss.sonatype.org/service/<span class="keyword">local</span>/staging/deploy/maven2/): </div><div class="line">Access denied <span class="keyword">to</span>: https://oss.sonatype.org/service/<span class="keyword">local</span>/staging/deploy/maven2/com/alibaba/cobar/cobar-client/<span class="number">1.0</span><span class="number">.5</span>/cobar-client-<span class="number">1.0</span><span class="number">.5</span>.jar -&gt; [<span class="keyword">Help</span> <span class="number">1</span>]</div></pre></td></tr></table></figure>

<p>没办法，等吧～</p>
<h1 id="正式发布">正式发布</h1>
<p>访问web地址： <a href="https://oss.sonatype.org/" target="_blank" rel="external">https://oss.sonatype.org/</a></p>
<p>登陆， 选择左边栏里的”Staging Repositories”, 然后点Close按钮，sonatype会做响应的validation，通过的话，就可以点Release发布啦，如果不通过，或者人工检查有问题，就先Drop，并重新做Staging发布， 知道搞定之后，再行发布。 没Release之前随便搞， Release之后就板上钉钉了。</p>
<h1 id="总结">总结</h1>
<p>第一次搞需要拢的东西比较多，而且很久没搞Maven了(俺现在搞SBT比较多，u know的)， 所以，搞的期间偶尔出点儿小问题刺挠刺挠我，都是小事儿，总体上来讲， 官方文档还是比较靠谱的。</p>
<h1 id="参考资料">参考资料</h1>
<ol>
<li><a href="http://central.sonatype.org/pages/ossrh-guide.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://datumedge.blogspot.com/2012/05/publishing-from-github-to-maven-central.html" target="_blank" rel="external">http://datumedge.blogspot.com/2012/05/publishing-from-github-to-maven-central.html</a></li>
<li><a href="https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven" target="_blank" rel="external">https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven</a></li>
</ol>
<hr>
<p>第一次发布有些周折， 请参看另外一篇文章: <a href="http://www.trinea.cn/dev-tools/upload-java-jar-or-android-aar-to-maven-center-repository/" target="_blank" rel="external">上传Android或Java库到Maven central repository</a>:</p>
<p>前面的步骤都一样， 下面转载后面几个章节。</p>
<h1 id="编译上传">编译上传</h1>
<h2 id="(1)_发布一个snapshot版本发布一个snapshot版本">(1) 发布一个snapshot版本发布一个snapshot版本</h2>
<p><code>mvn clean deploy</code><br>发布完成后登陆<a href="https://oss.sonatype.org" target="_blank" rel="external">https://oss.sonatype.org</a> (<a href="https://issues.sonatype.org/" target="_blank" rel="external">https://issues.sonatype.org/</a> 上的用户名和密码)，通过下图步骤找到自己的Artifact(上传的jar或aar或pom等)</p>
<p><img src="https://farm8.staticflickr.com/7326/13974246558_7738361c05_o.jpg" alt=""></p>
<h2 id="(2)_发布一个release版本">(2) 发布一个release版本</h2>
<p><code>mvn release:clean release:prepare release:perform</code></p>
<p>过程中需要通过GPG签名，需要输入上面的passphase。发布完成后我们依然可以通过类似上图步骤找到我们的Artifact</p>
<p>其他上传方式见<a href="https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-7a.3.StageaRelease" target="_blank" rel="external">Stage a Release</a></p>
<h1 id="正式发布-1">正式发布</h1>
<p>这里的正式发布是指同步到Maven主仓库使得其他人可以使用。主要包括Close和Release两步，先Close后Release，分别如下图<br><img src="https://docs.sonatype.org/download/attachments/6619276/staging_close.png?version=1&amp;modificationDate=1279720013166" alt=""><br><img src="https://docs.sonatype.org/download/attachments/6619284/staging_release.png?version=1&amp;modificationDate=1279720544670" alt=""></p>
<p>其他不明白可以查看：<a href="https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8a.ReleaseIt" target="_blank" rel="external">Release</a></p>
<p>需要注意</p>
<p><strong>(1) 在release时可能会出现</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Release failed</div><div class="line">Nexus returned an <span class="keyword">error</span>: <span class="keyword">ERROR</span> <span class="number">403</span>: Forbidden</div></pre></td></tr></table></figure>

<p>的403弹窗，这可能是因为在2中创建的JIRA ticket，状态还没有变为 <code>resolved</code>，等待可用即可。如果上面截图中你的Repository列表中Profile列的值不是你在创建JIRA ticket时的Group Id需要重新提交。</p>
<p>(2) 如果是第一次release，需要到之前你的JIRA ticket下，评论下告诉他们，你已经release了，需要同步下，我的JIRA ticket: OSSRH-9800.  如下图：<br><img src="https://farm8.staticflickr.com/7453/14197792294_0afd471357_o.jpg" alt=""></p>
]]></content>
    <summary type="html"><![CDATA[<p>最近准备将新开发的一个项目<a href="https://github.com/smallnest/fastjson-jaxrs-json-provider/blob/master/LICENSE" target="_blank" rel="external">fastjson-jaxrs-json-provider</a>发布的Maven central repository中（sonatype respository）, 这样其它人可以方便的下载编译好的库使用。 具体步骤可以参考<a href="http://central.sonatype.org/pages/ossrh-guide.html" target="_blank" rel="external">官方文档</a>。</p>
<p>搜索了一下，发现阿里的王福强的一篇文档介绍的很详细，特此转载记录以下。<br>]]></summary>
    
      <category term="Maven" scheme="http://colobu.com/tags/Maven/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZooKeeper程序员指南]]></title>
    <link href="http://colobu.com/2014/09/28/ZooKeeper-Programmers-Guide/"/>
    <id>http://colobu.com/2014/09/28/ZooKeeper-Programmers-Guide/</id>
    <published>2014-09-28T02:06:08.000Z</published>
    <updated>2014-09-28T04:21:55.000Z</updated>
    <content type="html"><![CDATA[<p>翻译于最新的<a href="http://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html" target="_blank" rel="external">ZooKeeper 3.4 文档</a>。</p>
<h1 id="前言">前言</h1>
<p>本文档是为那些希望利用ZooKeeper的协调服务建立分布式应用程序的开发人员而写的指南。它包含了Zookeeper的概念和实践内容。<br>指南的前四节介绍了ZooKeeper各种概念的高层次的讨论。 对于理解ZooKeeper如何工作和如何使用它这些概念都是必须了解的。尽管不包含代码，但还是假定你熟悉分布式计算相关的问题。<br>第一组的章节包括：</p>
<ul>
<li>ZooKeeper数据模型： The ZooKeeper Data Model</li>
<li>ZooKeeper的会话： ZooKeeper Sessions</li>
<li>ZooKeeper的监视： ZooKeeper Watches</li>
<li>一致性保证：Consistency Guarantees<br><em>(下面的翻译中概念尽量不翻译成中文，因为英文更能直观的反映其概念)</em></li>
</ul>
<p>接下来的四个章节提供了编程实践信息，它们是:</p>
<ul>
<li>Building Blocks: A Guide to ZooKeeper Operations</li>
<li>Bindings</li>
<li>Program Structure, with Simple Example [tbd]</li>
<li>Gotchas: Common Problems and Troubleshooting</li>
</ul>
<p>附录中的链接是其它的有用的,和ZooKeeper相关的信息.<br>书中的章节都可以独立阅读，然而在开发你的第一个ZooKeeper程序之前， 你最好先阅读一下ZooKeeper数据模型和ZooKeeper基本操作。Simple Programmming Example对于理解ZooKeeper客户端程序的基本结构也很有帮助.<br><a id="more"></a></p>
<h1 id="ZooKeeper数据模型：_The_ZooKeeper_Data_Model">ZooKeeper数据模型： The ZooKeeper Data Model</h1>
<p>ZooKeeper包含一个分层次的命名空间，很像分布式的文件系统. 唯一的不同是除了包含子节点外命名空间的每个节点还可以关联数据. 就像一个扩展的文件系统一样， 文件也可以是目录. 节点的路径(path)总是规范的斜线分隔的绝对路径;绝没有相对路径. 任意的unicode字符都可以做路径名， 除了以下的限制：:</p>
<ul>
<li>空字符(\u0000)不能做路径名的一部分. (主要考虑C语言)</li>
<li>以下字符不能使用。 因为它们不能显示或不易显示: \u0001 - \u001F and \u007F - \u009F.</li>
<li>以下字符也不可以: \ud800 - uF8FF, \uFFF0 - uFFFF.</li>
<li>“.” 字符可以作为路径名的一部分，但是 “.” 和 “..” 不能单独做路径名， 因为ZooKeeper不使用相对路径。 后面这几个路径都是非法的: “/a/b/./c” or “/a/b/../c”.</li>
<li>“zookeeper” 是保留关键字.</li>
</ul>
<h2 id="ZNode节点">ZNode节点</h2>
<p>ZooKeeper树中的每一个节点都被成<code>znode</code>. Znode维护一个stat数据结构， 包含数据变动的版本值， acl变动等(version numbers for data changes, acl changes)。 stat数据结构还包含时间戳(timestamp)。 版本和时间戳可以允许ZooKeeper校验缓存和协同更新。每次znode的数据改变，版本号都会增加。例如，无论何时一个节点获取数据时， 它都会得到数据的版本。 当节点执行更新或者删除操作时， 它必须提供它要改变的znode数据的版本。假如它提供的版本和数据的实际版本不一致，更新失败。 (这个行为可以被覆盖overriden,更多的信息请参考 [tbd…])</p>
<blockquote>
<p><strong>Note</strong>: 在分布式应用工程学上，单词<code>node</code> 可以指一个通用的主机，服务器， 集群中的一员， 一个客户端进程等。 而在ZooKeeper文档中，<code>znode</code>指数据节点，<code>Server</code>指提供ZooKeeper服务器的机器; <code>quorum peers</code> 指ZooKeeper集群中的服务器; <code>client</code> 指任何使用ZooKeeper的主机或者进程.</p>
</blockquote>
<p>Znode是程序访问的主要对象. 它们有以下几个特征值得一说.</p>
<h3 id="监视Watches">监视Watches</h3>
<p>Clients can set watches on znodes. Changes to that znode trigger the watch and then clear the<br>watch. When a watch triggers, ZooKeeper sends the client a notification. More information<br>about watches can be found in the section ZooKeeper Watches.</p>
<h3 id="数据访问Data_Access">数据访问Data Access</h3>
<p>The data stored at each znode in a namespace is read and written atomically. Reads get all the<br>data bytes associated with a znode and a write replaces all the data. Each node has an Access<br>Control List (ACL) that restricts who can do what.<br>ZooKeeper was not designed to be a general database or large object store. Instead,<br>it manages coordination data. This data can come in the form of configuration, status<br>information, rendezvous, etc. A common property of the various forms of coordination data<br>is that they are relatively small: measured in kilobytes. The ZooKeeper client and the server<br>implementations have sanity checks to ensure that znodes have less than 1M of data, but the<br>data should be much less than that on average. Operating on relatively large data sizes will<br>cause some operations to take much more time than others and will affect the latencies of<br>some operations because of the extra time needed to move more data over the network and<br>onto storage media. If large data storage is needed, the usually pattern of dealing with such<br>data is to store it on a bulk storage system, such as NFS or HDFS, and store pointers to the<br>storage locations in ZooKeeper.</p>
<h3 id="临时节点Ephemeral_Nodes">临时节点Ephemeral Nodes</h3>
<p>ZooKeeper also has the notion of ephemeral nodes. These znodes exists as long as the<br>session that created the znode is active. When the session ends the znode is deleted. Because<br>of this behavior ephemeral znodes are not allowed to have children.</p>
<h3 id="顺序节点Sequence_Nodes_—_Unique_Naming">顺序节点Sequence Nodes — Unique Naming</h3>
<p>When creating a znode you can also request that ZooKeeper append a monotonically<br>increasing counter to the end of path. This counter is unique to the parent znode. The counter<br>has a format of %010d — that is 10 digits with 0 (zero) padding (the counter is formatted in<br>this way to simplify sorting), i.e. “<path>0000000001”. See Queue Recipefor an example<br>use of this feature. Note: the counter used to store the next sequence number is a signed int<br>(4bytes) maintained by the parent node, the counter will overflow when incremented beyond<br>2147483647 (resulting in a name “<path>-2147483647”).</p>
<h2 id="ZooKeeper中的时间">ZooKeeper中的时间</h2>
<p>ZooKeeper tracks time multiple ways:</p>
<ul>
<li><strong>Zxid</strong><br>Every change to the ZooKeeper state receives a stamp in the form of a zxid(ZooKeeper<br>Transaction Id). This exposes the total ordering of all changes to ZooKeeper. Each<br>change will have a unique zxid and if zxid1 is smaller than zxid2 then zxid1 happened<br>before zxid2.</li>
<li><strong>Version numbers</strong><br>Every change to a node will cause an increase to one of the version numbers of that<br>node. The three version numbers are version (number of changes to the data of a znode),<br>cversion (number of changes to the children of a znode), and aversion (number of<br>changes to the ACL of a znode).</li>
<li><strong>Ticks</strong><br>When using multi-server ZooKeeper, servers use ticks to define timing of events such as<br>status uploads, session timeouts, connection timeouts between peers, etc. The tick time is<br>only indirectly exposed through the minimum session timeout (2 times the tick time); if a client requests a session timeout less than the minimum session timeout, the server will<br>tell the client that the session timeout is actually the minimum session timeout.</li>
<li><strong>Real time</strong><br>ZooKeeper doesn’t use real time, or clock time, at all except to put timestamps into the<br>stat structure on znode creation and znode modification.</li>
</ul>
<h2 id="ZooKeeper_Stat数据结构">ZooKeeper Stat数据结构</h2>
<p>The Stat structure for each znode in ZooKeeper is made up of the following fields:</p>
<ul>
<li><strong>czxid</strong><br>The zxid of the change that caused this znode to be created.</li>
<li><strong>mzxid</strong><br>The zxid of the change that last modified this znode.</li>
<li><strong>ctime</strong><br>The time in milliseconds from epoch when this znode was created.</li>
<li><strong>mtime</strong><br>The time in milliseconds from epoch when this znode was last modified.</li>
<li><strong>version</strong><br>The number of changes to the data of this znode.</li>
<li><strong>cversion</strong><br>The number of changes to the children of this znode.</li>
<li><strong>aversion</strong><br>The number of changes to the ACL of this znode.</li>
<li><strong>ephemeralOwner</strong><br>The session id of the owner of this znode if the znode is an ephemeral node. If it is not an<br>ephemeral node, it will be zero.</li>
<li><strong>dataLength</strong><br>The length of the data field of this znode.</li>
<li><strong>numChildren</strong><br>The number of children of this znode.</li>
</ul>
<h1 id="ZooKeeper会话">ZooKeeper会话</h1>
<p>A ZooKeeper client establishes a session with the ZooKeeper service by creating a<br>handle to the service using a language binding. Once created, the handle starts of in the<br>CONNECTING state and the client library tries to connect to one of the servers that make<br>up the ZooKeeper service at which point it switches to the CONNECTED state. During normal operation will be in one of these two states. If an unrecoverable error occurs, such as<br>session expiration or authentication failure, or if the application explicitly closes the handle,<br>the handle will move to the CLOSED state. The following figure shows the possible state<br>transitions of a ZooKeeper client:<br><img src="http://zookeeper.apache.org/doc/trunk/images/state_dia.jpg" alt=""></p>
<p>To create a client session the application code must provide a connection string containing<br>a comma separated list of host:port pairs, each corresponding to a ZooKeeper server (e.g.<br>“127.0.0.1:4545” or “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002”). The ZooKeeper client<br>library will pick an arbitrary server and try to connect to it. If this connection fails, or if the<br>client becomes disconnected from the server for any reason, the client will automatically try<br>the next server in the list, until a connection is (re-)established.<br>Added in 3.2.0: An optional “chroot” suffix may also be appended to the connection string.<br>This will run the client commands while interpreting all paths relative to this root (similar to<br>the unix chroot command). If used the example would look like: “127.0.0.1:4545/app/a” or<br>“127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a” where the client would be rooted at “/<br>app/a” and all paths would be relative to this root - ie getting/setting/etc… “/foo/bar” would<br>result in operations being run on “/app/a/foo/bar” (from the server perspective). This feature<br>is particularly useful in multi-tenant environments where each user of a particular ZooKeeper<br>service could be rooted differently. This makes re-use much simpler as each user can code<br>his/her application as if it were rooted at “/“, while actual location (say /app/a) could be<br>determined at deployment time.<br>When a client gets a handle to the ZooKeeper service, ZooKeeper creates a ZooKeeper session, represented as a 64-bit number, that it assigns to the client. If the client connects to a different ZooKeeper server, it will send the session id as a part of the connection handshake. As a security measure, the server creates a password for the session id that any ZooKeeper server can validate.The password is sent to the client with the session id when the client establishes the session. The client sends this password with the session id whenever it reestablishes the session with a new server.</p>
<p>One of the parameters to the ZooKeeper client library call to create a ZooKeeper session is the session timeout in milliseconds. The client sends a requested timeout, the server responds with the timeout that it can give the client. The current implementation requires that the timeout be a minimum of 2 times the tickTime (as set in the server configuration) and a maximum of 20 times the tickTime. The ZooKeeper client API allows access to the negotiated timeout.</p>
<p>When a client (session) becomes partitioned from the ZK serving cluster it will begin searching the list of servers that were specified during session creation. Eventually, when connectivity between the client and at least one of the servers is re-established, the session will either again transition to the “connected” state (if reconnected within the session timeout value) or it will transition to the “expired” state (if reconnected after the session timeout). It is not advisable to create a new session object (a new ZooKeeper.class or zookeeper handle in the c binding) for disconnection. The ZK client library will handle reconnect for you. In particular we have heuristics built into the client library to handle things like “herd effect”, etc… Only create a new session when you are notified of session expiration (mandatory).</p>
<p>Session expiration is managed by the ZooKeeper cluster itself, not by the client. When the ZK client establishes a session with the cluster it provides a “timeout” value detailed above. This value is used by the cluster to determine when the client’s session expires. Expirations happens when the cluster does not hear from the client within the specified session timeout period (i.e. no heartbeat). At session expiration the cluster will delete any/all ephemeral nodes owned by that session and immediately notify any/all connected clients of the change (anyone watching those znodes). At this point the client of the expired session is still disconnected from the cluster, it will not be notified of the session expiration until/unless it is able to re-establish a connection to the cluster. The client will stay in disconnected state until the TCP connection is re-established with the cluster, at which point the watcher of the expired session will receive the “session expired” notification.</p>
<p>Example state transitions for an expired session as seen by the expired session’s watcher:</p>
<ol>
<li>‘connected’ : session is established and client is communicating with cluster (client/server communication is operating properly)</li>
<li>…. client is partitioned from the cluster</li>
<li>‘disconnected’ : client has lost connectivity with the cluster</li>
<li>…. time elapses, after ‘timeout’ period the cluster expires the session, nothing is seen by client as it is disconnected from cluster</li>
<li>…. time elapses, the client regains network level connectivity with the cluster</li>
<li>‘expired’ : eventually the client reconnects to the cluster, it is then notified of the expiration</li>
</ol>
<p>Another parameter to the ZooKeeper session establishment call is the default watcher. Watchers are notified when any state change occurs in the client. For example if the client loses connectivity to the server the client will be notified, or if the client’s session expires, etc… This watcher should consider the initial state to be disconnected (i.e. before any state changes events are sent to the watcher by the client lib). In the case of a new connection, the first event sent to the watcher is typically the session connection event.</p>
<p>The session is kept alive by requests sent by the client. If the session is idle for a period of time that would timeout the session, the client will send a PING request to keep the session alive. This PING request not only allows the ZooKeeper server to know that the client is still active, but it also allows the client to verify that its connection to the ZooKeeper server is still active. The timing of the PING is conservative enough to ensure reasonable time to detect a dead connection and reconnect to a new server.</p>
<p>Once a connection to the server is successfully established (connected) there are basically two cases where the client lib generates connectionloss (the result code in c binding, exception in Java — see the API documentation for binding specific details) when either a synchronous or asynchronous operation is performed and one of the following holds:</p>
<ol>
<li>The application calls an operation on a session that is no longer alive/valid</li>
<li>The ZooKeeper client disconnects from a server when there are pending operations to that server, i.e., there is a pending asynchronous call.</li>
</ol>
<p><strong>Added in 3.2.0 — SessionMovedException.</strong> There is an internal exception that is generally not seen by clients called the SessionMovedException. This exception occurs because a request was received on a connection for a session which has been reestablished on a different server. The normal cause of this error is a client that sends a request to a server, but the network packet gets delayed, so the client times out and connects to a new server. When the delayed packet arrives at the first server, the old server detects that the session has moved, and closes the client connection. Clients normally do not see this error since they do not read from those old connections. (Old connections are usually closed.) One situation in which this condition can be seen is when two clients try to reestablish the same connection using a saved session id and password. One of the clients will reestablish the connection and the second client will be disconnected (causing the pair to attempt to re-establish its connection/session indefinitely).</p>
<p><strong>Updating the list of servers.</strong> We allow a client to update the connection string by providing a new comma separated list of host:port pairs, each corresponding to a ZooKeeper server. The function invokes a probabilistic load-balancing algorithm which may cause the client to disconnect from its current host with the goal to achieve expected uniform number of connections per server in the new list. In case the current host to which the client is connected is not in the new list this call will always cause the connection to be dropped. Otherwise, the decision is based on whether the number of servers has increased or decreased and by how much.</p>
<p>For example, if the previous connection string contained 3 hosts and now the list contains these 3 hosts and 2 more hosts, 40% of clients connected to each of the 3 hosts will move to one of the new hosts in order to balance the load. The algorithm will cause the client to drop its connection to the current host to which it is connected with probability 0.4 and in this case cause the client to connect to one of the 2 new hosts, chosen at random.</p>
<p>Another example — suppose we have 5 hosts and now update the list to remove 2 of the hosts, the clients connected to the 3 remaining hosts will stay connected, whereas all clients connected to the 2 removed hosts will need to move to one of the 3 hosts, chosen at random. If the connection is dropped, the client moves to a special mode where he chooses a new server to connect to using the probabilistic algorithm, and not just round robin.</p>
<p>In the first example, each client decides to disconnect with probability 0.4 but once the decision is made, it will try to connect to a random new server and only if it cannot connect to any of the new servers will it try to connect to the old ones. After finding a server, or trying all servers in the new list and failing to connect, the client moves back to the normal mode of operation where it picks an arbitrary server from the connectString and attempt to connect to it. If that fails, is will continue trying different random servers in round robin. (see above the algorithm used to initially choose a server)</p>
<h1 id="ZooKeeper_Watches">ZooKeeper Watches</h1>
<p>All of the read operations in ZooKeeper - getData(), getChildren(), and exists() - have the option of setting a watch as a side effect. Here is ZooKeeper’s definition of a watch: a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes. There are three key points to consider in this definition of a watch:</p>
<ul>
<li><strong>One-time trigger</strong><br>One watch event will be sent to the client when the data has changed. For example, if a client does a getData(“/znode1”, true) and later the data for /znode1 is changed or deleted, the client will get a watch event for /znode1. If /znode1 changes again, no watch event will be sent unless the client has done another read that sets a new watch.</li>
<li><strong>Sent to the client</strong><br>This implies that an event is on the way to the client, but may not reach the client before the successful return code to the change operation reaches the client that initiated the change. Watches are sent asynchronously to watchers. ZooKeeper provides an ordering guarantee: a client will never see a change for which it has set a watch until it first sees the watch event. Network delays or other factors may cause different clients to see watches and return codes from updates at different times. The key point is that everything seen by the different clients will have a consistent order.</li>
<li><strong>The data for which the watch was set</strong><br>This refers to the different ways a node can change. It helps to think of ZooKeeper as maintaining two lists of watches: data watches and child watches. getData() and exists() set data watches. getChildren() sets child watches. Alternatively, it may help to think of watches being set according to the kind of data returned. getData() and exists() return information about the data of the node, whereas getChildren() returns a list of children. Thus, setData() will trigger data watches for the znode being set (assuming the set is successful). A successful create() will trigger a data watch for the znode being created and a child watch for the parent znode. A successful delete() will trigger both a data watch and a child watch (since there can be no more children) for a znode being deleted as well as a child watch for the parent znode.</li>
</ul>
<p>Watches are maintained locally at the ZooKeeper server to which the client is connected. This allows watches to be lightweight to set, maintain, and dispatch. When a client connects to a new server, the watch will be triggered for any session events. Watches will not be received while disconnected from a server. When a client reconnects, any previously registered watches will be reregistered and triggered if needed. In general this all occurs transparently. There is one case where a watch may be missed: a watch for the existence of a znode not yet created will be missed if the znode is created and deleted while disconnected.</p>
<h2 id="Semantics_of_Watches">Semantics of Watches</h2>
<p>We can set watches with the three calls that read the state of ZooKeeper: exists, getData, and getChildren. The following list details the events that a watch can trigger and the calls that enable them:</p>
<ul>
<li><strong>Created event</strong>:<br>Enabled with a call to exists.</li>
<li><strong>Deleted event</strong>:<br>Enabled with a call to exists, getData, and getChildren.</li>
<li><strong>Changed event</strong>:<br>Enabled with a call to exists and getData.</li>
<li><strong>Child event</strong>:<br>Enabled with a call to getChildren.</li>
</ul>
<h2 id="Remove_Watches">Remove Watches</h2>
<p>We can remove the watches registered on a znode with a call to removeWatches. Also, a ZooKeeper client can remove watches locally even if there is no server connection by setting the local flag to true. The following list details the events which will be triggered after the successful watch removal.</p>
<ul>
<li><strong>Child Remove event</strong>:<br>Watcher which was added with a call to getChildren.<br><strong>Data Remove event</strong>:<br>Watcher which was added with a call to exists or getData.</li>
</ul>
<h2 id="What_ZooKeeper_Guarantees_about_Watches">What ZooKeeper Guarantees about Watches</h2>
<p>With regard to watches, ZooKeeper maintains these guarantees:</p>
<ul>
<li>Watches are ordered with respect to other events, other watches, and asynchronous replies. The ZooKeeper client libraries ensures that everything is dispatched in order.</li>
<li>A client will see a watch event for a znode it is watching before seeing the new data that corresponds to that znode.</li>
<li>The order of watch events from ZooKeeper corresponds to the order of the updates as seen by the ZooKeeper service.</li>
</ul>
<h2 id="Things_to_Remember_about_Watches">Things to Remember about Watches</h2>
<ul>
<li>Watches are one time triggers; if you get a watch event and you want to get notified of future changes, you must set another watch.</li>
<li>Because watches are one time triggers and there is latency between getting the event and sending a new request to get a watch you cannot reliably see every change that happens to a node in ZooKeeper. Be prepared to handle the case where the znode changes multiple times between getting the event and setting the watch again. (You may not care, but at least realize it may happen.)</li>
<li>A watch object, or function/context pair, will only be triggered once for a given notification. For example, if the same watch object is registered for an exists and a getData call for the same file and that file is then deleted, the watch object would only be invoked once with the deletion notification for the file.</li>
<li>When you disconnect from a server (for example, when the server fails), you will not get any watches until the connection is reestablished. For this reason session events are sent to all outstanding watch handlers. Use session events to go into a safe mode: you will not be receiving events while disconnected, so your process should act conservatively in that mode.</li>
</ul>
<h1 id="ZooKeeper_access_control_using_ACLs">ZooKeeper access control using ACLs</h1>
<p>ZooKeeper uses ACLs to control access to its znodes (the data nodes of a ZooKeeper data tree). The ACL implementation is quite similar to UNIX file access permissions: it employs permission bits to allow/disallow various operations against a node and the scope to which the bits apply. Unlike standard UNIX permissions, a ZooKeeper node is not limited by the three standard scopes for user (owner of the file), group, and world (other). ZooKeeper does not have a notion of an owner of a znode. Instead, an ACL specifies sets of ids and permissions that are associated with those ids.</p>
<p>Note also that an ACL pertains only to a specific znode. In particular it does not apply to children. For example, if /app is only readable by ip:172.16.16.1 and /app/status is world readable, anyone will be able to read /app/status; ACLs are not recursive.</p>
<p>ZooKeeper supports pluggable authentication schemes. Ids are specified using the form scheme:id, where scheme is a the authentication scheme that the id corresponds to. For example, ip:172.16.16.1 is an id for a host with the address 172.16.16.1.</p>
<p>When a client connects to ZooKeeper and authenticates itself, ZooKeeper associates all the ids that correspond to a client with the clients connection. These ids are checked against the ACLs of znodes when a clients tries to access a node. ACLs are made up of pairs of (scheme:expression, perms). The format of the expression is specific to the scheme. For example, the pair (ip:19.22.0.0/16, READ) gives the READ permission to any clients with an IP address that starts with 19.22.</p>
<h2 id="ACL_Permissions">ACL Permissions</h2>
<p>ZooKeeper supports the following permissions:</p>
<ul>
<li><strong>CREATE</strong>: you can create a child node</li>
<li><strong>READ</strong>: you can get data from a node and list its children.</li>
<li><strong>WRITE</strong>: you can set data for a node</li>
<li><strong>DELETE</strong>: you can delete a child node</li>
<li><strong>ADMIN</strong>: you can set permissions</li>
</ul>
<p>The CREATE and DELETE permissions have been broken out of the WRITE permission for finer grained access controls. The cases for CREATE and DELETE are the following:</p>
<p>You want A to be able to do a set on a ZooKeeper node, but not be able to CREATE or DELETE children.</p>
<p>CREATE without DELETE: clients create requests by creating ZooKeeper nodes in a parent directory. You want all clients to be able to add, but only request processor can delete. (This is kind of like the APPEND permission for files.)</p>
<p>Also, the ADMIN permission is there since ZooKeeper doesn’t have a notion of file owner. In some sense the ADMIN permission designates the entity as the owner. ZooKeeper doesn’t support the LOOKUP permission (execute permission bit on directories to allow you to LOOKUP even though you can’t list the directory). Everyone implicitly has LOOKUP permission. This allows you to stat a node, but nothing more. (The problem is, if you want to call zoo_exists() on a node that doesn’t exist, there is no permission to check.)</p>
<h3 id="Builtin_ACL_Schemes">Builtin ACL Schemes</h3>
<p>ZooKeeeper has the following built in schemes:</p>
<ul>
<li><strong>world</strong> has a single id, anyone, that represents anyone.</li>
<li><strong>auth</strong> doesn’t use any id, represents any authenticated user.</li>
<li><strong>digest</strong> uses a username:password string to generate MD5 hash which is then used as an ACL ID identity. Authentication is done by sending the username:password in clear text. When used in the ACL the expression will be the username:base64 encoded SHA1 password digest.</li>
<li><strong>ip</strong> uses the client host IP as an ACL ID identity. The ACL expression is of the form addr/bits where the most significant bits of addr are matched against the most significant bits of the client host IP.</li>
</ul>
<h3 id="ZooKeeper_C_client_API">ZooKeeper C client API</h3>
<p>The following constants are provided by the ZooKeeper C library:</p>
<ul>
<li>const int ZOO_PERM_READ; //can read node’s value and list its children</li>
<li>const int ZOO_PERM_WRITE;// can set the node’s value</li>
<li>const int ZOO_PERM_CREATE; //can create children</li>
<li>const int ZOO_PERM_DELETE;// can delete children</li>
<li>const int ZOO_PERM_ADMIN; //can execute set_acl()</li>
<li>const int ZOO_PERM_ALL;// all of the above flags OR’d together</li>
</ul>
<p>The following are the standard ACL IDs:</p>
<ul>
<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>
<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>
</ul>
<p>ZOO_AUTH_IDS empty identity string should be interpreted as “the identity of the creator”.</p>
<p>ZooKeeper client comes with three standard ACLs:</p>
<ul>
<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>
<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>
<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>
</ul>
<p>The ZOO_OPEN_ACL_UNSAFE is completely open free for all ACL: any application can execute any operation on the node and can create, list and delete its children. The ZOO_READ_ACL_UNSAFE is read-only access for any application. CREATE_ALL_ACL grants all permissions to the creator of the node. The creator must have been authenticated by the server (for example, using “digest” scheme) before it can create nodes with this ACL.</p>
<p>The following ZooKeeper operations deal with ACLs:</p>
<ul>
<li>int zoo_add_auth (zhandle_t <em>zh,const char</em> scheme,const char<em> cert, int certLen, void_completion_t completion, const void </em>data);</li>
</ul>
<p>The application uses the zoo_add_auth function to authenticate itself to the server. The function can be called multiple times if the application wants to authenticate using different schemes and/or identities.</p>
<ul>
<li>int zoo_create (zhandle_t <em>zh, const char </em>path, const char <em>value,int valuelen, const struct ACL_vector </em>acl, int flags,char *realpath, int max_realpath_len);</li>
</ul>
<p>zoo_create(…) operation creates a new node. The acl parameter is a list of ACLs associated with the node. The parent node must have the CREATE permission bit set.</p>
<ul>
<li>int zoo_get_acl (zhandle_t <em>zh, const char </em>path,struct ACL_vector <em>acl, struct Stat </em>stat);</li>
</ul>
<p>This operation returns a node’s ACL info.</p>
<ul>
<li>int zoo_set_acl (zhandle_t <em>zh, const char </em>path, int version,const struct ACL_vector *acl);</li>
</ul>
<p>This function replaces node’s ACL list with a new one. The node must have the ADMIN permission set.</p>
<p>Here is a sample code that makes use of the above APIs to authenticate itself using the “foo” scheme and create an ephemeral node “/xyz” with create-only permissions.</p>
<blockquote>
<p><strong>Note:</strong> This is a very simple example which is intended to show how to interact with ZooKeeper ACLs specifically. See …/trunk/src/c/src/cli.c for an example of a proper C client implementation</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;errno.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "zookeeper.h"</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> zhandle_t *zh;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * In this example this method gets the cert for your</div><div class="line"> *   environment -- you must provide</div><div class="line"> */</div><div class="line"><span class="keyword">char</span> *foo_get_cert_once(<span class="keyword">char</span>* id) { <span class="keyword">return</span> <span class="number">0</span>; }</div><div class="line"></div><div class="line"><span class="comment">/** Watcher function -- empty for this example, not something you should</span></div><div class="line"> * do in real code */</div><div class="line"><span class="keyword">void</span> watcher(zhandle_t *zzh, <span class="keyword">int</span> type, <span class="keyword">int</span> state, <span class="keyword">const</span> <span class="keyword">char</span> *path,</div><div class="line">             <span class="keyword">void</span> *watcherCtx) {}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv) {</div><div class="line">  <span class="keyword">char</span> buffer[<span class="number">512</span>];</div><div class="line">  <span class="keyword">char</span> p[<span class="number">2048</span>];</div><div class="line">  <span class="keyword">char</span> *cert=<span class="number">0</span>;</div><div class="line">  <span class="keyword">char</span> appId[<span class="number">64</span>];</div><div class="line"></div><div class="line">  <span class="built_in">strcpy</span>(appId, <span class="string">"example.foo_test"</span>);</div><div class="line">  cert = foo_get_cert_once(appId);</div><div class="line">  <span class="keyword">if</span>(cert!=<span class="number">0</span>) {</div><div class="line">    <span class="built_in">fprintf</span>(stderr,</div><div class="line">            <span class="string">"Certificate for appid [%s] is [%s]\n"</span>,appId,cert);</div><div class="line">    <span class="built_in">strncpy</span>(p,cert, <span class="keyword">sizeof</span>(p)-<span class="number">1</span>);</div><div class="line">    <span class="built_in">free</span>(cert);</div><div class="line">  } <span class="keyword">else</span> {</div><div class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">"Certificate for appid [%s] not found\n"</span>,appId);</div><div class="line">    <span class="built_in">strcpy</span>(p, <span class="string">"dummy"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  zoo_set_debug_level(ZOO_LOG_LEVEL_DEBUG);</div><div class="line"></div><div class="line">  zh = zookeeper_init(<span class="string">"localhost:3181"</span>, watcher, <span class="number">10000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span> (!zh) {</div><div class="line">    <span class="keyword">return</span> errno;</div><div class="line">  }</div><div class="line">  <span class="keyword">if</span>(zoo_add_auth(zh,<span class="string">"foo"</span>,p,<span class="built_in">strlen</span>(p),<span class="number">0</span>,<span class="number">0</span>)!=ZOK)</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> ACL CREATE_ONLY_ACL[] = {{ZOO_PERM_CREATE, ZOO_AUTH_IDS}};</div><div class="line">  <span class="keyword">struct</span> ACL_vector CREATE_ONLY = {<span class="number">1</span>, CREATE_ONLY_ACL};</div><div class="line">  <span class="keyword">int</span> rc = zoo_create(zh,<span class="string">"/xyz"</span>,<span class="string">"value"</span>, <span class="number">5</span>, &CREATE_ONLY, ZOO_EPHEMERAL,</div><div class="line">                      buffer, <span class="keyword">sizeof</span>(buffer)-<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">/** this operation will fail with a ZNOAUTH error */</span></div><div class="line">  <span class="keyword">int</span> buflen= <span class="keyword">sizeof</span>(buffer);</div><div class="line">  <span class="keyword">struct</span> Stat stat;</div><div class="line">  rc = zoo_get(zh, <span class="string">"/xyz"</span>, <span class="number">0</span>, buffer, &buflen, &stat);</div><div class="line">  <span class="keyword">if</span> (rc) {</div><div class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">"Error %d for %s\n"</span>, rc, __LINE__);</div><div class="line">  }</div><div class="line"></div><div class="line">  zookeeper_close(zh);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h1 id="可插拔的ZooKeeper身份验证">可插拔的ZooKeeper身份验证</h1>
<p>ZooKeeper runs in a variety of different environments with various different authentication schemes, so it has a completely pluggable authentication framework. Even the builtin authentication schemes use the pluggable authentication framework.</p>
<p>To understand how the authentication framework works, first you must understand the two main authentication operations. The framework first must authenticate the client. This is usually done as soon as the client connects to a server and consists of validating information sent from or gathered about a client and associating it with the connection. The second operation handled by the framework is finding the entries in an ACL that correspond to client. ACL entries are <idspec, permissions=""> pairs. The idspec may be a simple string match against the authentication information associated with the connection or it may be a expression that is evaluated against that information. It is up to the implementation of the authentication plugin to do the match. Here is the interface that an authentication plugin must implement:</idspec,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>{</div><div class="line">    String getScheme();</div><div class="line">    KeeperException.Code handleAuthentication(ServerCnxn cnxn, <span class="keyword">byte</span> authData[]);</div><div class="line">    <span class="keyword">boolean</span> isValid(String id);</div><div class="line">    <span class="keyword">boolean</span> matches(String id, String aclExpr);</div><div class="line">    <span class="keyword">boolean</span> isAuthenticated();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>The first method getScheme returns the string that identifies the plugin. Because we support multiple methods of authentication, an authentication credential or an idspec will always be prefixed with scheme:. The ZooKeeper server uses the scheme returned by the authentication plugin to determine which ids the scheme applies to.</p>
<p>handleAuthentication is called when a client sends authentication information to be associated with a connection. The client specifies the scheme to which the information corresponds. The ZooKeeper server passes the information to the authentication plugin whose getScheme matches the scheme passed by the client. The implementor of handleAuthentication will usually return an error if it determines that the information is bad, or it will associate information with the connection using cnxn.getAuthInfo().add(new Id(getScheme(), data)).</p>
<p>The authentication plugin is involved in both setting and using ACLs. When an ACL is set for a znode, the ZooKeeper server will pass the id part of the entry to the isValid(String id) method. It is up to the plugin to verify that the id has a correct form. For example, ip:172.16.0.0/16 is a valid id, but ip:host.com is not. If the new ACL includes an “auth” entry, isAuthenticated is used to see if the authentication information for this scheme that is assocatied with the connection should be added to the ACL. Some schemes should not be included in auth. For example, the IP address of the client is not considered as an id that should be added to the ACL if auth is specified.</p>
<p>ZooKeeper invokes matches(String id, String aclExpr) when checking an ACL. It needs to match authentication information of the client against the relevant ACL entries. To find the entries which apply to the client, the ZooKeeper server will find the scheme of each entry and if there is authentication information from that client for that scheme, matches(String id, String aclExpr) will be called with id set to the authentication information that was previously added to the connection by handleAuthentication and aclExpr set to the id of the ACL entry. The authentication plugin uses its own logic and matching scheme to determine if id is included in aclExpr.</p>
<p>There are two built in authentication plugins: ip and digest. Additional plugins can adding using system properties. At startup the ZooKeeper server will look for system properties that start with “zookeeper.authProvider.” and interpret the value of those properties as the class name of an authentication plugin. These properties can be set using the -Dzookeeeper.authProvider.X=com.f.MyAuth or adding entries such as the following in the server configuration file:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authProvider<span class="number">.1</span>=com.f.MyAuth</div><div class="line">authProvider<span class="number">.2</span>=com.f.MyAuth2</div></pre></td></tr></table></figure>

<p>Care should be taking to ensure that the suffix on the property is unique. If there are duplicates such as <code>-Dzookeeeper.authProvider.X=com.f.MyAuth -Dzookeeper.authProvider.X=com.f.MyAuth2</code>, only one will be used. Also all servers must have the same plugins defined, otherwise clients using the authentication schemes provided by the plugins will have problems connecting to some servers. </p>
<h1 id="一致性保证_Consistency_Guarantees">一致性保证 Consistency Guarantees</h1>
<p>ZooKeeper is a high performance, scalable service. Both reads and write operations are designed to be fast, though reads are faster than writes. The reason for this is that in the case of reads, ZooKeeper can serve older data, which in turn is due to ZooKeeper’s consistency guarantees:</p>
<p><strong>Sequential Consistency</strong><br>  Updates from a client will be applied in the order that they were sent.</p>
<p><strong>Atomicity</strong><br>  Updates either succeed or fail — there are no partial results.</p>
<p><strong>Single System Image</strong><br>  A client will see the same view of the service regardless of the server that it connects to.</p>
<p><strong>Reliability</strong><br>  Once an update has been applied, it will persist from that time forward until a client overwrites the update. This guarantee has two corollaries:</p>
<ol>
<li>If a client gets a successful return code, the update will have been applied. On some failures (communication errors, timeouts, etc) the client will not know if the update has applied or not. We take steps to minimize the failures, but the guarantee is only present with successful return codes. (This is called the monotonicity condition in Paxos.)</li>
<li>Any updates that are seen by the client, through a read request or successful update, will never be rolled back when recovering from server failures.</li>
</ol>
<p><strong>Timeliness</strong><br>  The clients view of the system is guaranteed to be up-to-date within a certain time bound (on the order of tens of seconds). Either system changes will be seen by a client within this bound, or the client will detect a service outage.</p>
<p>Using these consistency guarantees it is easy to build higher level functions such as leader election, barriers, queues, and read/write revocable locks solely at the ZooKeeper client (no additions needed to ZooKeeper). See Recipes and Solutions for more details.</p>
<blockquote>
<p><strong>Note:</strong> Sometimes developers mistakenly assume one other guarantee that ZooKeeper does not in fact make. This is:<br>Simultaneously Consistent Cross-Client Views<br> ZooKeeper does not guarantee that at every instance in time, two different clients will have identical views of ZooKeeper data. Due to factors like network delays, one client may perform an update before another client gets notified of the change. Consider the scenario of two clients, A and B. If client A sets the value of a znode /a from 0 to 1, then tells client B to read /a, client B may read the old value of 0, depending on which server it is connected to. If it is important that Client A and Client B read the same value, Client B should should call the sync() method from the ZooKeeper API method before it performs its read.<br> So, ZooKeeper by itself doesn’t guarantee that changes occur synchronously across all servers, but ZooKeeper primitives can be used to construct higher level functions that provide useful client synchronization. (For more information, see the ZooKeeper Recipes. [tbd:..]).</p>
</blockquote>
<h1 id="绑定Binding">绑定Binding</h1>
<p>The ZooKeeper client libraries come in two languages: Java and C. The following sections describe these.</p>
<h2 id="Java_Binding">Java Binding</h2>
<p>here are two packages that make up the ZooKeeper Java binding: <strong>org.apache.zookeeper and org.apache.zookeeper.data</strong>. The rest of the packages that make up ZooKeeper are used internally or are part of the server implementation. The <strong>org.apache.zookeeper.data</strong> package is made up of generated classes that are used simply as containers.</p>
<p>The main class used by a ZooKeeper Java client is the ZooKeeper class. Its two constructors differ only by an optional session id and password. ZooKeeper supports session recovery accross instances of a process. A Java program may save its session id and password to stable storage, restart, and recover the session that was used by the earlier instance of the program.</p>
<p>When a ZooKeeper object is created, two threads are created as well: an IO thread and an event thread. All IO happens on the IO thread (using Java NIO). All event callbacks happen on the event thread. Session maintenance such as reconnecting to ZooKeeper servers and maintaining heartbeat is done on the IO thread. Responses for synchronous methods are also processed in the IO thread. All responses to asynchronous methods and watch events are processed on the event thread. There are a few things to notice that result from this design:</p>
<ul>
<li>All completions for asynchronous calls and watcher callbacks will be made in order, one at a time. The caller can do any processing they wish, but no other callbacks will be processed during that time.</li>
<li>Callbacks do not block the processing of the IO thread or the processing of the synchronous calls.</li>
<li>Synchronous calls may not return in the correct order. For example, assume a client does the following processing: issues an asynchronous read of node /a with watch set to true, and then in the completion callback of the read it does a synchronous read of /a. (Maybe not good practice, but not illegal either, and it makes for a simple example.)<br>Note that if there is a change to /a between the asynchronous read and the synchronous read, the client library will receive the watch event saying /a changed before the response for the synchronous read, but because the completion callback is blocking the event queue, the synchronous read will return with the new value of /a before the watch event is processed.</li>
</ul>
<p>Finally, the rules associated with shutdown are straightforward: once a ZooKeeper object is closed or receives a fatal event (SESSION_EXPIRED and AUTH_FAILED), the ZooKeeper object becomes invalid. On a close, the two threads shut down and any further access on zookeeper handle is undefined behavior and should be avoided. </p>
<h2 id="C_Binding">C Binding</h2>
<p>The C binding has a single-threaded and multi-threaded library. The multi-threaded library is easiest to use and is most similar to the Java API. This library will create an IO thread and an event dispatch thread for handling connection maintenance and callbacks. The single-threaded library allows ZooKeeper to be used in event driven applications by exposing the event loop used in the multi-threaded library.</p>
<p>The package includes two shared libraries: zookeeper_st and zookeeper_mt. The former only provides the asynchronous APIs and callbacks for integrating into the application’s event loop. The only reason this library exists is to support the platforms were a pthread library is not available or is unstable (i.e. FreeBSD 4.x). In all other cases, application developers should link with zookeeper_mt, as it includes support for both Sync and Async API.</p>
<h3 id="Installation">Installation</h3>
<p>If you’re building the client from a check-out from the Apache repository, follow the steps outlined below. If you’re building from a project source package downloaded from apache, skip to step <strong>3</strong>.</p>
<ol>
<li>Run ant compile_jute from the ZooKeeper top level directory (…/trunk). This will create a directory named “generated” under …/trunk/src/c.</li>
<li>Change directory to the…/trunk/src/c and run <code>autoreconf</code> -if to bootstrap <code>autoconf</code>, <code>automake</code> and <code>libtool</code>. Make sure you have autoconf version 2.59 or greater installed. Skip to step <strong>4</strong>.</li>
<li>If you are building from a project source package, unzip/untar the source tarball and cd to the zookeeper-x.x.x/src/c directory.</li>
<li>Run ./configure <your-options> to generate the makefile. Here are some of options the configure utility supports that can be useful in this step:<ul>
<li>—enable-debug<br>Enables optimization and enables debug info compiler options. (Disabled by default.)</li>
<li>—without-syncapi<br>Disables Sync API support; zookeeper_mt library won’t be built. (Enabled by default.)</li>
<li>—disable-static<br>Do not build static libraries. (Enabled by default.)</li>
<li>—disable-shared<br>Do not build shared libraries. (Enabled by default.)<blockquote>
<p><strong>Note:</strong> See INSTALL for general information about running configure.</p>
</blockquote>
</li>
</ul>
</your-options></li>
<li>Run make or make install to build the libraries and install them.</li>
<li>To generate doxygen documentation for the ZooKeeper API, run make doxygen-doc. All documentation will be placed in a new subfolder named docs. By default, this command only generates HTML. For information on other document formats, run ./configure —help</li>
</ol>
<h3 id="Using_the_C_Client">Using the C Client</h3>
<p>You can test your client by running a ZooKeeper server (see instructions on the project wiki page on how to run it) and connecting to it using one of the cli applications that were built as part of the installation procedure. cli_mt (multithreaded, built against zookeeper_mt library) is shown in this example, but you could also use cli_st (singlethreaded, built against zookeeper_st library):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cli_mt zookeeper_hos<span class="variable">t:9876</span></div></pre></td></tr></table></figure>

<p>This is a client application that gives you a shell for executing simple ZooKeeper commands. Once successfully started and connected to the server it displays a shell prompt. You can now enter ZooKeeper commands. For example, to create a node:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="blockquote">&gt; create /my_new_node</span></div></pre></td></tr></table></figure>

<p>To verify that the node’s been created:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">ls</span> /</div></pre></td></tr></table></figure>

<p>You should see a list of node who are children of the root node “/“.</p>
<p>In order to be able to use the ZooKeeper API in your application you have to remember to</p>
<ol>
<li>Include ZooKeeper header: #include <zookeeper zookeeper.h=""></zookeeper></li>
<li>If you are building a multithreaded client, compile with -DTHREADED compiler flag to enable the multi-threaded version of the library, and then link against against the zookeeper_mt library. If you are building a single-threaded client, do not compile with -DTHREADED, and be sure to link against the zookeeper_st library.</li>
</ol>
<p>Refer to Program Structure, with Simple Example for examples of usage in Java and C. [tbd] </p>
<h1 id="Building_Blocks:_A_Guide_to_ZooKeeper_Operations">Building Blocks: A Guide to ZooKeeper Operations</h1>
<p>This section surveys all the operations a developer can perform against a ZooKeeper server. It is lower level information than the earlier concepts chapters in this manual, but higher level than the ZooKeeper API Reference. It covers these topics:</p>
<ul>
<li><a href="http://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html#sc_connectingToZk" target="_blank" rel="external">Connecting to ZooKeeper</a></li>
</ul>
<h2 id="Handling_Errors">Handling Errors</h2>
<p>Both the Java and C client bindings may report errors. The Java client binding does so by throwing KeeperException, calling code() on the exception will return the specific error code. The C client binding returns an error code as defined in the enum ZOO_ERRORS. API callbacks indicate result code for both language bindings. See the API documentation (javadoc for Java, doxygen for C) for full details on the possible errors and their meaning.</p>
<h2 id="Connecting_to_ZooKeeper">Connecting to ZooKeeper</h2>
<h2 id="Read_Operations">Read Operations</h2>
<h2 id="Write_Operations">Write Operations</h2>
<h2 id="Handling_Watches">Handling Watches</h2>
<h2 id="Miscelleaneous_ZooKeeper_Operations">Miscelleaneous ZooKeeper Operations</h2>
<h1 id="Program_Structure,_with_Simple_Example">Program Structure, with Simple Example</h1>
<h1 id="Gotchas:_Common_Problems_and_Troubleshooting">Gotchas: Common Problems and Troubleshooting</h1>
<p>So now you know ZooKeeper. It’s fast, simple, your application works, but wait … something’s wrong. Here are some pitfalls that ZooKeeper users fall into:</p>
<ol>
<li>If you are using watches, you must look for the connected watch event. When a ZooKeeper client disconnects from a server, you will not receive notification of changes until reconnected. If you are watching for a znode to come into existance, you will miss the event if the znode is created and deleted while you are disconnected.</li>
<li>You must test ZooKeeper server failures. The ZooKeeper service can survive failures as long as a majority of servers are active. The question to ask is: can your application handle it? In the real world a client’s connection to ZooKeeper can break. (ZooKeeper server failures and network partitions are common reasons for connection loss.) The ZooKeeper client library takes care of recovering your connection and letting you know what happened, but you must make sure that you recover your state and any outstanding requests that failed. Find out if you got it right in the test lab, not in production - test with a ZooKeeper service made up of a several of servers and subject them to reboots.</li>
<li>The list of ZooKeeper servers used by the client must match the list of ZooKeeper servers that each ZooKeeper server has. Things can work, although not optimally, if the client list is a subset of the real list of ZooKeeper servers, but not if the client lists ZooKeeper servers not in the ZooKeeper cluster.</li>
<li>Be careful where you put that transaction log. The most performance-critical part of ZooKeeper is the transaction log. ZooKeeper must sync transactions to media before it returns a response. A dedicated transaction log device is key to consistent good performance. Putting the log on a busy device will adversely effect performance. If you only have one storage device, put trace files on NFS and increase the snapshotCount; it doesn’t eliminate the problem, but it can mitigate it.</li>
<li>Set your Java max heap size correctly. It is very important to avoid swapping. Going to disk unnecessarily will almost certainly degrade your performance unacceptably. Remember, in ZooKeeper, everything is ordered, so if one request hits the disk, all other queued requests hit the disk.</li>
<li>To avoid swapping, try to set the heapsize to the amount of physical memory you have, minus the amount needed by the OS and cache. The best way to determine an optimal heap size for your configurations is to run load tests. If for some reason you can’t, be conservative in your estimates and choose a number well below the limit that would cause your machine to swap. For example, on a 4G machine, a 3G heap is a conservative estimate to start with.</li>
</ol>
<p>Outside the formal documentation, there’re several other sources of information for ZooKeeper developers.<br>[tbd]</p>
<p><strong>ZooKeeper Whitepaper [tbd: find url]</strong><br>The definitive discussion of ZooKeeper design and performance, by Yahoo! Research<br><strong>API Reference [tbd: find url]</strong><br>The complete reference to the ZooKeeper API<br><strong>ZooKeeper Talk at the Hadoup Summit 2008</strong><br>A video introduction to ZooKeeper, by Benjamin Reed of Yahoo! Research<br><strong>Barrier and Queue Tutorial</strong><br>The excellent Java tutorial by Flavio Junqueira, implementing simple barriers and producer-consumer queues using ZooKeeper.<br>ZooKeeper - A Reliable, Scalable Distributed Coordination System<br><strong>An article by Todd Hoff (07/15/2008)</strong><br><strong>ZooKeeper Recipes</strong><br>Pseudo-level discussion of the implementation of various synchronization solutions with ZooKeeper: Event Handles, Queues, Locks, and Two-phase Commits.<br><strong>[tbd]</strong><br>Any other good sources anyone can think of…</p>
]]></content>
    <summary type="html"><![CDATA[<p>翻译于最新的<a href="http://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html" target="_blank" rel="external">ZooKeeper 3.4 文档</a>。</p>
<h1 id="前言">前言</h1>
<p>本文档是为那些希望利用ZooKeeper的协调服务建立分布式应用程序的开发人员而写的指南。它包含了Zookeeper的概念和实践内容。<br>指南的前四节介绍了ZooKeeper各种概念的高层次的讨论。 对于理解ZooKeeper如何工作和如何使用它这些概念都是必须了解的。尽管不包含代码，但还是假定你熟悉分布式计算相关的问题。<br>第一组的章节包括：</p>
<ul>
<li>ZooKeeper数据模型： The ZooKeeper Data Model</li>
<li>ZooKeeper的会话： ZooKeeper Sessions</li>
<li>ZooKeeper的监视： ZooKeeper Watches</li>
<li>一致性保证：Consistency Guarantees<br><em>(下面的翻译中概念尽量不翻译成中文，因为英文更能直观的反映其概念)</em></li>
</ul>
<p>接下来的四个章节提供了编程实践信息，它们是:</p>
<ul>
<li>Building Blocks: A Guide to ZooKeeper Operations</li>
<li>Bindings</li>
<li>Program Structure, with Simple Example [tbd]</li>
<li>Gotchas: Common Problems and Troubleshooting</li>
</ul>
<p>附录中的链接是其它的有用的,和ZooKeeper相关的信息.<br>书中的章节都可以独立阅读，然而在开发你的第一个ZooKeeper程序之前， 你最好先阅读一下ZooKeeper数据模型和ZooKeeper基本操作。Simple Programmming Example对于理解ZooKeeper客户端程序的基本结构也很有帮助.<br>]]></summary>
    
      <category term="Zookeeper" scheme="http://colobu.com/tags/Zookeeper/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop生态圈一览]]></title>
    <link href="http://colobu.com/2014/09/26/hadoop-ecosystem-at-a-glance/"/>
    <id>http://colobu.com/2014/09/26/hadoop-ecosystem-at-a-glance/</id>
    <published>2014-09-26T09:02:36.000Z</published>
    <updated>2014-09-28T00:43:53.000Z</updated>
    <content type="html"><![CDATA[<p>Hadoop是一个大规模的分布式可扩展的批处理大数据框架(PB级别)，可以运行于千台服务器的集群。</p>
<p>最近几年Hadoop生态圈持续成长。 涌现了很多的关于工具和框架的术语。 也有很多的组织基于Hadoop进行研究和创新， 使Hadoop变得越来越好，越来越容易。基于作者的几周的潜心研究， 他提供了一个思维脑图， 描绘了Hadoop的生态圈， 可以帮助我们了解Hadoop生态圈的全貌。<br><a id="more"></a><br>英文原址: <a href="http://www.neevtech.com/blog/2013/03/18/hadoop-ecosystem-at-a-glance/" target="_blank" rel="external">Hadoop Ecosystem at a glance</a></p>
<p><img src="http://www.neevtech.com/blog/wp-content/uploads/2013/03/hadoop.png" alt=""></p>
<h1 id="Core">Core</h1>
<ul>
<li><strong>HDFS</strong>: Hadoop Distribute File System (HDFS) is a distributed file system designed to run on a commodity cluster of machines. HDFS is highly fault tolerant and is useful for processing large data sets. A Map Reduce job, described below, typically processes data stored in HDFS. Files in HDFS are split into blocks, typically 64MB or 128MB, and stored across nodes in the cluster. Each block of data is also replicated across more nodes, generally three, in the cluster to avoid data loss in case of a node failure.</li>
<li><strong>MapReduce</strong>: MapReduce is a software framework for processing large data sets, petabyte scale, on a cluster of commodity hardware.  When MapReduce jobs are run, Hadoop splits the input and locates the nodes on the cluster. The actual jobs are then run at or close to the node where the data is residing so that the data is as close to the computation node as possible. This avoids transfer of huge amount of data across the network so that the network does not become a bottleneck or get flooded.</li>
</ul>
<p>Distributions</p>
<ul>
<li><strong>Apache</strong>: Purely Open Source distribution of Hadoop maintained by the community at Apache Software Foundation.</li>
<li><strong>Cloudera</strong>: Cloudera’s distribution of Hadoop that is built on top of Apache Hadoop. The distribution includes capabilities such as management, security, high availability and integration with a wide variety of hardware and software solutions. Cloudera is the leading distributor of Hadoop.</li>
<li><strong>Horton Works</strong>: This also builds on the Open Source Apache Hadoop with claims to enterprise readiness. It also claims to be the only distribution that is available for Windows servers.</li>
<li><strong>MapR</strong>: Hadoop distribution with some unique features, most notably the ability to mount the Hadoop cluster over NFS.</li>
<li><strong>Intel</strong>: Intel’s Open Source version of Hadoop distribution.</li>
<li><strong>Greenplum</strong>:  Greenplum’s distribution is called Pivotal HD. One of the highlights of this distribution is a SQL-based database engine on Hadoop that allows querying of data in Hadoop using SQL.</li>
<li><strong>Amazon EMR</strong> : Amazon’s hosted version of MapReduce is called Elastic Map Reduce. This is part of the Amazon Web Services (AWS). EMR allows a Hadoop cluster to be deployed and MapReduce jobs to be run in the AWS cloud with just a few clicks.</li>
</ul>
<p>Related Projects</p>
<ul>
<li><strong>Avro</strong>: Avro is a data serialization framework that is useful in Hadoop and other systems. The framework allows one to define schema which is language independent so that data can be interchanged between different languages.e.g  A Hadoop client in a different language can use Avro as the data serialization framework to communicate with the Hadoop server which is in Java.</li>
<li><strong>Pig</strong>: Framework for analyzing large data sets using a high level language called Pig Latin. Scripts written in Pig Latin are compiled by the framework in MapReduce jobs which are run on the Hadoop cluster. Pig eases development of MapReduce jobs. A set of MapReduce jobs which may take hundreds of lines of code can be written with just few lines of Pig Latin scripts. At Yahoo &gt; 60% of Hadoop usage is on Pig.</li>
<li><strong>Hive</strong> : Hive is a data warehouse framework that stores querying of large data sets stored in Hadoop. To do this, Hive provides a high-level SQL like language called HiveQL. Traditional MapReduce programs can be plugged into HiveQL where its more efficient to have these instead of HiveQL.</li>
<li><strong>HBase</strong> : HBase is a distributed scalable data store based on Hadoop. HBase is a distributed, versioned, column-oriented database modeled after Google’s BigTable.</li>
<li><strong>Mahout</strong> : Mahout is a scalable Machine learning library. Mahout utilizes Hadoop to achieve massive scalability.</li>
<li><strong>YARN</strong> : YARN is the next generation of MapReduce a.k.a MapReduce 2. The MapReduce framework was overhauled using YARN to overcome the scalability bottlenecks in earlier version of MapReduce when it was run over a very large cluster(thousands of nodes).</li>
<li><strong>Ozzie</strong> : In a real life scenario, a MapReduce deployment typically involves running a sequence of MapReduce and other pre and post processing jobs at scheduled times or based on data availability. Ozzie is a workflow scheduler system that eases the creation and management of these workflows. A workflow is defined using XML in which one can do HDFS operations, run MapReduce jobs, Pig scripts, Streaming jobs, branching, chaining, etc.</li>
<li><strong>Flume</strong> : A distributed, reliable and available service for collecting, aggregating and moving log data to HDFS. This is typically useful in systems where log data needs to be moved to HDFS periodically for processing.</li>
<li><strong>Sqoop</strong> : Sqoop is designed for transferring data between Hadoop and relational databases.</li>
<li><strong>Cascading</strong> : Application framework for building applications using Hadoop.</li>
</ul>
<p>Related Technologies</p>
<p>Below is a list of related BigData technologies but which follow an architecture different from Hadoop.</p>
<ul>
<li><strong>Twitter Storm</strong> : As opposed to Hadoop which is a batch processing system, Storm is a distributed real-time processing system developed by Twitter. Storm is fast, scalable and easy to use.</li>
<li><strong>HPCC</strong> : High Performance Computing Cluster (HPCC) is an MPP (Massive Parallel Processing) computing platform for solving Big Data problems. HPCC follows an architecture different from Hadoop. It boasts a few differences and advantages over Hadoop.</li>
<li><strong>Dremel</strong> : A scalable interactive ad-hoc query system for analysis of read-only nested data by Google. Google’s BigQuery service is reportedly based on Dremel.</li>
</ul>
<p>This is not an exhaustive list and there may be many other projects, tools, and organizations related to Hadoop. I have tried to touch the most popular ones here.</p>
<p>In future posts, I wish to talk in detail about some of the less-talked-about projects in the above list but which can be really useful in day-to-day running and managing of a Hadoop cluster.</p>
]]></content>
    <summary type="html"><![CDATA[<p>Hadoop是一个大规模的分布式可扩展的批处理大数据框架(PB级别)，可以运行于千台服务器的集群。</p>
<p>最近几年Hadoop生态圈持续成长。 涌现了很多的关于工具和框架的术语。 也有很多的组织基于Hadoop进行研究和创新， 使Hadoop变得越来越好，越来越容易。基于作者的几周的潜心研究， 他提供了一个思维脑图， 描绘了Hadoop的生态圈， 可以帮助我们了解Hadoop生态圈的全貌。<br>]]></summary>
    
      <category term="Hadoop" scheme="http://colobu.com/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
