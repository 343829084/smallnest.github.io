<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2015-11-20T09:00:31.173Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java8 简明教程]]></title>
    <link href="http://colobu.com/2015/11/20/java8-tutorial/"/>
    <id>http://colobu.com/2015/11/20/java8-tutorial/</id>
    <published>2015-11-20T07:14:50.000Z</published>
    <updated>2015-11-20T08:59:31.437Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是<a href="http://winterbe.com" target="_blank" rel="external">Benjamin Winterberg</a>写的英文教程<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">Modern Java - A Guide to Java 8</a>,最早发表于2014年三月，当时由 <a href="http://www.importnew.com/" target="_blank" rel="external">ImportNew</a> - <a href="http://www.importnew.com/author/huangxiaofei" target="_blank" rel="external">黄小非</a>翻译成中文: <a href="http://www.importnew.com/10360.html" target="_blank" rel="external">Java 8简明教程</a>。离原文初次发表已经快两年了，作者又陆陆续续提交多个commit，所以我根据原文以及黄小非的译文又做了修正。实际绝大部分的内容和小非翻译的一样，只有些许的变化。</p>
</blockquote>
<p><strong>Java并没有没落，人们开始认识到这一点</strong></p>
<p>欢迎阅读我编写的<a href="https://jdk8.java.net/" target="_blank" rel="external">Java 8</a>介绍。本教程将带领你一步步认识这门语言的所有新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和可重复注解。在这篇教程的最后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。<br><strong>没有大段的废话，只是一些带注释的代码片段，望君喜欢。</strong></p>
<p>本文最早发表在我的<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">博客</a>上。 你可以在Twitter上<a href="https://twitter.com/winterbe_" target="_blank" rel="external">加我</a>。<br><a id="more"></a></p>
<h2 id="接口中的默认方法">接口中的默认方法</h2>
<p>Java 8 允许我们使用default关键字，为接口添加非抽象(non-abstract)的方法实现。这个特性又被称为<a href="http://stackoverflow.com/a/24102730" target="_blank" rel="external">扩展方法</a>。下面是我们的第一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface Formula {</div><div class="line">    <span class="keyword">double</span> calculate(<span class="keyword">int</span> a);</div><div class="line"></div><div class="line">    <span class="keyword">default</span> <span class="keyword">double</span> sqrt(<span class="keyword">int</span> a) {</div><div class="line">        <span class="keyword">return</span> Math.sqrt(a);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在接口<em>Formula</em>中，除了抽象方法<em>caculate</em>以外，还定义了一个默认方法sqrt。Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Formula formula = <span class="keyword">new</span> Formula() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span>(<span class="keyword">int</span> a) {</div><div class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></div><div class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></div></pre></td></tr></table></figure>

<p><em>formula</em>对象以匿名对象的形式实现了Formula接口。代码很啰嗦：用了6行代码才实现了一个简单的计算功能：a*100 开平方根。我们在下一节会看到，Java 8 还有一种更加漂亮的方法，能够实现只包含单个函数的对象。</p>
<h3 id="Lambda表达式">Lambda表达式</h3>
<p>让我们从最简单的例子开始，来学习如何对一个string列表进行排序。我们首先使用Java 8之前的方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</div><div class="line"></div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(String a, String b) {</div><div class="line">        <span class="keyword">return</span> b.compareTo(a);</div><div class="line">    }</div><div class="line">});</div></pre></td></tr></table></figure>

<p>静态工具方法 Collections.sort 接受一个 list，和一个 Comparator 接口作为输入参数来对，Comparator的实现类可以对输入的list中的元素进行比较。通常你会创建一个匿名Comparator对象，并把它作为参数传递给sort方法。</p>
<p>除了一直以来创建匿名对象的方式外，Java 8 还提供了一种更简洁的语法，Lambda表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; {</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>如你所见，这段代码比之前的更加简短和易读。但是，它还可以更加简短：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>

<p>只要一行代码，包含了方法体。你甚至可以连大括号对{}和return关键字都省略不要。不过这还不是最短的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">names.sort((a, b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>

<p>List现在有了一个 sort方法。Java编译器能够自动识别参数的类型，所以你就可以省略掉类型不写。让我们再深入地研究一下lambda表达式的威力吧。</p>
<h3 id="函数式接口">函数式接口</h3>
<p>Lambda表达式如何匹配Java的类型系统？每一个lambda都能够通过一个特定的接口，与一个给定的类型进行匹配。一个所谓的函数式接口必须要<strong>有且仅有一个抽象方法声明</strong>。每个与之对应的lambda表达式必须要与这个抽象方法的声明相匹配。由于默认方法不是抽象的，因此你可以在你的函数式接口里任意添加默认方法。<br>只包含一个抽象方法的任意接口，我们都可以用来当作lambda表达式的类型。为了让你定义的接口满足要求，你应当在接口前加上<code>@FunctionalInterface</code>注解。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。<br>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line">interface Converter&lt;F, T&gt; {</div><div class="line">    T convert(F from);</div><div class="line">}</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// 123</span></div></pre></td></tr></table></figure>

<p>注意，如果你不写<code>@FunctionalInterface</code> 注解，程序也是正确的。</p>
<h3 id="方法和构造函数引用">方法和构造函数引用</h3>
<p>上面的代码实例可以通过静态方法引用，使之更加简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);   <span class="comment">// 123</span></div></pre></td></tr></table></figure>

<p>Java 8 允许你通过::关键字获取方法或者构造函数的的引用。上面的例子就演示了如何引用一个静态方法。而且，我们还可以对一个对象的方法进行引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Something {</div><div class="line">    String startsWith(String s) {</div><div class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Something something = <span class="keyword">new</span> Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// "J"</span></div></pre></td></tr></table></figure>

<p>让我们看看如何使用::关键字引用构造函数。首先我们定义一个包含不同的构造方法示例bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person {</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() {}</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) {</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来，我们定义一个person工厂接口，用来创建新的person对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface PersonFactory&lt;P extends Person&gt; {</div><div class="line">    P create(String firstName, String lastName);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后我们通过构造函数引用来把所有东西拼到一起，而不是像以前一样，通过手动实现一个工厂来这么做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</div></pre></td></tr></table></figure>

<p>我们通过Person::new来创建一个<code>Person</code>类构造函数的引用。Java编译器会自动地选择合适的构造函数来匹配<code>PersonFactory.create</code>函数的签名，并选择正确的构造函数形式。</p>
<h3 id="Lambda的域_(scope)">Lambda的域 (scope)</h3>
<p>访问lambdab表达式外部的变量类似匿名对象。你能够访问局部外部域(local outer scope)的final变量，以及成员变量和静态变量。</p>
<h3 id="访问局部变量">访问局部变量</h3>
<p>我们可以访问lambda表达式外部的final局部变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p>但是与匿名对象不同的是，变量num并不需要一定是final。下面的代码依然是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p>然而， 变量num 必须隐式地编译成为final类型。下面的代码无法编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = <span class="number">3</span>;</div></pre></td></tr></table></figure>

<p>在Lambda表达式中也禁止对局部变量 <code>num</code>的写。</p>
<h3 id="访问成员变量和静态变量">访问成员变量和静态变量</h3>
<p>与局部变量不同，我们在lambda表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Lambda4 {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</div><div class="line">    <span class="keyword">int</span> outerNum;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> testScopes() {</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {</div><div class="line">            outerNum = <span class="number">23</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        };</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {</div><div class="line">            outerStaticNum = <span class="number">72</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        };</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="访问默认接口方法">访问默认接口方法</h3>
<p>还记得第一节里面formula的那个例子么？ 接口Formula定义了一个默认的方法sqrt，该方法能够被formula所有的实例以及匿名对象所访问。这个对lambda表达式来讲则无效。</p>
<p>默认方法无法在lambda表达式内部被访问。因此下面的代码是无法通过编译的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</div></pre></td></tr></table></figure>

<h3 id="内置函数式接口">内置函数式接口</h3>
<p>JDK 1.8 API中包含了很多内置的函数式接口。有些是在以前版本的Java中大家耳熟能详的，例如<code>Comparator</code>接口，或者<code>Runnable</code>接口。Java8 对这些现成的接口进行了扩展，加上了@FunctionalInterface 注解来标识。</p>
<p>Java 8 API 还提供了很多新的函数式接口，使你的生活更美好。有些新的接口已经在<a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">Google Guava 库</a>中很有名了。如果你对这些库很熟的话，你甚至闭上眼睛都能够想到，这些接口在类库的实现过程中起了多么大的作用。</p>
<h3 id="Predicate">Predicate</h3>
<p>Predicate是一个布尔类型的函数，该函数只有一个输入参数。Predicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>

<h3 id="Function">Function</h3>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起（compse, andThen）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></div></pre></td></tr></table></figure>

<h3 id="Supplier">Supplier</h3>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure>

<h3 id="Consumer">Consumer</h3>
<p>Consumer代表了在单一的输入参数上需要进行的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</div><div class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</div></pre></td></tr></table></figure>

<h3 id="Comparator">Comparator</h3>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></div><div class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></div></pre></td></tr></table></figure>

<h3 id="Optional">Optional</h3>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerEception产生。这个概念在下一节会显得很重要，所以我们在这里快速地浏览一下Optional是如何使用的。</p>
<p>Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</div><div class="line"></div><div class="line">optional.isPresent();           <span class="comment">// true</span></div><div class="line">optional.get();                 <span class="comment">// "bam"</span></div><div class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></div></pre></td></tr></table></figure>

<h2 id="Stream">Stream</h2>
<p><code>java.util.Stream</code>表示了某种元素的序列，在这些元素上可以进行各种操作。Stream操作可以是中间操作(intermediate )，也可以是完结操作(terminal)。完结操作会返回一个某种类型的值，而中间操作会返回流对象本身，并且你可以通过多次调用同一个流操作方法来将操作结果串起来。Stream是在一个源(source)上创建出来的，例如<code>java.util.Collection</code>中的<code>list</code>或者<code>set</code>（map不能作为Stream的源）。Stream操作既可以并行也可以串行。</p>
<blockquote>
<p>你也应该看看 <a href="https://github.com/winterbe/streamjs" target="_blank" rel="external">Stream.js</a>, Java 8 Streams API的 Javascript移植.</p>
</blockquote>
<p>我们先了解一下串行流。首先，我们创建string类型的list的源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(<span class="string">"ddd2"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa2"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb1"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa1"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb3"</span>);</div><div class="line">stringCollection.add(<span class="string">"ccc"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb2"</span>);</div><div class="line">stringCollection.add(<span class="string">"ddd1"</span>);</div></pre></td></tr></table></figure>

<p>Java 8中的Collections类的功能已经有所增强，你可以之直接通过调用<code>Collections.stream()</code>或者<code>Collection.parallelStream()</code>方法来创建一个流对象。下面的章节会解释这个最常用的操作。</p>
<h3 id="Filter">Filter</h3>
<p>Filter接受一个predicate接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基础上再进行其他的流操作（<code>forEach</code>）。ForEach接受一个consumer，用来执行对每一个元素的操作。ForEach是一个中止操作。它返回<code>void</code>，所以我们不能再调用其他的流操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa2", "aaa1"</span></div></pre></td></tr></table></figure>

<h3 id="Sorted">Sorted</h3>
<p>Sorted是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个Comparator接口来改变排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa1", "aaa2"</span></div></pre></td></tr></table></figure>

<p>一定要记住，<code>sorted</code>只是创建一个流对象排序的视图，而不会改变原来集合中元素的顺序。原来string集合中的元素顺序是没有改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(stringCollection);</div><div class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></div></pre></td></tr></table></figure>

<h3 id="Map">Map</h3>
<p>map是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素映射到另外一个对象上。下面的例子就演示了如何把每个string都转换成大写的string. 不但如此，你还可以把每一种对象映射成为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给map的泛型方法来决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></div></pre></td></tr></table></figure>

<h3 id="Match">Match</h3>
<p>匹配操作有多种不同的类型，都是用来判断某个predicate 是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个boolean类型的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      <span class="comment">// tr</span></div></pre></td></tr></table></figure>

<h3 id="Count">Count</h3>
<p>Count是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<h3 id="Reduce">Reduce</h3>
<p>该操作是一个终结操作，它能够通过某一个方法，对元素进行 reduction 操作。该操作的结果会放在一个Optional变量里返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></div></pre></td></tr></table></figure>

<h3 id="并行流">并行流</h3>
<p>像上面所说的，流操作可以是串行的，也可以是并行的。串行操作通过单线程执行，而并行操作则通过多线程执行。<br>下面的例子就演示了如何使用并行流进行操作来提高运行效率，代码非常简单。<br>首先我们创建一个大的list，里面的元素都是唯一的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</div><div class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) {</div><div class="line">    UUID uuid = UUID.randomUUID();</div><div class="line">    values.add(uuid.toString());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，我们测量一下对这个集合进行排序所使用的时间。</p>
<h3 id="串行排序">串行排序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// sequential sort took: 899 ms</span></div></pre></td></tr></table></figure>

<h3 id="并行排序">并行排序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// parallel sort took: 472 ms</span></div></pre></td></tr></table></figure>

<p>如你所见，所有的代码段几乎都相同，唯一的不同就是把<code>stream()</code>改成了<code>parallelStream()</code>, 结果并行排序快了50%。</p>
<h3 id="Map-1">Map</h3>
<p>正如前面已经提到的那样，map是不支持流操作的, map类没有stream()方法。但是你可以在key, value, entry上产生特定流， 比如下列方法 <code>map.keySet().stream()</code>, <code>map.values().stream()</code> 和 <code>map.entrySet().stream()</code>。</p>
<p>而更新后的map现在则支持多种实用的新方法，来完成常规的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</div><div class="line">}</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure>

<p>上面的代码风格是完全自解释的：<code>putIfAbsent</code> 避免我们将<code>null</code>写入；<code>forEach</code>接受一个consumer，从而将操作实施到每一个map中的值上。</p>
<p>下面的这个例子展示了如何使用函数在map执行计算操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</div><div class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</div><div class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div></pre></td></tr></table></figure>

<p>接下来，我们将学习，当给定一个key值时，如何把一个实例从对应的key中移除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></div></pre></td></tr></table></figure>

<p>另一个有用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></div></pre></td></tr></table></figure>

<p>将map中的实例合并也是非常容易的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></div><div class="line"></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></div></pre></td></tr></table></figure>

<p>合并操作先看map中是否没有特定的key/value存在，如果是，则把key/value存入map，否则merging函数就会被调用，对现有的数值进行修改。</p>
<h3 id="时间日期API">时间日期API</h3>
<p>Java 8 包含了全新的时间日期API，这些功能都放在了<code>java.time</code>包下。新的时间日期API是参考<a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda-Time</a>库开发的，但是也<a href="http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html" target="_blank" rel="external">不尽相同</a>。下面的例子就涵盖了大多数新的API的重要部分。</p>
<h3 id="Clock">Clock</h3>
<p>Clock提供了对当前时间和日期的访问功能。Clock是对当前时区敏感的，并可用于替代<code>System.currentTimeMillis()</code>方法来获取当前的毫秒时间。当前时间线上的时刻可以用<code>Instance</code>类来表示。Instance也能够用于创建原先的<code>java.util.Date</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line"><span class="keyword">long</span> millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></div></pre></td></tr></table></figure>

<h3 id="Timezone">Timezone</h3>
<p>时区类可以用一个<code>ZoneId</code>来表示。时区类的对象可以通过静态工厂方法方便地获取。时区类还定义了一个偏移量，用来在当前时刻或某时间与目标时区时间之间进行转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line"><span class="comment">// prints all available timezone ids</span></div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</div><div class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></div></pre></td></tr></table></figure>

<h3 id="LocalTime">LocalTime</h3>
<p>本地时间类表示一个没有指定时区的时间，例如，10 p.m.或者17：30:15，下面的例子会用上面的例子定义的时区创建两个本地时间对象。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></div><div class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></div></pre></td></tr></table></figure>

<p>LocalTime是由多个工厂方法组成，其目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</div><div class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></div></pre></td></tr></table></figure>

<h3 id="LocalDate">LocalDate</h3>
<p>本地时间表示了一个独一无二的时间，例如：2014-03-11。这个时间是不可变的，与LocalTime是同源的。下面的例子演示了如何通过加减日，月，年等指标来计算新的日期。记住，每一次操作都会返回一个新的时间对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></div></pre></td></tr></table></figure>

<p>解析字符串并形成LocalDate对象，这个操作和解析LocalTime一样简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</div><div class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></div></pre></td></tr></table></figure>

<h3 id="LocalDateTime">LocalDateTime</h3>
<p>LocalDateTime表示的是日期-时间。它将刚才介绍的日期对象和时间对象结合起来，形成了一个对象实例。<code>LocalDateTime</code>是不可变的，与LocalTime和LocalDate的工作原理相同。我们可以通过调用方法来获取日期时间对象中特定的数据域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></div></pre></td></tr></table></figure>

<p>如果再加上的时区信息，LocalDateTime能够被转换成Instance实例。Instance能够被转换成以前的java.util.Date对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></div></pre></td></tr></table></figure>

<p>格式化日期-时间对象就和格式化日期对象或者时间对象一样。除了使用预定义的格式以外，我们还可以创建自定义的格式化对象，然后匹配我们自定义的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></div></pre></td></tr></table></figure>

<p>不同于<code>java.text.NumberFormat</code>，新的<code>DateTimeFormatter</code>类是不可变的，也是<strong>线程安全</strong>的。</p>
<p>更多的细节，请看<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">这里</a></p>
<h3 id="Annotation">Annotation</h3>
<p>Java 8中的注解是可重复的。让我们直接深入看看例子，弄明白它是什么意思。<br>首先，我们定义一个包装注解，它包括了一个实际注解的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@interface</span> Hints {</div><div class="line">    Hint[] value();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@Repeatable</span>(Hints.class)</div><div class="line"><span class="annotation">@interface</span> Hint {</div><div class="line">    String value();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>只要在前面加上注解名：<code>@Repeatable</code>，Java 8 允许我们对同一类型使用多重注解，</p>
<h3 id="变体1：使用注解容器（老方法）">变体1：使用注解容器（老方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Hints</span>({<span class="annotation">@Hint</span>(<span class="string">"hint1"</span>), <span class="annotation">@Hint</span>(<span class="string">"hint2"</span>)})</div><div class="line">class Person {}</div></pre></td></tr></table></figure>

<h3 id="变体2：使用可重复注解（新方法）">变体2：使用可重复注解（新方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Hint</span>(<span class="string">"hint1"</span>)</div><div class="line"><span class="annotation">@Hint</span>(<span class="string">"hint2"</span>)</div><div class="line">class Person {}</div></pre></td></tr></table></figure>

<p>使用变体2，Java编译器能够在内部自动对@Hint进行设置。这对于通过反射来读取注解信息来说，是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hint hint = Person.class.getAnnotation(Hint.class);</div><div class="line">System.out.println(hint);                   <span class="comment">// null</span></div><div class="line"></div><div class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</div><div class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></div><div class="line"></div><div class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</div><div class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></div></pre></td></tr></table></figure>

<p>尽管我们绝对不会在<code>Person</code>类上声明<code>@Hints</code>注解，但是它的信息仍然可以通过<code>getAnnotation(Hints.class)</code>来读取。并且，g<code>etAnnotationsByType</code>方法会更方便，因为它赋予了所有<code>@Hints</code>注解标注的方法直接的访问权限。</p>
<p>此外， Java 8中的注解可以扩展到两个新的类型上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Target</span>({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})</div><div class="line"><span class="annotation">@interface</span> MyAnnotation {}</div></pre></td></tr></table></figure>

<h2 id="更多资源">更多资源</h2>
<p>我的Java 8编程指南就到此告一段落。如果你想了解JDK 8 API 所有的新增加的类和特性，可以查看我的<a href="http://winterbe.com/projects/java8-explorer/" target="_blank" rel="external">JDK8 API Explorer</a>, 它可以帮助你了解JDK 8的新增加的类和隐藏的精华。例如：<code>Arrays.parallelSort</code>, <code>StampedLock</code>和<code>CompletableFuture</code>等等 ———— 我这里只是举几个例子而已。</p>
<p>我也在博客上写了一些文章，你可能会感兴趣:</p>
<ul><li><a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="external">Java 8 Stream Tutorial</a></li><li><a href="http://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/" target="_blank" rel="external">Java 8 Nashorn Tutorial</a></li><li><a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="external">Java 8 Concurrency Tutorial: Threads and Executors</a></li><li><a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/" target="_blank" rel="external">Java 8 Concurrency Tutorial: Synchronization and Locks</a></li><li><a href="http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/" target="_blank" rel="external">Java 8 Concurrency Tutorial: Atomic Variables and ConcurrentMap</a></li><li><a href="http://winterbe.com/posts/2015/03/25/java8-examples-string-number-math-files/" target="_blank" rel="external">Java 8 API by Example: Strings, Numbers, Math and Files</a></li><li><a href="http://winterbe.com/posts/2015/03/15/avoid-null-checks-in-java/" target="_blank" rel="external">Avoid Null Checks in Java 8</a></li><li><a href="http://winterbe.com/posts/2015/03/05/fixing-java-8-stream-gotchas-with-intellij-idea/" target="_blank" rel="external">Fixing Java 8 Stream Gotchas with IntelliJ IDEA</a></li><li><a href="http://winterbe.com/posts/2014/04/07/using-backbonejs-with-nashorn/" target="_blank" rel="external">Using Backbone.js with Java 8 Nashorn</a></li></ul>

<p>你可以在Twitter上关注<a href="https://twitter.com/winterbe_" target="_blank" rel="external">我</a>。 感谢阅读。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是<a href="http://winterbe.com" target="_blank" rel="external">Benjamin Winterberg</a>写的英文教程<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">Modern Java - A Guide to Java 8</a>,最早发表于2014年三月，当时由 <a href="http://www.importnew.com/" target="_blank" rel="external">ImportNew</a> - <a href="http://www.importnew.com/author/huangxiaofei" target="_blank" rel="external">黄小非</a>翻译成中文: <a href="http://www.importnew.com/10360.html" target="_blank" rel="external">Java 8简明教程</a>。离原文初次发表已经快两年了，作者又陆陆续续提交多个commit，所以我根据原文以及黄小非的译文又做了修正。实际绝大部分的内容和小非翻译的一样，只有些许的变化。</p>
</blockquote>
<p><strong>Java并没有没落，人们开始认识到这一点</strong></p>
<p>欢迎阅读我编写的<a href="https://jdk8.java.net/" target="_blank" rel="external">Java 8</a>介绍。本教程将带领你一步步认识这门语言的所有新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和可重复注解。在这篇教程的最后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。<br><strong>没有大段的废话，只是一些带注释的代码片段，望君喜欢。</strong></p>
<p>本文最早发表在我的<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">博客</a>上。 你可以在Twitter上<a href="https://twitter.com/winterbe_" target="_blank" rel="external">加我</a>。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java RESTful框架的性能比较]]></title>
    <link href="http://colobu.com/2015/11/17/Jax-RS-Performance-Comparison/"/>
    <id>http://colobu.com/2015/11/17/Jax-RS-Performance-Comparison/</id>
    <published>2015-11-17T08:57:09.000Z</published>
    <updated>2015-11-18T08:26:08.799Z</updated>
    <content type="html"><![CDATA[<p>在微服务流行的今天，我们会从纵向和横向分解代码的逻辑，将一些独立的无状态的代码单元实现为微服务，可以将它们发布到一些分布式计算单元或者Docker中，并在性能需要的时候及时地创建更多的服务单元。<br>微服务是一个概念，并没有规定服务的格式，但是很多厂商和框架都不约而同的采用RESTful的架构,尽管也有一些其它的性能很好的RPC框架。<br>如何在Java生态圈选择一个轻量级的RESTful框架？可以参考一些其他人的经验， 比如我翻译的: <a href="http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">最好的8个 Java RESTful 框架</a>。<br>就我个人而言，我选择框架的理由很简单：</p>
<ul>
<li>简单，轻量级</li>
<li>性能好</li>
<li>稳定，可靠</li>
<li>易于开发和维护</li>
</ul>
<p>我会首选遵循Java规范(<a href="https://jcp.org/en/jsr/detail?id=339" target="_blank" rel="external">JSR339</a>)的框架，轻量级，便于发布到Docker容器中。 所以我不会选择Spring boot, Spring MVC, CXF等比较重的框架,也不会选择纯netty这样的太过底层，还得实现路由等基本功能框架。<br>因为追求轻量级，便于发布到docker容器中，我也不会考察JBOSS, Tomcat这样的JEE容器， 而是选用jetty, undertow这样的嵌入式容器。</p>
<p>所以，这里我挑选了几个候选者：</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Grizzly</a></li>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty</a></li>
<li><a href="http://www.dropwizard.io" target="_blank" rel="external">Dropwizard</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Netty</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Undertow</a></li>
</ol>
<p><strong>[Updated on 2015/11/18]</strong><br>我增加了更多的 RESTful 框架,有些不是Jax-RS的实现，但是也有很活跃的社区。</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty4</a></li>
<li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a></li>
<li><a href="http://netty.io/" target="_blank" rel="external">纯Netty</a></li>
<li><a href="http://vertx.io/" target="_blank" rel="external">Vert.x</a><br>你会发现一些有趣的测试结果。</li>
</ol>
<p>Jersey 是Jax-RS的官方参考实现，可以很好的和其它JEE容器集成。RESTEasy是JBoss出品的框架，也很容易的和其它容器集成。Dropwizard实际上集成了Jersey, Jetty以及其它的第三方库比如它的Metrics，提供了一站式的开发，略微有些厚重。</p>
<p>测试相关的代码已经放在了GITHUB上： <a href="https://github.com/smallnest/Jax-RS-Performance-Comparison" target="_blank" rel="external">代码</a><br><a id="more"></a></p>
<h3 id="编译代码">编译代码</h3>
<p>测试代码是一个多模块的Maven项目， 你直接运行<code>maven clean package</code>就可以生成各个jar,而且这些jar包含了所依赖的类，执行起来相当简单。<br>你也可以在每个模块下运行<code>mvn exec:java</code>启动服务，然后在浏览器中访问 <a href="http://localhost:8080/rest/hello" target="_blank" rel="external">http://localhost:8080/rest/hello</a> (对于Jersey + Jetty,地址是<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>)</p>
<h3 id="测试环境">测试环境</h3>
<p><strong>服务器</strong><br>AWS C3.2xlarge</p>
<ul>
<li>8 cores (E5-2666 v3 @ 2.90GHz)</li>
<li>memory: 16G (服务只分配了4G内存)</li>
</ul>
<p><strong>Java</strong><br>1.8.0_51</p>
<p><strong>测试工具</strong><br><a href="https://github.com/wg/wrk" target="_blank" rel="external">wrk</a><br>测试命令如: <code>wrk -t16 -c1000 -d30s http://127.0.0.1:8080/rest/hello</code>.<br>针对每个case, 我使用16个线程，以及100/200/500/1000并发进行测试。</p>
<p><strong>服务启动命令</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="title">java</span> -Xmx4g -Xms4g -jar jersey-grizzly2-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar jersey-jetty-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar dropwizard-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar hello.yml </div><div class="line">java -Xmx4g -Xms4g -jar resteasy-netty-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar </div><div class="line">java -Xmx4g -Xms4g -jar resteasy-undertow-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar springboot-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar resteasy-netty4-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar </div><div class="line">java -Xmx4g -Xms4g -jar nativenetty-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div><div class="line">java -Xmx4g -Xms4g -jar vertx-<span class="number">1</span>.<span class="number">0</span>-SNAPSHOT.jar</div></pre></td></tr></table></figure>

<h3 id="测试结果">测试结果</h3>
<p>测试结果数据可以查看这里： <a href="Jax-RS-Performance-Comparison">测试数据</a>,<br>延迟基本在几毫秒到10几毫秒之间。</p>
<p>图形化测试结果(y轴为Requests/sec, x轴为并发量)：<br><img src="performance.png" alt=""></p>
<h3 id="结论">结论</h3>
<p>从结果看，</p>
<ul>
<li>RESTEasy的性能要好于 Jersey,无论哪种嵌入式JEE容器。</li>
<li>Jersey+Grizzly2和Jersey+Jetty, dropwizard性能差别不大</li>
<li>dropwizard底层实际是Jersey+Jetty,性能结果也和Jersey+Jetty一样</li>
<li>RESTEasy+netty (netty3)的结果并没有优于RESTEasy+undertow.这出乎我的意料，可能CPU和Memory占用上会好一些</li>
<li>RESTEasy+netty4的性能远远低于RESTEasy+netty3，这出乎我的意料。或许因为Netty线程池的改变。</li>
<li>纯netty的性能远远高于其它框架，一方面是由于没有http router的逻辑，另一方面也显示了Netty框架的优秀。如果不是实现很复杂的路由和很多的Service,不妨使用纯Netty实现高性能。</li>
<li>Spring Boot太厚重了，使用Spring MVC的语法，性能只有Jersey的一半。</li>
<li>Vert.x底层使用Netty,可以使用Java 8 Lambda语法，也提供了其它语言的支持，但是性能看起来不是太好，而且随着并发量增大吞吐率也随之下降。</li>
</ul>
<p>当然测试也有一点遗憾，就是没有记录测试时的CPU占用率和Memory占用率，以我个人的经验，这方面Netty会占一些优势。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在微服务流行的今天，我们会从纵向和横向分解代码的逻辑，将一些独立的无状态的代码单元实现为微服务，可以将它们发布到一些分布式计算单元或者Docker中，并在性能需要的时候及时地创建更多的服务单元。<br>微服务是一个概念，并没有规定服务的格式，但是很多厂商和框架都不约而同的采用RESTful的架构,尽管也有一些其它的性能很好的RPC框架。<br>如何在Java生态圈选择一个轻量级的RESTful框架？可以参考一些其他人的经验， 比如我翻译的: <a href="http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">最好的8个 Java RESTful 框架</a>。<br>就我个人而言，我选择框架的理由很简单：</p>
<ul>
<li>简单，轻量级</li>
<li>性能好</li>
<li>稳定，可靠</li>
<li>易于开发和维护</li>
</ul>
<p>我会首选遵循Java规范(<a href="https://jcp.org/en/jsr/detail?id=339" target="_blank" rel="external">JSR339</a>)的框架，轻量级，便于发布到Docker容器中。 所以我不会选择Spring boot, Spring MVC, CXF等比较重的框架,也不会选择纯netty这样的太过底层，还得实现路由等基本功能框架。<br>因为追求轻量级，便于发布到docker容器中，我也不会考察JBOSS, Tomcat这样的JEE容器， 而是选用jetty, undertow这样的嵌入式容器。</p>
<p>所以，这里我挑选了几个候选者：</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Grizzly</a></li>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty</a></li>
<li><a href="http://www.dropwizard.io" target="_blank" rel="external">Dropwizard</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Netty</a></li>
<li><a href="http://resteasy.jboss.org/" target="_blank" rel="external">RESTEasy + Undertow</a></li>
</ol>
<p><strong>[Updated on 2015/11/18]</strong><br>我增加了更多的 RESTful 框架,有些不是Jax-RS的实现，但是也有很活跃的社区。</p>
<ol>
<li><a href="https://jersey.java.net/" target="_blank" rel="external">Jersey + Jetty4</a></li>
<li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a></li>
<li><a href="http://netty.io/" target="_blank" rel="external">纯Netty</a></li>
<li><a href="http://vertx.io/" target="_blank" rel="external">Vert.x</a><br>你会发现一些有趣的测试结果。</li>
</ol>
<p>Jersey 是Jax-RS的官方参考实现，可以很好的和其它JEE容器集成。RESTEasy是JBoss出品的框架，也很容易的和其它容器集成。Dropwizard实际上集成了Jersey, Jetty以及其它的第三方库比如它的Metrics，提供了一站式的开发，略微有些厚重。</p>
<p>测试相关的代码已经放在了GITHUB上： <a href="https://github.com/smallnest/Jax-RS-Performance-Comparison" target="_blank" rel="external">代码</a><br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最好的8个 Java RESTful 框架]]></title>
    <link href="http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/"/>
    <id>http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/</id>
    <published>2015-11-15T05:03:22.000Z</published>
    <updated>2015-11-18T02:53:34.362Z</updated>
    <content type="html"><![CDATA[<p>原文： <a href="http://www.gajotres.net/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">Top 8 Java RESTful Micro Frameworks</a><br>过去的每一年，涌现出越来越多的Java框架。就像JavaScript，每个人都认为他们知道一个好的框架的功能应该是怎么样的。连我的老祖母现在也使用一个我从来没有听说过而且可能永远不会使用的框架。玩笑归玩笑，可以做几乎任何事的臃肿的框架市场已经饱和，，但是如何评判呢?</p>
<p>这篇文章旨在提供目前最好的 Java RESTfulful 框架。我只介绍轻量级的产品， 略过了那些臃肿的过度设计的框架。同时，我只想要他们稳定和成熟，提供简单，轻量级的特点。我只在介绍Play frameworks时打破这条规则，理由稍后给出。</p>
<p>在将来的项目中使用哪个 Java RESTful框架完全取决于你当前的需求。为了便于你取舍，我将列出最突出的框架功能,希望这能节省一些你的时间。</p>
<a id="more"></a>
<h3 id="Dropwizard">Dropwizard</h3>
<p>诞生时间: 2011<br>评分: 4.5/5</p>
<p>Dropwizard 提供了稳定成熟的Java库， 并封装成一个简单的轻量级的包。<br>Dropwizard 介于框架和库之间。它提供了一个开发web应用程序的全部所需。由于内置模块化，一个应用程序可以保持小而精干的特点，减少开发和维护的时间，减少负担。<br>Dropwizard 使用已有的 Jetty HTTP 库，嵌入到你的项目中，无需外部的server。所有的Dropwizard项目都有一个 main 方法来管理内建的 HTTP server. </p>
<p><strong>链接</strong><br><a href="http://www.dropwizard.io/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/dropwizard/dropwizard" target="_blank" rel="external">GITHUB</a> <a href="http://www.dropwizard.io/getting-started.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快速的项目构建和启动</li>
<li>模块化</li>
<li>不可思议的快(至少根据内建的 metric 测得的结果)</li>
<li>Jetty for HTTP, Jersey for REST, 以及 Jackson for JSON</li>
<li>也支持其它的库， 比如 Mustache, Logback, JDBI, Hibernate Validator, Guava, …</li>
<li>使用Metrics支持监控</li>
<li>Main方法启动 Jetty server，可以容易地调试和维护</li>
<li>社区力度强</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>Dropwizard文档是主要的知识来源，但谈不上优秀。你可能需要搜索和发掘第三方类库的文档。</li>
<li>因为某些原因错误被当作普通文本, 如果你希望响应结果总是JSON，这可能有问题</li>
<li>确保使用最新的Dropwizard， 一些老版本使用了废弃的第三方库。 而且早期的Dropwizzard也很难升级</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.helloworld;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> io.dropwizard.Application;</div><div class="line"><span class="keyword">import</span> io.dropwizard.setup.Bootstrap;</div><div class="line"><span class="keyword">import</span> io.dropwizard.setup.Environment;</div><div class="line"><span class="keyword">import</span> com.example.helloworld.resources.HelloWorldResource;</div><div class="line"><span class="keyword">import</span> com.example.helloworld.health.TemplateHealthCheck;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HelloWorldConfiguration</span>&gt; </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="keyword">new</span> HelloWorldApplication().run(args);</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">getName</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello-world"</span>;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span>(Bootstrap&lt;HelloWorldConfiguration&gt; bootstrap) {</div><div class="line">        <span class="comment">// nothing to do yet</span></div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(HelloWorldConfiguration configuration,</div><div class="line">                    Environment environment) {</div><div class="line">        <span class="comment">// nothing to do yet</span></div><div class="line">    }</div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>个人不想为大的项目推荐这个框架。不过如果你想尝试的话，你不会失望的。主要是这个框架使用最好的现代的Java web 组件，组装成一个简单易用的框架。<br>不幸的是这也带来了它的问题。 将这些库糅合起来可能导致不可预见的问题。这也是我为什么给它减掉0.5颗星，而没有评为满分5颗星。</p>
<h3 id="Jersey">Jersey</h3>
<p>诞生时间: 2012 (Jersey 2.X)<br>评分: 5/5</p>
<p>Jersey RESTful 框架是开源的RESTful框架, 实现了JAX-RS (JSR 311 &amp; JSR 339) 规范。它扩展了JAX-RS 参考实现， 提供了更多的特性和工具， 可以进一步地简化 RESTful service 和 client 开发。尽管相对年轻，它已经是一个产品级的 RESTful service 和 client 框架。</p>
<p><strong>链接</strong><br><a href="https://jersey.java.net/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/jersey/jersey" target="_blank" rel="external">GITHUB</a> <a href="https://jersey.java.net/documentation/latest/index.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>优秀的文档和例子</li>
<li>快速</li>
<li>超级容易的路由</li>
<li>平滑的 JUnit 集成</li>
<li>就个人而言, 当开发 RESTful service 时, JAX-RS 实现要好于 MVC 框架。</li>
<li>可以集成到其它库/框架 (Grizzly, Netty). 这也可能是很多产品使用它的原因。</li>
<li>支持异步链接</li>
<li>不喜欢 servlet container? 使用Jersey的时候可以不用它们。</li>
<li>WADL, XML/JSON support</li>
<li>包含在Glassfish中</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>Jersey 2.0+使用了有些复杂的依赖注入实现</li>
<li>可能不是一件坏事。Jersey 1.X 使用较老的 JAX-RS 实现</li>
<li>一大堆第三方库只支持 Jersey 1.X， 在 Jersey 2.X 不可用</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.glassfish.jersey.examples.helloworld;</div><div class="line">  </div><div class="line"><span class="keyword">import</span> javax.ws.rs.GET;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.Path;</div><div class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</div><div class="line">  </div><div class="line"><span class="annotation">@Path</span>(<span class="string">"helloworld"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldResource</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLICHED_MESSAGE = <span class="string">"Hello World!"</span>;</div><div class="line">  </div><div class="line"><span class="annotation">@GET</span></div><div class="line"><span class="annotation">@Produces</span>(<span class="string">"text/plain"</span>)</div><div class="line">    <span class="keyword">public</span> String <span class="title">getHello</span>() {</div><div class="line">        <span class="keyword">return</span> CLICHED_MESSAGE;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>Jersey 是我的选择， 5颗星。</p>
<h3 id="Ninja_Web_Framework">Ninja Web Framework</h3>
<p>诞生时间: 2012<br>评分: 3.5/5<br>Ninja Web Framework是全栈的 java web framework。稳定, 快速, 可靠, 产品级.<br>它提供了开发，测试，发布，维护 RESTful web应用的一切(Servlets, Guice, JPA, Flyway migrations, Maven, etc.).<br>就像 DropWizzard, Ninja Web Framework 是一个集成的软件栈。你不必建立你自己的，只需使用 Maven archetype生成一个新的项目，导入到IDE中就可以开始编码了。</p>
<p><strong>链接</strong><br><a href="http://www.ninjaframework.org/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/ninjaframework/ninja" target="_blank" rel="external">GITHUB</a> <a href="http://www.ninjaframework.org/documentation/getting_started/installing_ninja.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快</li>
<li>快速的项目构建和启动</li>
<li>模块化</li>
<li>XML, HTML, JSON渲染</li>
<li>也支持其它的库 (如 Guice, Logback, Guava, etc.)</li>
<li>很好的数据持久化和缓存</li>
<li>不喜欢 servlet container? U可以选择你喜欢的容器</li>
<li>如果根本就不喜欢容器，可以使用 standalone 模式, 使用Jetty作为一个自执行的jar</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>同样，就像DropWizzard, 文档有但是不够好。我花了好长时间去了解它。这个框架也依赖很多其它的库，有时候想得到所需的信息很麻烦。</li>
<li>不怎么出名，社区小。 有谣言说这个框架是由那些切换到Scala的 Play 2.X 用户创建的</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationController</span> </span>{       </div><div class="line"> </div><div class="line">    <span class="keyword">public</span> Result <span class="title">index</span>() {</div><div class="line"> </div><div class="line">        Person person = <span class="keyword">new</span> Person();</div><div class="line">        person.name = <span class="string">"John Johnson"</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> Results.json().render(person);</div><div class="line"> </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>看起来不错，但是在它成熟之前我还是把它丢在一边吧。</p>
<h3 id="Play_Framework">Play Framework</h3>
<p>诞生时间: 2011<br>评分: 4/5 </p>
<p>使用Play Framework 很容易地创建，构建和发布 web 应用程序，支持 Java &amp; Scala。它使用Akka, 基于一个轻量级的无状态的架构。它应该应用于大规模地低CPU和内存消耗的应用。</p>
<p><strong>链接</strong><br><a href="https://www.playframework.com/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/playframework/playframework" target="_blank" rel="external">GITHUB</a> <a href="https://www.playframework.com/documentation/2.4.x/Home" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>易于开发</li>
<li>快，但是没有其它的一些框架快</li>
<li>基于 Netty, 支持非阻塞的 I/O. 并行处理远程调用的时候很优秀</li>
<li>社区很大</li>
<li>快速的项目构建和启动</li>
<li>模块化</li>
<li><strong>MVC</strong></li>
<li>REST, JSON/XML, Web Sockets, non-blocking I/O</li>
<li>只需刷新浏览器就可以看到最新的改变</li>
<li>支持Async</li>
<li>有出版的书</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>版本2.0 是最有争议的Java框架。 切换至Switch to Scala made some Java developers outraged.</li>
<li>不向后兼容; Play 2.X 重写了</li>
<li>号称轻量级，但有些臃肿</li>
<li>SBT构建工具. 号称 Maven 杀手, 但是从没有优秀到替换它。难以学习和配置</li>
<li>非 servlet</li>
<li>Breaking changes across releases</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> controllers</div><div class="line"> </div><div class="line"><span class="keyword">import</span> play.api._</div><div class="line"><span class="keyword">import</span> play.api.mvc._</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>{</div><div class="line"> </div><div class="line">  <span class="keyword">def</span> hello(name: String) = Action {</div><div class="line">    Ok(<span class="string">"Hello "</span> + name + <span class="string">"!"</span>)</div><div class="line">  }</div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>抱怨归抱怨，我还是一直喜欢和首选这个框架。不幸的是，我只能给它4颗星。我坚信 基于JAX-RS的框架更适合 RESTful web services.</p>
<h3 id="RestExpress">RestExpress</h3>
<p>诞生时间: 2009<br>评分: 3/5 </p>
<p>RestExpress是一个非容器的轻量级的 Netty HTTP栈的包装， 以便更容易地创建 Java RESTful services.<br>RestExpress 目标是支持最好的 RESTful 实践。</p>
<p><strong>链接</strong><br><a href="https://github.com/RestExpress/RestExpress" target="_blank" rel="external">GITHUB</a></p>
<p><strong>优点</strong></p>
<ul>
<li>真正的微框架</li>
<li>顶级的性能，快，可靠</li>
<li>XML/JSON</li>
<li>最老的也是最稳定的 RESTful 框架之一</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>没有文档</li>
<li>几乎没有支持</li>
<li>很小的社区    </li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpMethod;</div><div class="line"><span class="keyword">import</span> org.restexpress.RestExpress;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></div><div class="line">{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RestExpress <span class="title">startServer</span>(String[] args) <span class="keyword">throws</span> IOException</div><div class="line">    {</div><div class="line">        RestExpress server = <span class="keyword">new</span> RestExpress();</div><div class="line">        MyResource r = <span class="keyword">new</span> MyResource();</div><div class="line"> </div><div class="line">        server.uri(<span class="string">"/myapp/myresource"</span>, r)</div><div class="line">            .method(HttpMethod.GET)</div><div class="line">            .noSerialization();</div><div class="line"> </div><div class="line">        server.uri(<span class="string">"/myapp/myresource"</span>, r)</div><div class="line">            .method(HttpMethod.POST);</div><div class="line"> </div><div class="line">        server.bind(<span class="number">8080</span>);</div><div class="line">        <span class="keyword">return</span> server;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        RestExpress server = startServer(args);</div><div class="line">        System.out.println(<span class="string">"Hit enter to stop it..."</span>);</div><div class="line">        System.in.read();</div><div class="line">        server.shutdown();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>尽管这个框架超级快，我也不想推荐它。文档缺乏以及没有支持使它成为一个欠佳的框架。看在速度的份上给它3颗星。</p>
<h3 id="Restlet">Restlet</h3>
<p>诞生时间: 2005<br>评分: 4.5/5</p>
<p>Restlet 帮助Java程序员建立大规模的快速的符合 RESTful 架构模式的web api。<br>它提供了强大的路由和filtering 系统。统一的client/server Java API. 满足所有主要的平台 (Java SE/EE, Google AppEngine, OSGi, GWT, Android) 以及提供了无数的扩展以满足程序员的需求。<br>据我说知，它是第一个 java RESTful web 框架。很多公司都在用它，但是你可能从未听说过它，好像它已经不可见了。</p>
<p><strong>链接</strong><br><a href="http://restlet.com/products/restlet-framework/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/restlet/restlet-framework-java" target="_blank" rel="external">GITHUB</a> <a href="http://restlet.com/products/restlet-framework/" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>强大</li>
<li>企业级的框架</li>
<li>多平台 Java SE, Java EE, Google Web Toolkit, Google AppEngine, Android, OSGi environments</li>
<li>支持JAX-RS (就像 Jersey)</li>
<li>大部分高级 RESTful 支持</li>
<li>模块化</li>
<li>支持其它库</li>
<li>开发一直活跃</li>
<li>智能的url绑定， 全功能的 URI 路由</li>
<li>有相关的书籍</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>非常陡峭的学习曲线</li>
<li>关闭的社区，尽管 StackOverflow 上还是开放的</li>
<li>不再流行，更多的是因为 Play Framework 和 Jersey</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Part03</span> <span class="keyword">extends</span> <span class="title">ServerResource</span> </span>{</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="comment">// Create the HTTP server and listen on port 8182</span></div><div class="line">        <span class="keyword">new</span> Server(Protocol.HTTP, <span class="number">8182</span>, Part03.class).start();</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Get</span>(<span class="string">"txt"</span>)</div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello, world"</span>;</div><div class="line">    }</div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>尽管这个框架还一直流行，考虑到它的年纪和当前的完成度，我不能给它5颗星。</p>
<h3 id="Restx">Restx</h3>
<p>诞生时间: 2013<br>评分: 3.5/5 </p>
<p>Restx 是一个轻量级的,模块化的,特性众多的，超快的开源 Java REST 框架。</p>
<p><strong>链接</strong><br><a href="http://restx.io/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/restx/restx" target="_blank" rel="external">GITHUB</a> <a href="http://restx.io/docs/" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快速，轻量级</li>
<li>容易搭建</li>
<li>真正的微框架</li>
<li>模块化</li>
<li>支持其它库</li>
<li>支持MongoDB</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不友好的令人迷惑的文档。对于这类框架我期望能有好一点的文档</li>
<li>太年轻</li>
<li>目前还不支持异步Async</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@GET</span>(<span class="string">"/message/{id}"</span>)</div><div class="line">    <span class="keyword">public</span> Message <span class="title">sayHello</span>(String id, // path param</div><div class="line">                            String who // query param</div><div class="line">                            ) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message().setMessage(String.format(</div><div class="line">                <span class="string">"hello %s, it's %s"</span>,</div><div class="line">                who, DateTime.now().toString(<span class="string">"HH:mm:ss"</span>)));</div><div class="line">    }</div><div class="line"><span class="annotation">@POST</span>(<span class="string">"/message/{id}"</span>)</div><div class="line">    <span class="keyword">public</span> Message <span class="title">sayHello</span>(String id, // path param</div><div class="line">                            Message msg // body param</div><div class="line">                            ) {</div><div class="line">        <span class="keyword">return</span> msg.setMessage(String.format(</div><div class="line">                <span class="string">"%s @ %s"</span>,</div><div class="line">                msg.getMessage(), DateTime.now().toString(<span class="string">"HH:mm:ss"</span>)));</div><div class="line">    }</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>真心来讲我没有在这个框架上花费太多时间。不值得在另一个框架上花费太多精力，我意思是说，Java框架市场已经越来越碎片化了，就像 JavaScript 市场，应该停止这种趋势了。</p>
<h3 id="Spark_Framework">Spark Framework</h3>
<p>诞生时间: 2011<br>评分: 3.5/5<br>不要和 Apache 的大数据框架 Spark 弄混, 这里的 Spark 框架是一个轻量级的 Java web 框架，用来进行快速的开发(50% Spark用户使用 Spark 创建 REST APIs)。 它受 Ruby 框架 Sinatra 启发。</p>
<p>它有一个不到1M的最小化的内核， 提供了所有基本的特性, 用来构建 RESTful 或者传统的 web 应用程序。</p>
<p><strong>链接</strong><br><a href="http://sparkjava.com/" target="_blank" rel="external">官方站点</a> <a href="https://github.com/perwendel/spark" target="_blank" rel="external">GITHUB</a> <a href="http://sparkjava.com/documentation.html" target="_blank" rel="external">文档</a></p>
<p><strong>优点</strong></p>
<ul>
<li>快，轻量级</li>
<li>优秀的快速原型</li>
<li>易于搭建</li>
<li>经常和AngularJS搭配使用</li>
<li>真正的微框架</li>
<li>使用 Jetty</li>
<li>可以用在容器中或者独立运行</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>文档可以更好，它不适合初学者</li>
<li>不适合大型项目</li>
<li>社区小</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> spark.Spark.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">      get(<span class="string">"/hello"</span>, (req, res) -&gt; <span class="string">"Hello World"</span>);</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>注解</strong><br>这个框架适合初始开发。主要用作小小项目或者原型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文： <a href="http://www.gajotres.net/best-available-java-restful-micro-frameworks/" target="_blank" rel="external">Top 8 Java RESTful Micro Frameworks</a><br>过去的每一年，涌现出越来越多的Java框架。就像JavaScript，每个人都认为他们知道一个好的框架的功能应该是怎么样的。连我的老祖母现在也使用一个我从来没有听说过而且可能永远不会使用的框架。玩笑归玩笑，可以做几乎任何事的臃肿的框架市场已经饱和，，但是如何评判呢?</p>
<p>这篇文章旨在提供目前最好的 Java RESTfulful 框架。我只介绍轻量级的产品， 略过了那些臃肿的过度设计的框架。同时，我只想要他们稳定和成熟，提供简单，轻量级的特点。我只在介绍Play frameworks时打破这条规则，理由稍后给出。</p>
<p>在将来的项目中使用哪个 Java RESTful框架完全取决于你当前的需求。为了便于你取舍，我将列出最突出的框架功能,希望这能节省一些你的时间。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[uriDB网站的可扩展的技术栈]]></title>
    <link href="http://colobu.com/2015/11/09/The-Stack-of-uriDB/"/>
    <id>http://colobu.com/2015/11/09/The-Stack-of-uriDB/</id>
    <published>2015-11-09T04:43:00.000Z</published>
    <updated>2015-11-10T07:11:10.478Z</updated>
    <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB</a>本身不生产干货，<a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>网站只是大自然的搬运工。<br>自<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>诞生依赖，已经有多个中文技术头条的网站了，比如<a href="http://toutiao.io/" target="_blank" rel="external">开发者头条</a>和<a href="http://geek.csdn.net/hotest" target="_blank" rel="external">极客头条</a>，为什么还要做这样一个雷同的头条网站呢？</p>
<p>有两个原因：<br>一是我想做一个分类头条的网站，按照技术领域对文章进行分类，这样只对前端感兴趣的同学可以只跟踪最新的前端文章。 同时uriDB只会筛选最新的技术干货，不会将问答，闲聊等技术层次低的文章收录。<br>二是这么多年来，我涉及的领域包括后台，大数据，前端和移动端的技术也是我感兴趣的领域。心中那份对技术的持久的热情，促使我将多年的技术积累以某种具体的形式呈现出来，籍此展示并能持久的进行技术架构的演化。</p>
<p>因此，uriDB技术流网站也就孵化出来了。虽然目前的访问量比较少，但是看的用户数和访问量在逐步的提升，也是一件令人欣慰的事。至少，这个网站收集的干货也为那些执着学习的同学带来些许的便利和技能提升。</p>
<p>与其说<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>类似<em>Hacker News</em>网站， 还不说说它类似<a href="http://toutiao.com/" target="_blank" rel="external">今日头条</a>， 只不是今日头条上全是新闻类的内容，而<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>上全是技术干货。今日头条会将目标网站上的内容抓去过来进行重新排版，更加适合阅读。我也抓去了目标文章的内容，却没有进行重新排版显示，主要是考虑到了版权的问题，还是老老实实的做<em>Hacker News</em>一样的转发。</p>
<p>这个网站是2015年国庆节期间开始启动的，也是作为我的side project在维护。我会时不时的将我的新的想法，技术灵感应用于这个网站上。<br><img src="/2015/11/09/The-Stack-of-uriDB/uridb.png" alt=""><br><a id="more"></a></p>
<h3 id="产品部署环境">产品部署环境</h3>
<h4 id="云主机">云主机</h4>
<p>国内的云服务器包括：<a href="http://www.aliyun.com/" target="_blank" rel="external">阿里云</a> <a href="http://www.qcloud.com/" target="_blank" rel="external">腾讯云</a> <a href="https://mos.meituan.com/" target="_blank" rel="external">美团云</a> <a href="http://www.qingcloud.com/" target="_blank" rel="external">青云</a> <a href="http://www.hwclouds.com/" target="_blank" rel="external">华为云</a> <a href="http://www.ctyun.cn/" target="_blank" rel="external">天翼云</a> <a href="http://www.west263.com/" target="_blank" rel="external">西部数码</a> <a href="http://www.linkcloud.cn/" target="_blank" rel="external">Linkcloud</a><br>国外的如 <a href="http://aws.amazon.com/" target="_blank" rel="external">AWS</a> <a href="http://www.windowsazure.com/" target="_blank" rel="external">Azure</a> <a href="https://www.digitalocean.com/" target="_blank" rel="external">Digital Ocean</a> <a href="https://www.linode.com/" target="_blank" rel="external">linnode</a></p>
<p>云服务器之间的比较大家可以具体的搜索。<br>我使用 <a href="https://www.digitalocean.com/?refcode=67c9dbb27bb2" target="_blank" rel="external">DigitalOcean</a>的云主机作为服务器， 主要考虑价格便宜，而是使用ssd作硬盘，速度好，可以选用新加坡的机房。</p>
<h4 id="负载均衡">负载均衡</h4>
<p>使用CentOS 7.1做所有的节点的操作系统。<br>nginx 1.8.0作为负载均衡。为了实现高可用性，采用keepalived实现， 比如文章<a href="http://www.tokiwinter.com/building-a-highly-available-load-balancer-with-nginx-and-keepalived-on-centos/" target="_blank" rel="external">Building a Highly-Available Load Balancer with Nginx and Keepalived on CentOS</a>。这样当一台Load balancer宕机的时候，它的功能转移到另外一台Load balancer上。</p>
<p>Keepalived的作用是检测服务器的健康状态，在所有可能出现单点故障的地方为其提供高可用。如果有一台服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。keepalived的核心是vrrp，它是通过脚本来调用服务的，所以在keepalived的使用中，仅需关心两点：配置文件（/etc/keepalived/keepalived.conf）和服务脚本（/etc/rc.d/init.d/keepalived）</p>
<p>N年前我在Motorola工作的时候，使用的是一个商业的高可用方案，后来基于HAProxy+keepalived方式实现高可用，应用于视频节目的播放产品中。这里我们使用Nginx作为负载均衡器，所以配置Nginx+Keepalived作为双主高可用负载均衡器。</p>
<p>参考文档中列出了此方案的配置方法的一些介绍文章，文档内容基本类似，读者可以选择查看。<br>商业版的NGINX Plus提供了Keepalived的集成。</p>
<p>国内厂商使用 <a href="http://tengine.taobao.org/" target="_blank" rel="external">Tengine</a>也不少，配置keepalived一样。</p>
<p>使用Golang开发了整个服务器后台程序和爬虫。自2000年开始我用.NET做了三年的开发，2003年以后一致用Java做开发，2015年使用Scala做大数据和高性能服务器的开发。所以最熟悉的开发语言还是Java和Scala。<br>但是，我想挑战一下自己。Scala代码的优雅(这里指代码本身，不谈论性能等其它方面)，面向对象和函数式编程是我的思维得到了极大的扩展。通过对Go语言的学习，我也深深被它的简洁和编译的本地代码所吸引，所以业余将主要精力放在了Go语言的学习和实践上，也尝试为开源项目提供<a href="https://github.com/parnurzeal/gorequest/graphs/contributors" target="_blank" rel="external">贡献</a>。</p>
<p>虽然Java生态圈的库和框架多如牛毛，Go相关的高质量库也不断的涌现。Go在中国也相当的<a href="http://herman.asia/why-is-go-popular-in-china" target="_blank" rel="external">火</a>,国内的一些厂商也在应用Golang,如七牛，360等。本身我对Go实现一个高性能的服务器架构不持怀疑态度。</p>
<p>上面一句话是假的。既然决定采用Go作为主开发语言，必然在选型的时候做一些性能的测试。实际的测试结果也表明Go的性能不错。尽管<a href="http://colobu.com/2015/04/24/Web-Frameworks-Benchmark-2015/" target="_blank" rel="external">Web Frameworks Benchmark 2015</a>的测试中Go排名19，低于Java实现的Netty,undertow,Servlet, C++/C的实现等，我还是觉得Go的潜力无限。</p>
<p>另一个值得关注的语言是Mozilla主导的<a href="https://www.rust-lang.org/" target="_blank" rel="external">rust</a>，但是能否成气候还有待观察。</p>
<h3 id="前端">前端</h3>
<p>网站的前端主要采用当前流行的<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="external">单页程序</a>设计。采用AJAX进行数据的拉取。<br>2014年在Thistech主要采用<a href="http://emberjs.com/" target="_blank" rel="external">ember.js</a>进行开发，积累了一些前端框架经验，所以对ember.js的评价有好有坏。考虑到uriDB网站的形式，动态交互的逻辑不多(搜索，加载)，没必要重度使用前端框架如AngularJS, Ember.js, Backbone.js等。</p>
<p>所以最后使用jquery的ajax调用访问服务器的Restful API，以及jquery相关的插件。<br>前端的css框架采用定制的bootstrap，主要以红色色调为主，因为快到冬天了，红红火火，比较温暖，而没有采用蓝色系，尽管蓝色系的bootstrap也准备好了。</p>
<p>尽然通过jquery动态加载数据，页面基本上就是一个模版，这样动静分离，可以将静态页面cache住，减少服务器的压力。<br>相关的javascript和css进行了合并，并且进行了压缩。<br>在nginx出配置了gzip特性，超过1k的响应会被压缩。<br>将js,css,图片分流到另外一个域名上 <a href="http://static.uridb.com。" target="_blank" rel="external">http://static.uridb.com。</a><br>前端的图片采用动态加载的方式，只有滚动到显示时才进行加载，从而避免页面加载时间过长。</p>
<p>更多的前端优化请参看: <a href="http://colobu.com/2015/10/30/h5-performance/" target="_blank" rel="external">前端性能优化指南</a></p>
<h3 id="爬虫">爬虫</h3>
<p>爬虫运行在单独的服务器上，它会定时的到指定网站抓取最新的文章列表，这里对网站的请求使用了我的一个开源项目: <a href="https://github.com/smallnest/goreq" target="_blank" rel="external">goreq</a>，它简化了http client的操作。<br>它基于<a href="http://www.rssboard.org/" target="_blank" rel="external">RSS</a>或者<a href="https://github.com/PuerkitoBio/goquery" target="_blank" rel="external">goquery</a>进行分析列表，得到候选文章。<br>但是不止于此，它还会基于候选文章列表访问每个抓取的文章，获取文章的元数据和正文。<br>基于这些信息，它会生成文章的元数据，并进行自动化的分类。<br>当前的分类还是一个简单的根据关键词的分类，所以有时候会造成误判， 比如一篇《Go, Go, GO,让我们开始用Java编程》可能会被分类成Golang文章，尽管它属于Java栏目的。</p>
<p>爬虫应该能处理超时以及意外情况(不规整的html)，我们可以容忍一条文章的损失，但是必须保证整个爬虫程序不会垮掉。</p>
<p>充分利用Go interface，我们实现了简洁的爬虫程序，并且可以很方便的添加新的网站源。</p>
<p>通过crontab进行抓取，每天会抓取几次，每次的抓取时间少于10分钟。</p>
<h3 id="后台">后台</h3>
<p>使用<a href="https://github.com/go-zoo/bone" target="_blank" rel="external">bone</a>作为http Multiplexer，而没有采用其它流行的Go web框架如: <a href="http://www.gorillatoolkit.org/" target="_blank" rel="external">Gorilla</a>, 谢工的<a href="http://beego.me/" target="_blank" rel="external">Beego</a>等，主要还是考虑到简单和性能。<br>依照bone官方的测试：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> <span class="constant">BenchmarkBoneMux</span>        <span class="number">10000000</span>               <span class="number">118</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkZeusMux</span>          <span class="number">100000</span>               <span class="number">144</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkHttpRouterMux</span>  <span class="number">10000000</span>               <span class="number">134</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkNetHttpMux</span>      <span class="number">3000000</span>               <span class="number">580</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkGorillaMux</span>       <span class="number">300000</span>              <span class="number">3333</span> ns/op</span></div><div class="line">-<span class="ruby"> <span class="constant">BenchmarkGorillaPatMux</span>   <span class="number">1000000</span>              <span class="number">1889</span> ns/op</span></div></pre></td></tr></table></figure>

<p>它的性能比Gorilla好太多了。使用它开发也非常的简单快捷。</p>
<p>后台是无状态的服务设计。Session需要在所有的节点共享。<br>使用 <a href="http://github.com/gorilla/sessions" target="_blank" rel="external">gorilla/sessions</a>实现session的管理，并且使用<a href="github.com/kidstuff/mongostore">mongostore</a>将session存储在MongoDB中。<br>也有其它的session存储方式， 如MySQL, Redis等：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/starJammer/gorilla-sessions-arangodb</span>](<span class="link_url">https://github.com/starJammer/gorilla-sessions-arangodb</span>) - ArangoDB</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/yosssi/boltstore</span>](<span class="link_url">https://github.com/yosssi/boltstore</span>) - Bolt</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/srinathgs/couchbasestore</span>](<span class="link_url">https://github.com/srinathgs/couchbasestore</span>) - Couchbase</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/denizeren/dynamostore</span>](<span class="link_url">https://github.com/denizeren/dynamostore</span>) - Dynamodb on AWS</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/bradleypeabody/gorilla-sessions-memcache</span>](<span class="link_url">https://github.com/bradleypeabody/gorilla-sessions-memcache</span>) - Memcache</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/hnakamur/gaesessions</span>](<span class="link_url">https://github.com/hnakamur/gaesessions</span>) - Memcache on GAE</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/kidstuff/mongostore</span>](<span class="link_url">https://github.com/kidstuff/mongostore</span>) - MongoDB</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/srinathgs/mysqlstore</span>](<span class="link_url">https://github.com/srinathgs/mysqlstore</span>) - MySQL</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/antonlindstrom/pgstore</span>](<span class="link_url">https://github.com/antonlindstrom/pgstore</span>) - PostgreSQL</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/boj/redistore</span>](<span class="link_url">https://github.com/boj/redistore</span>) - Redis</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/boj/rethinkstore</span>](<span class="link_url">https://github.com/boj/rethinkstore</span>) - RethinkDB</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/boj/riakstore</span>](<span class="link_url">https://github.com/boj/riakstore</span>) - Riak</div><div class="line"><span class="bullet">* </span>[<span class="link_label">github.com/michaeljs1990/sqlitestore</span>](<span class="link_url">https://github.com/michaeljs1990/sqlitestore</span>) - SQLite</div></pre></td></tr></table></figure>

<p>得益于Go http库的设计，可以实现很精巧的请求拦截， 比如进行权限检查，日志输出和Panic处理等。比如下面的panic的处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> panicCover(f http.HandlerFunc) http.HandlerFunc {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(w http.ResponseWriter, req *http.Request) {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="constant">nil</span> {</div><div class="line">				glog.Error(<span class="string">"Recovered in handlers"</span>, r, stack.Callers<span class="number">(3</span>))</div><div class="line">				http.Error(w, <span class="string">"Error"</span>, http.StatusInternalServerError)</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		f(w, req)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">mux.Get(<span class="string">"/abc"</span>, panicCover(http.HandlerFunc(oneHandler)))</div></pre></td></tr></table></figure>

<p>基于golang template可以实现网站的模板化处理,将布局layout和组件widget分开，这样可以公用header, footer,菜单，边栏等。<br>Restful API提供JSON数据，将从Mongo或者缓存中的数据返回给前端。</p>
<p>使用mgo作为数据访问层， mgo对于session/连接池的管理官方还缺乏一个详细而精确的说明，这里使用了基于请求的session管理:<a href="http://stackoverflow.com/questions/26574594/best-practice-to-maintain-a-mgo-session" target="_blank" rel="external">Best practice to maintain a mgo session</a></p>
<p>uriDB提供了微博,QQ,Github,Linkedin,Google的OAuth2登录，<a href="golang.org/x/oauth2">x/oauth2</a>并不能完全cover所有的oauth2的认证，因为每个厂家都有自己的方言，所以实现的时候针对每个厂家做了底层的处理。<br>同时还提供了注册服务器帐号的功能。<br>为了避免机器人注册和登录，提供了验证码的功能,基于<a href="github.com/dchest/captcha">dchest/captcha</a>。<br>我们需要考虑多节点的情况，填写验证码后请求可能会被提交到另外一个节点，所以验证码需要在节点中共享，所以实现了一个基于memcached的store。</p>
<p>考虑uriDB站点的情况， <strong>写</strong>操作相对较少，大部分的操作还是<strong>读</strong>，所以很适合用缓存来减少数据库的压力。使用memcached缓存文章的查询，极大地减少数据库的压力。</p>
<p>uriDB还提供了搜索的功能，详情见搜索那一节。</p>
<p>另外，还设计了管理员的简单平台，可以对文章进行审核，对用户进行管理，对文章进行修改。还提供了命令行的工具。<br>但是这些基本上不会用到，而是采用了slack机器人的方式，随时随地对网站进行管理: <a href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/" target="_blank" rel="external">使用Go开发一个 Slack 运维机器人 </a></p>
<p>日志采用<a href="https://github.com/golang/glog" target="_blank" rel="external">glog</a>，简单好用。</p>
<h3 id="数据库">数据库</h3>
<p>数据库的选择倒不是一个很艰难的选择，无论mysql还是MongoDB，cassandra都能胜任。<br>基本上现在每天收集的文章不到100篇，一年也才3万多篇， 10年也才30万。对数据库的存储压力不大。<br>所以这里选用了我近两年一直使用的Mongo。<br>Mongo数据的备份开始参照: <a href="http://colobu.com/2015/10/27/mongodb-backup/" target="_blank" rel="external">Mongodb 定期备份</a></p>
<p>如果数据库的压力增大，我会考虑将当前的MongoDB单例迁移到Replica Set,如果性能再不济，将其迁移到cluster模式，通过shard方式分担数据库的压力。我想基本不会达到这样的压力的。</p>
<p>但是数据库的备份是至关重要的，一旦机器宕机，或者遭受攻击，或者运维误操作，必须能恢复回来，否则哭也来不及。</p>
<h3 id="搜索">搜索</h3>
<p>当前的搜索基于Mongo的查询，搜索字段都建立了索引。但是在数据量大的时候，分页查询会是一个瓶颈，我想这对于实现过大数据分页的读者来说并不陌生。当offset很大的时候， 因为尽管你会skip这些offset取得limit条数据，也会搜索这些所有的数据，越往后查询越慢。<br>杨卫华(TimYang)有一篇很好的总结文章：<a href="http://timyang.net/data/key-list-pagination/" target="_blank" rel="external">为什么超长列表数据的翻页技术实现复杂</a></p>
<p>所以一般实现扶梯方式，只提供上一页下一页的功能，并不能直接跳转到n页。这样就可以通过最后一条或者第一条的偏移，获取下一页或者上一页的数据。<br>另外还要根据多字段查询，都建立索引对数据库的性能也有影响。</p>
<p>总的来说，在大数据量的情况下，查询并不是一件容易的事。</p>
<p>现在正在做的一件事是使用<a href="https://www.elastic.co/" target="_blank" rel="external">Elasticsearch</a>做索引服务器，可以很好的解决查询的问题。Elasticsearch已经在很多大公司得到广泛的应用，绝对是值得使用的做内容索引的产品。</p>
<p>最简单的方式，将Mongo数据库的数据导入到Elasticsearch中： <a href="http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/" target="_blank" rel="external">基于Golang将MongoDB的数据同步到Elasticsearch</a>。但是我不会采用这种方式，而是采用一种近实时的索引架构。</p>
<p>我索引的内容就是文章的元数据，元数据插入的时候只有两种：爬虫插入，读者提交/管理员更改/删除。所以在数据插入/更改/删除的时候将操作放入到<a href="https://github.com/nsqio/nsq" target="_blank" rel="external">nsq</a>中，Elasticsearch服务器读取到文章的变动，实时更新索引服务器。</p>
<p>使用nsq可以很好的实现异步的操作，将文章的变动和索引服务器的操作交给不同的服务器进行处理。<br>而且nsq也会作为uriDB异步服务的基础框架。</p>
<h3 id="移动端">移动端</h3>
<p>事实上，我先实现的Android版的移动端， 叫&quot;<a href="http://colobu.com/techreview/" target="_blank" rel="external">技术快报</a>&quot;， 如果你在一些应用商店搜索&quot;<a href="https://www.google.is/webhp?ie=utf-8&amp;oe=utf-8&amp;gws_rd=cr&amp;ei=w3BAVorbNsi80ASPsouICA#q=%E6%8A%80%E6%9C%AF%E5%BF%AB%E6%8A%A5+android" target="_blank" rel="external">Android 技术快报</a>&quot;就能搜到它。</p>
<p>因为当时还没有客户端，所以爬虫代码就在手机端实现的，出于时间的考虑，只能拉取很少的文章资源。</p>
<p>新的版本将直接从 <a href="http://uridb.com" target="_blank" rel="external">http://uridb.com</a> 拉取数据，并提供按照栏目进行浏览的方式，基本上会类似网易新闻这样的客户端。</p>
<h3 id="运维">运维</h3>
<p>Elasticsearch、Logstash和Kibana会是日志分析的三剑客。<br>当前的运维还很薄弱，服务器的监控，软件的重启和升级都靠手工，这些都是有待加强的地方。</p>
<p>当前实现了一个slack机器人，这样我就可以通过聊天室让机器人完成一些网站管理的工作，现在感觉超方便，我甚至可以在炒菜的时候得到网站的消息，也可以在睡觉前查看服务器的状态。</p>
<h3 id="参考文章">参考文章</h3>
<ol>
<li><a href="http://www.tokiwinter.com/building-a-highly-available-load-balancer-with-nginx-and-keepalived-on-centos/" target="_blank" rel="external">http://www.tokiwinter.com/building-a-highly-available-load-balancer-with-nginx-and-keepalived-on-centos/</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-highly-available-web-servers-with-keepalived-and-floating-ips-on-ubuntu-14-04" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-set-up-highly-available-web-servers-with-keepalived-and-floating-ips-on-ubuntu-14-04</a></li>
<li><a href="http://seanlook.com/2015/05/18/nginx-keepalived-ha/" target="_blank" rel="external">http://seanlook.com/2015/05/18/nginx-keepalived-ha/</a></li>
<li><a href="http://nmshuishui.blog.51cto.com/1850554/1405484" target="_blank" rel="external">http://nmshuishui.blog.51cto.com/1850554/1405484</a></li>
<li><a href="http://isux.tencent.com/h5-performance.html" target="_blank" rel="external">http://isux.tencent.com/h5-performance.html</a></li>
<li><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">https://developer.yahoo.com/performance/rules.html</a></li>
<li><a href="https://github.com/PuerkitoBio/goquery" target="_blank" rel="external">https://github.com/PuerkitoBio/goquery</a></li>
<li><a href="https://github.com/smallnest/goreq" target="_blank" rel="external">https://github.com/smallnest/goreq</a></li>
<li><a href="https://github.com/go-zoo/bone" target="_blank" rel="external">https://github.com/go-zoo/bone</a></li>
<li><a href="http://github.com/gorilla/sessions" target="_blank" rel="external">http://github.com/gorilla/sessions</a></li>
<li><a href="http://github.com/kidstuff/mongostore" target="_blank" rel="external">http://github.com/kidstuff/mongostore</a></li>
<li><a href="https://labix.org/mgo" target="_blank" rel="external">https://labix.org/mgo</a></li>
<li><a href="http://stackoverflow.com/questions/26574594/best-practice-to-maintain-a-mgo-session" target="_blank" rel="external">http://stackoverflow.com/questions/26574594/best-practice-to-maintain-a-mgo-session</a></li>
<li><a href="https://godoc.org/golang.org/x/oauth2" target="_blank" rel="external">https://godoc.org/golang.org/x/oauth2</a></li>
<li><a href="https://github.com/dchest/captcha" target="_blank" rel="external">https://github.com/dchest/captcha</a></li>
<li><a href="https://github.com/golang/glog" target="_blank" rel="external">https://github.com/golang/glog</a></li>
<li><a href="https://github.com/bradfitz/gomemcache/memcache" target="_blank" rel="external">https://github.com/bradfitz/gomemcache/memcache</a></li>
<li><a href="http://colobu.com/2015/10/27/mongodb-backup/" target="_blank" rel="external">http://colobu.com/2015/10/27/mongodb-backup/</a></li>
<li><a href="http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/" target="_blank" rel="external">http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/</a></li>
<li><a href="https://github.com/nsqio/nsq" target="_blank" rel="external">https://github.com/nsqio/nsq</a></li>
<li><a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="external">https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details</a></li>
<li><a href="http://kibana.logstash.es/" target="_blank" rel="external">http://kibana.logstash.es/</a></li>
<li><a href="https://www.gitbook.com/book/chenryn/logstash-best-practice/details" target="_blank" rel="external">https://www.gitbook.com/book/chenryn/logstash-best-practice/details</a></li>
<li><a href="https://www.gitbook.com/book/looly/elasticsearch-the-definitive-guide-cn/details" target="_blank" rel="external">https://www.gitbook.com/book/looly/elasticsearch-the-definitive-guide-cn/details</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="背景">背景</h3>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB</a>本身不生产干货，<a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>网站只是大自然的搬运工。<br>自<a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a>诞生依赖，已经有多个中文技术头条的网站了，比如<a href="http://toutiao.io/" target="_blank" rel="external">开发者头条</a>和<a href="http://geek.csdn.net/hotest" target="_blank" rel="external">极客头条</a>，为什么还要做这样一个雷同的头条网站呢？</p>
<p>有两个原因：<br>一是我想做一个分类头条的网站，按照技术领域对文章进行分类，这样只对前端感兴趣的同学可以只跟踪最新的前端文章。 同时uriDB只会筛选最新的技术干货，不会将问答，闲聊等技术层次低的文章收录。<br>二是这么多年来，我涉及的领域包括后台，大数据，前端和移动端的技术也是我感兴趣的领域。心中那份对技术的持久的热情，促使我将多年的技术积累以某种具体的形式呈现出来，籍此展示并能持久的进行技术架构的演化。</p>
<p>因此，uriDB技术流网站也就孵化出来了。虽然目前的访问量比较少，但是看的用户数和访问量在逐步的提升，也是一件令人欣慰的事。至少，这个网站收集的干货也为那些执着学习的同学带来些许的便利和技能提升。</p>
<p>与其说<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>类似<em>Hacker News</em>网站， 还不说说它类似<a href="http://toutiao.com/" target="_blank" rel="external">今日头条</a>， 只不是今日头条上全是新闻类的内容，而<a href="http://uridb.com" target="_blank" rel="external">uriDB</a>上全是技术干货。今日头条会将目标网站上的内容抓去过来进行重新排版，更加适合阅读。我也抓去了目标文章的内容，却没有进行重新排版显示，主要是考虑到了版权的问题，还是老老实实的做<em>Hacker News</em>一样的转发。</p>
<p>这个网站是2015年国庆节期间开始启动的，也是作为我的side project在维护。我会时不时的将我的新的想法，技术灵感应用于这个网站上。<br><img src="/2015/11/09/The-Stack-of-uriDB/uridb.png" alt=""><br>]]>
    
    </summary>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="bootstrap" scheme="http://colobu.com/tags/bootstrap/"/>
    
      <category term="nginx" scheme="http://colobu.com/tags/nginx/"/>
    
      <category term="nsq" scheme="http://colobu.com/tags/nsq/"/>
    
      <category term="android" scheme="http://colobu.com/tags/android/"/>
    
      <category term="mongo" scheme="http://colobu.com/tags/mongo/"/>
    
      <category term="elasticsearch" scheme="http://colobu.com/tags/elasticsearch/"/>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法 Python&R 速查表]]></title>
    <link href="http://colobu.com/2015/11/05/full-cheatsheet-machine-learning-algorithms/"/>
    <id>http://colobu.com/2015/11/05/full-cheatsheet-machine-learning-algorithms/</id>
    <published>2015-11-05T02:55:29.000Z</published>
    <updated>2015-11-09T01:36:49.673Z</updated>
    <content type="html"><![CDATA[<p>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">Cheatsheet – Python &amp; R codes for common Machine Learning Algorithms</a><br>在拿破仑•希尔的名著《思考与致富》中讲述了达比的故事：达比经过几年的时间快要挖掘到了金矿，却在离它三英尺的地方离开了！</p>
<p>现在,我不知道这个故事是否真实。但是,我肯定在我的周围有一些跟达比一样的人，这些人认为，不管遇到什么问题, 机器学习的目的就是执行以及使用2 – 3组算法。他们不去尝试更好的算法和技术，因为他们觉得太困难或耗费时间。</p>
<p>像达比一样,他们无疑是在到达最后一步的时候突然消失了!最后,他们放弃机器学习,说计算量非常大、非常困难或者认为自己的模型已经到达优化的临界点——真的是这样吗?</p>
<p>下面这些速查表能让这些“达比”成为机器学习的支持者。这是10个最常用的机器学习算法，这些算法使用了Python和R代码。考虑到机器学习在构建模型中的应用，这些速查表可以很好作为编码指南帮助你学好这些机器学习算法。Good Luck!</p>
<p><a href="http://discuss.analyticsvidhya.com/t/download-full-cheatsheet-on-machine-learning-algorithms/4063/1" target="_blank" rel="external">PDF版本</a><br><a id="more"></a><br><img src="1.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">Cheatsheet – Python &amp; R codes for common Machine Learning Algorithms</a><br>在拿破仑•希尔的名著《思考与致富》中讲述了达比的故事：达比经过几年的时间快要挖掘到了金矿，却在离它三英尺的地方离开了！</p>
<p>现在,我不知道这个故事是否真实。但是,我肯定在我的周围有一些跟达比一样的人，这些人认为，不管遇到什么问题, 机器学习的目的就是执行以及使用2 – 3组算法。他们不去尝试更好的算法和技术，因为他们觉得太困难或耗费时间。</p>
<p>像达比一样,他们无疑是在到达最后一步的时候突然消失了!最后,他们放弃机器学习,说计算量非常大、非常困难或者认为自己的模型已经到达优化的临界点——真的是这样吗?</p>
<p>下面这些速查表能让这些“达比”成为机器学习的支持者。这是10个最常用的机器学习算法，这些算法使用了Python和R代码。考虑到机器学习在构建模型中的应用，这些速查表可以很好作为编码指南帮助你学好这些机器学习算法。Good Luck!</p>
<p><a href="http://discuss.analyticsvidhya.com/t/download-full-cheatsheet-on-machine-learning-algorithms/4063/1" target="_blank" rel="external">PDF版本</a><br>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法精要(Python 和 R 代码)]]></title>
    <link href="http://colobu.com/2015/11/05/common-machine-learning-algorithms/"/>
    <id>http://colobu.com/2015/11/05/common-machine-learning-algorithms/</id>
    <published>2015-11-05T01:25:46.000Z</published>
    <updated>2015-11-05T02:31:42.071Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://www.analyticsvidhya.com" target="_blank" rel="external">analyticsvidhya</a>网站有一些非常好的机器学习的文章，这是其中的一篇。<br>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" target="_blank" rel="external">Essentials of Machine Learning Algorithms</a>,<br>国内有人翻译了，可以移步：<a href="http://blog.jobbole.com/92021/" target="_blank" rel="external">10 种机器学习算法的要点</a><br><a id="more"></a></p>
</blockquote>
<h3 id="Introduction">Introduction</h3>
<blockquote>
<p>Google’s self-driving cars and robots get a lot of press, but the company’s real future is in machine learning, the technology that enables computers to get smarter and more personal.</p>
<p>   – Eric Schmidt (Google Chairman)</p>
</blockquote>
<p>We are probably living in the most defining period of human history. The period when computing moved from large mainframes to PCs to cloud. But what makes it defining is not what has happened, but what is coming our way in years to come.</p>
<p>What makes this period exciting for some one like me is the democratization of the tools and techniques, which followed the boost in computing. Today, as a data scientist, I can build data crunching machines with complex algorithms for a few dollors per hour. But, reaching here wasn’t easy! I had my dark days and nights.</p>
<h3 id="Who_can_benefit_the_most_from_this_guide?">Who can benefit the most from this guide?</h3>
<p><strong>What I am giving out today is probably the most valuable guide, I have ever created.</strong><br>(这一篇指南，可能是我写过的最有价值的指南)</p>
<p>The idea behind creating this guide is to simplify the journey of aspiring data scientists and machine learning enthusiasts across the world. Through this guide, I will enable you to work on machine learning problems and gain from experience. <strong>I am providing a high level understanding about various machine learning algorithms along with R &amp; Python codes to run them. These should be sufficient to get your hands dirty.</strong><br><img src="1.jpg" alt=""><br>I have deliberately skipped the statistics behind these techniques, as you don’t need to understand them at the start. So, if you are looking for statistical understanding of these algorithms, you should look elsewhere. But, if you are looking to equip yourself to start building machine learning project, you are in for a treat.</p>
<h3 id="Broadly,_there_are_3_types_of_Machine_Learning_Algorithms-">Broadly, there are 3 types of Machine Learning Algorithms..</h3>
<p><strong>1 Supervised Learning</strong><br>监督式学习<br><strong>How it works</strong>: This algorithm consist of a target / outcome variable (or dependent variable) which is to be predicted from a given set of predictors (independent variables). Using these set of variables, we generate a function that map inputs to desired outputs. The training process continues until the model achieves a desired level of accuracy on the training data. Examples of Supervised Learning: Regression, Decision Tree, Random Forest, KNN, Logistic Regression etc. (回归、决策树、随机森林、K–近邻算法、逻辑回归等)</p>
<p><strong>2 Unsupervised Learning</strong><br>非监督式学习<br><strong>How it works</strong>: In this algorithm, we do not have any target or outcome variable to predict / estimate.  It is used for clustering population in different groups, which is widely used for segmenting customers in different groups for specific intervention. Examples of Unsupervised Learning: Apriori algorithm, K-means. (关联算法, K–均值算法)</p>
<p><strong>3 Reinforcement Learning</strong><br>强化学习<br><strong>How it works</strong>:  Using this algorithm, the machine is trained to make specific decisions. It works this way: the machine is exposed to an environment where it trains itself continually using trial and error. This machine learns from past experience and tries to capture the best possible knowledge to make accurate business decisions. Example of Reinforcement Learning: Markov Decision Process</p>
<h3 id="List_of_Common_Machine_Learning_Algorithms">List of Common Machine Learning Algorithms</h3>
<p>Here is the list of commonly used machine learning algorithms. These algorithms can be applied to almost any data problem:</p>
<ol>
<li>Linear Regression (线性回归)</li>
<li>Logistic Regression (逻辑回归)</li>
<li>Decision Tree (决策树)</li>
<li>SVM (支持向量机)</li>
<li>Naive Bayes (朴素贝叶斯)</li>
<li>KNN (K最近邻算法)</li>
<li>K-Means (K均值算法)</li>
<li>Random Forest (随机森林算法)</li>
<li>Dimensionality Reduction Algorithms (降维算法)</li>
<li>Gradient Boost &amp; Adaboost</li>
</ol>
<h4 id="1_Linear_Regression">1 Linear Regression</h4>
<p>It is used to estimate real values (cost of houses, number of calls, total sales etc.) based on continuous variable(s). Here, we establish relationship between independent and dependent variables by fitting a best line. This best fit line is known as regression line and represented by a linear equation Y= a *X + b.</p>
<p>The best way to understand linear regression is to relive this experience of childhood. Let us say, you ask a child in fifth grade to arrange people in his class by increasing order of weight, without asking them their weights! What do you think the child will do? He / she would likely look (visually analyze) at the height and build of people and arrange them using a combination of these visible parameters. This is linear regression in real life! The child has actually figured out that height and build would be correlated to the weight by a relationship, which looks like the equation above.</p>
<p>In this equation:</p>
<ul>
<li>Y – Dependent Variable</li>
<li>a – Slope</li>
<li>X – Independent variable</li>
<li>b – Intercept</li>
</ul>
<p>These coefficients a and b are derived based on minimizing the sum of squared difference of distance between data points and regression line.</p>
<p>Look at the below example. Here we have identified the best fit line having linear equation <strong>y=0.2811x+13.9</strong>. Now using this equation, we can find the weight, knowing the height of a person.<br><img src="2.png" alt=""></p>
<p>Linear Regression is of mainly two types: Simple Linear Regression and Multiple Linear Regression. Simple Linear Regression is characterized by one independent variable. And, Multiple Linear Regression(as the name suggests) is characterized by multiple (more than 1) independent variables. While finding best fit line, you can fit a polynomial or curvilinear regression. And these are known as polynomial or curvilinear regression.</p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="comment">#Import other necessary libraries like pandas, numpy...</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</div><div class="line"><span class="comment">#Load Train and Test datasets</span></div><div class="line"><span class="comment">#Identify feature and response variable(s) and values must be numeric and numpy arrays</span></div><div class="line">x_train=input_variables_values_training_datasets</div><div class="line">y_train=target_variables_values_training_datasets</div><div class="line">x_test=input_variables_values_test_datasets</div><div class="line"><span class="comment"># Create linear regression object</span></div><div class="line">linear = linear_model.LinearRegression()</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">linear.fit(x_train, y_train)</div><div class="line">linear.score(x_train, y_train)</div><div class="line"><span class="comment">#Equation coefficient and Intercept</span></div><div class="line">print(<span class="string">'Coefficient: \n'</span>, linear.coef_)</div><div class="line">print(<span class="string">'Intercept: \n'</span>, linear.intercept_)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= linear.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong><em>R</em></strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Load Train and Test datasets</span></div><div class="line"><span class="comment">#Identify feature and response variable(s) and values must be numeric and numpy arrays</span></div><div class="line">x_train &lt;- input_variables_values_training_datasets</div><div class="line">y_train &lt;- target_variables_values_training_datasets</div><div class="line">x_test &lt;- input_variables_values_test_datasets</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">linear &lt;- lm(y_train ~ ., data = x)</div><div class="line">summary(linear)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= predict(linear,x_test)</div></pre></td></tr></table></figure>

<h4 id="2_Logistic_Regression">2 Logistic Regression</h4>
<p>Don’t get confused by its name! It is a classification not a regression algorithm. It is used to estimate discrete values ( Binary values like 0/1, yes/no, true/false ) based on given set of independent variable(s). In simple words, it predicts the probability of occurrence of an event by fitting data to a logit function. Hence, it is also known as <strong>logit regression</strong>. Since, it predicts the probability, its output values lies between 0 and 1 (as expected).</p>
<p>Again, let us try and understand this through a simple example.</p>
<p>Let’s say your friend gives you a puzzle to solve. There are only 2 outcome scenarios – either you solve it or you don’t. Now imagine, that you are being given wide range of puzzles / quizzes in an attempt to understand which subjects you are good at. The outcome to this study would be something like this – if you are given a trignometry based tenth grade problem, you are 70% likely to solve it. On the other hand, if it is grade fifth history question, the probability of getting an answer is only 30%. This is what Logistic Regression provides you.</p>
<p>Coming to the math, the log odds of the outcome is modeled as a linear combination of the predictor variables.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dds= p/ (<span class="number">1</span>-p) = probability <span class="keyword">of</span> event occurrence / probability <span class="keyword">of</span> <span class="keyword">not</span> event occurrence</div><div class="line"><span class="function"><span class="title">ln</span><span class="params">(odds)</span> = <span class="title">ln</span><span class="params">(p/(<span class="number">1</span>-p)</span>)</span></div><div class="line"><span class="title">logit</span><span class="params">(p)</span> = <span class="title">ln</span><span class="params">(p/(<span class="number">1</span>-p)</span>) = <span class="title">b0</span>+<span class="title">b1X1</span>+<span class="title">b2X2</span>+<span class="title">b3X3</span>....+<span class="title">bkXk</span></div></pre></td></tr></table></figure>

<p>Above, p is the probability of presence of the characteristic of interest. It chooses parameters that maximize the likelihood of observing the sample values rather than that minimize the sum of squared errors (like in ordinary regression).</p>
<p>Now, you may ask, why take a log? For the sake of simplicity, let’s just say that this is one of the best mathematical way to replicate a step function. I can go in more details, but that will beat the purpose of this article.<br><img src="3.png" alt=""></p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create logistic regression object</span></div><div class="line">model = LogisticRegression()</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line">model.score(X, y)</div><div class="line"><span class="comment">#Equation coefficient and Intercept</span></div><div class="line">print(<span class="string">'Coefficient: \n'</span>, model.coef_)</div><div class="line">print(<span class="string">'Intercept: \n'</span>, model.intercept_)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">logistic &lt;- glm(y_train ~ ., data = x,family=<span class="string">'binomial'</span>)</div><div class="line">summary(logistic)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= predict(logistic,x_test)</div></pre></td></tr></table></figure>

<p><strong>Furthermore...</strong></p>
<p>There are many different steps that could be tried in order to improve the model:</p>
<ul>
<li>including interaction terms</li>
<li>removing features</li>
<li>regularization techniques</li>
<li>using a non-linear model</li>
</ul>
<h4 id="3_Decision_Tree">3 Decision Tree</h4>
<p>This is one of my favorite algorithm and I use it quite frequently. It is a type of supervised learning algorithm that is mostly used for classification problems. Surprisingly, it works for both categorical and continuous dependent variables. In this algorithm, we split the population into two or more homogeneous sets. This is done based on most significant attributes/ independent variables to make as distinct groups as possible. For more details, you can read: <a href="http://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="external">Decision Tree Simplified</a>.<br><img src="4.png" alt=""><br>In the image above, you can see that population is classified into four different groups based on multiple attributes to identify ‘if they will play or not’. To split the population into different heterogeneous groups, it uses various techniques like Gini, Information Gain, Chi-square, entropy.</p>
<p>The best way to understand how decision tree works, is to play Jezzball – a classic game from Microsoft (image below). Essentially, you have a room with moving walls and you need to create walls such that maximum area gets cleared off with out the balls.<br><img src="5.jpg" alt=""><br>So, every time you split the room with a wall, you are trying to create 2 different populations with in the same room. Decision trees work in very similar fashion by dividing a population in as different groups as possible.</p>
<p>More: <a href="http://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="external">Simplified Version of Decision Tree Algorithms</a></p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="comment">#Import other necessary libraries like pandas, numpy...</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create tree object </span></div><div class="line">model = tree.DecisionTreeClassifier(criterion=<span class="string">'gini'</span>) <span class="comment"># for classification, here you can change the algorithm as gini or entropy (information gain) by default it is gini  </span></div><div class="line"><span class="comment"># model = tree.DecisionTreeRegressor() for regression</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line">model.score(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rpart)</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># grow tree </span></div><div class="line">fit &lt;- rpart(y_train ~ ., data = x,method=<span class="string">"class"</span>)</div><div class="line">summary(fit)</div><div class="line"><span class="comment">#Predict Output </span></div><div class="line">predicted= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="4_SVM_(Support_Vector_Machine)">4 SVM (Support Vector Machine)</h4>
<p>It is a classification method. In this algorithm, we plot each data item as a point in n-dimensional space (where n is number of features you have) with the value of each feature being the value of a particular coordinate.</p>
<p>For example, if we only had two features like Height and Hair length of an individual, we’d first plot these two variables in two dimensional space where each point has two co-ordinates (these co-ordinates are known as <strong>Support Vectors</strong>)</p>
<p><img src="6.png" alt=""></p>
<p>Now, we will find some line that splits the data between the two differently classified groups of data. This will be the line such that the distances from the closest point in each of the two groups will be farthest away.<br><img src="7.png" alt=""></p>
<p>In the example shown above, the line which splits the data into two differently classified groups is the black line, since the two closest points are the farthest apart from the line. This line is our classifier. Then, depending on where the testing data lands on either side of the line, that’s what class we can classify the new data as.</p>
<p>More: <a href="http://www.analyticsvidhya.com/blog/2014/10/support-vector-machine-simplified/" target="_blank" rel="external">Simplified Version of Support Vector Machine</a></p>
<p><strong>Think of this algorithm as playing JezzBall in n-dimensional space. The tweaks in the game are:</strong></p>
<ul>
<li>You can draw lines / planes at any angles (rather than just horizontal or vertical as in classic game)</li>
<li>The objective of the game is to segregate balls of different colors in different rooms.</li>
<li>And the balls are not moving.</li>
</ul>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create SVM classification object </span></div><div class="line">model = svm.svc() <span class="comment"># there is various option associated with it, this is simple for classification. You can refer link, for mo# re detail.</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line">model.score(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(e1071)</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Fitting model</span></div><div class="line">fit &lt;-svm(y_train ~ ., data = x)</div><div class="line">summary(fit)</div><div class="line"><span class="comment">#Predict Output </span></div><div class="line">predicted= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="5_Naive_Bayes">5 Naive Bayes</h4>
<p>It is a classification technique based on Bayes’ theorem with an assumption of independence between predictors. In simple terms, a Naive Bayes classifier assumes that the presence of a particular feature in a class is unrelated to the presence of any other feature. For example, a fruit may be considered to be an apple if it is red, round, and about 3 inches in diameter. Even if these features depend on each other or upon the existence of the other features, a naive Bayes classifier would consider all of these properties to independently contribute to the probability that this fruit is an apple.</p>
<p>Naive Bayesian model is easy to build and particularly useful for very large data sets. Along with simplicity, Naive Bayes is known to outperform even highly sophisticated classification methods.</p>
<p>Bayes theorem provides a way of calculating posterior probability P(c|x) from P(c), P(x) and P(x|c). Look at the equation below:<br><img src="8.png" alt=""><br>Here,</p>
<ul>
<li>P(c|x) is the posterior probability of class (target) given predictor (attribute). </li>
<li>P(c) is the prior probability of class. </li>
<li>P(x|c) is the likelihood which is the probability of predictor given class. </li>
<li>P(x) is the prior probability of predictor.</li>
</ul>
<p><strong>Example</strong>: Let’s understand it using an example. Below I have a training data set of weather and corresponding target variable ‘Play’. Now, we need to classify whether players will play or not based on weather condition. Let’s follow the below steps to perform it.</p>
<p>Step 1: Convert the data set to frequency table</p>
<p>Step 2: Create Likelihood table by finding the probabilities like Overcast probability = 0.29 and probability of playing is 0.64.<br><img src="9.png" alt=""></p>
<p>Step 3: Now, use Naive Bayesian equation to calculate the posterior probability for each class. The class with the highest posterior probability is the outcome of prediction.</p>
<p><strong>Problem</strong>: Players will pay if weather is sunny, is this statement is correct?</p>
<p>We can solve it using above discussed method, so P(Yes | Sunny) = P( Sunny | Yes) * P(Yes) / P (Sunny)</p>
<p>Here we have P (Sunny |Yes) = 3/9 = 0.33, P(Sunny) = 5/14 = 0.36, P( Yes)= 9/14 = 0.64</p>
<p>Now, P (Yes | Sunny) = 0.33 * 0.64 / 0.36 = 0.60, which has higher probability.</p>
<p>Naive Bayes uses a similar method to predict the probability of different class based on various attributes. This algorithm is mostly used in text classification and with problems having multiple classes.</p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create SVM classification object model = GaussianNB() # there is other distribution for multinomial classes like Bernoulli Naive Bayes, Refer link</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">library</span>(e1071)</div><div class="line"><span class="title">x</span> &lt;- cbind(x_train,y_train)</div><div class="line"><span class="preprocessor"># Fitting model</span></div><div class="line"><span class="title">fit</span> &lt;-naiveBayes(y_train ~ ., <span class="typedef"><span class="keyword">data</span> = x)</span></div><div class="line"><span class="title">summary</span>(fit)</div><div class="line"><span class="preprocessor">#Predict Output </span></div><div class="line"><span class="title">predicted</span>= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="6_KNN_(K-_Nearest_Neighbors)">6 KNN (K- Nearest Neighbors)</h4>
<p>It can be used for both classification and regression problems. However, it is more widely used in classification problems in the industry. K nearest neighbors is a simple algorithm that stores all available cases and classifies new cases by a majority vote of its k neighbors. The case being assigned to the class is most common amongst its K nearest neighbors measured by a distance function.</p>
<p>These distance functions can be Euclidean, Manhattan, Minkowski and Hamming distance. First three functions are used for continuous function and fourth one (Hamming) for categorical variables. If K = 1, then the case is simply assigned to the class of its nearest neighbor. At times, choosing K turns out to be a challenge while performing KNN modeling.</p>
<p>More: <a href="http://Introduction to k-nearest neighbors : Simplified" target="_blank" rel="external">Introduction to k-nearest neighbors : Simplified.</a><br><img src="10.png" alt=""><br>KNN can easily be mapped to our real lives. If you want to learn about a person, of whom you have no information, you might like to find out about his close friends and the circles he moves in and gain access to his/her information!<br>Things to consider before selecting KNN:</p>
<ul>
<li>KNN is computationally expensive</li>
<li>Variables should be normalized else higher range variables can bias it</li>
<li>Works on pre-processing stage more before going for KNN like outlier, noise removal</li>
</ul>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create KNeighbors classifier object model </span></div><div class="line">KNeighborsClassifier(n_neighbors=<span class="number">6</span>) <span class="comment"># default value for n_neighbors is 5</span></div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">library</span>(knn)</div><div class="line"><span class="title">x</span> &lt;- cbind(x_train,y_train)</div><div class="line"><span class="preprocessor"># Fitting model</span></div><div class="line"><span class="title">fit</span> &lt;-knn(y_train ~ ., <span class="typedef"><span class="keyword">data</span> = x,k=5)</span></div><div class="line"><span class="title">summary</span>(fit)</div><div class="line"><span class="preprocessor">#Predict Output </span></div><div class="line"><span class="title">predicted</span>= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="7_K-Means">7 K-Means</h4>
<p>It is a type of unsupervised algorithm which  solves the clustering problem. Its procedure follows a simple and easy  way to classify a given data set through a certain number of  clusters (assume k clusters). Data points inside a cluster are homogeneous and heterogeneous to peer groups.</p>
<p>Remember figuring out shapes from ink blots? k means is somewhat similar this activity. You look at the shape and spread to decipher how many different clusters / population are present!<br><img src="11.jpg" alt=""></p>
<p><strong>How K-means forms cluster:</strong></p>
<ol>
<li>K-means picks k number of points for each cluster known as centroids.</li>
<li>Each data point forms a cluster with the closest centroids i.e. k clusters.</li>
<li>Finds the centroid of each cluster based on existing cluster members. Here we have new centroids.</li>
<li>As we have new centroids, repeat step 2 and 3. Find the closest distance for each data point from new centroids and get associated with new k-clusters. Repeat this process until convergence occurs i.e. centroids does not change.</li>
</ol>
<p><strong>How to determine value of K:</strong><br>In K-means, we have clusters and each cluster has its own centroid. Sum of square of difference between centroid and the data points within a cluster constitutes within sum of square value for that cluster. Also, when the sum of square values for all the clusters are added, it becomes total within sum of square value for the cluster solution.</p>
<p>We know that as the number of cluster increases, this value keeps on decreasing but if you plot the result you may see that the sum of squared distance decreases sharply up to some value of k, and then much more slowly after that. Here, we can find the optimum number of cluster.<br><img src="12.png" alt=""><br><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</div><div class="line"><span class="comment">#Assumed you have, X (attributes) for training data set and x_test(attributes) of test_dataset</span></div><div class="line"><span class="comment"># Create KNeighbors classifier object model </span></div><div class="line">k_means = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">0</span>)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(<span class="keyword">cluster</span>)</div><div class="line">fit &lt;- kmeans(X, 3) # 5 <span class="keyword">cluster</span> solution</div></pre></td></tr></table></figure>

<h4 id="8_Random_Forest">8 Random Forest</h4>
<p>Random Forest is a trademark term for an ensemble of decision trees. In Random Forest, we’ve collection of decision trees (so known as “Forest”). To classify a new object based on attributes, each tree gives a classification and we say the tree “votes” for that class. The forest chooses the classification having the most votes (over all the trees in the forest).</p>
<p>Each tree is planted &amp; grown as follows:</p>
<ol>
<li>If the number of cases in the training set is N, then sample of N cases is taken at random but with replacement. This sample will be the training set for growing the tree.</li>
<li>If there are M input variables, a number m&lt;&lt;M is specified such that at each node, m variables are selected at random out of the M and the best split on these m is used to split the node. The value of m is held constant during the forest growing.</li>
<li>Each tree is grown to the largest extent possible. There is no pruning.</li>
</ol>
<p>For more details on this algorithm, comparing with decision tree and tuning model parameters, I would suggest you to read these articles:</p>
<ol>
<li><a href="http://www.analyticsvidhya.com/blog/2014/06/introduction-random-forest-simplified/" target="_blank" rel="external">Introduction to Random forest – Simplified</a></li>
<li><a href="http://www.analyticsvidhya.com/blog/2014/06/comparing-cart-random-forest-1/" target="_blank" rel="external">Comparing a CART model to Random Forest (Part 1)</a></li>
<li><a href="http://www.analyticsvidhya.com/blog/2014/06/comparing-random-forest-simple-cart-model/" target="_blank" rel="external">Comparing a Random Forest to a CART model (Part 2)</a></li>
<li><a href="http://www.analyticsvidhya.com/blog/2015/06/tuning-random-forest-model/" target="_blank" rel="external">Tuning the parameters of your Random Forest model</a></li>
</ol>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create Random Forest object</span></div><div class="line">model= RandomForestClassifier()</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">library</span>(randomForest)</div><div class="line"><span class="title">x</span> &lt;- cbind(x_train,y_train)</div><div class="line"><span class="preprocessor"># Fitting model</span></div><div class="line"><span class="title">fit</span> &lt;- randomForest(<span class="type">Species</span> ~ ., x,ntree=<span class="number">500</span>)</div><div class="line"><span class="title">summary</span>(fit)</div><div class="line"><span class="preprocessor">#Predict Output </span></div><div class="line"><span class="title">predicted</span>= predict(fit,x_test)</div></pre></td></tr></table></figure>

<h4 id="9_Dimensionality_Reduction_Algorithms">9 Dimensionality Reduction Algorithms</h4>
<p>In the last 4-5 years, there has been an exponential increase in data capturing at every possible stages. Corporates/ Government Agencies/ Research organisations are not only coming with new sources but also they are capturing data in great detail.</p>
<p>For example: E-commerce companies are capturing more details about customer like their demographics, web crawling history, what they like or dislike, purchase history, feedback and many others to give them personalized attention more than your nearest grocery shopkeeper.</p>
<p>As a data scientist, the data we are offered also consist of many features, this sounds good for building good robust model but there is a challenge. How’d you identify highly significant variable(s) out 1000 or 2000? In such cases, dimensionality reduction algorithm helps us along with various other algorithms like Decision Tree, Random Forest, PCA, Factor Analysis, Identify based on correlation matrix, missing value ratio and others.</p>
<p>To know more about this algorithms, you can read <a href="http://www.analyticsvidhya.com/blog/2015/07/dimension-reduction-methods/" target="_blank" rel="external">“Beginners Guide To Learn Dimension Reduction Techniques“</a>.</p>
<p><strong>Python  Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> decomposition</div><div class="line"><span class="comment">#Assumed you have training and test data set as train and test</span></div><div class="line"><span class="comment"># Create PCA obeject pca= decomposition.PCA(n_components=k) #default value of k =min(n_sample, n_features)</span></div><div class="line"><span class="comment"># For Factor analysis</span></div><div class="line"><span class="comment">#fa= decomposition.FactorAnalysis()</span></div><div class="line"><span class="comment"># Reduced the dimension of training dataset using PCA</span></div><div class="line">train_reduced = pca.fit_transform(train)</div><div class="line"><span class="comment">#Reduced the dimension of test dataset</span></div><div class="line">test_reduced = pca.transform(test)</div><div class="line"><span class="comment">#For more detail on this, please refer  this link.</span></div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">library</span><span class="params">(stats)</span></span></div><div class="line"><span class="title">pca</span> &lt;- <span class="title">princomp</span><span class="params">(train, cor = <span class="variable">TRUE</span>)</span></div><div class="line"><span class="title">train_reduced</span>  &lt;- <span class="title">predict</span><span class="params">(pca,train)</span></div><div class="line"><span class="title">test_reduced</span>  &lt;- <span class="title">predict</span><span class="params">(pca,test)</span></div></pre></td></tr></table></figure>

<h4 id="10_Gradient_Boosting_&amp;_AdaBoost">10 Gradient Boosting &amp; AdaBoost</h4>
<p>GBM &amp; AdaBoost are boosting algorithms used when we deal with plenty of data to make a prediction with high prediction power. Boosting is an ensemble learning algorithm which combines the prediction of several base estimators in order to improve robustness over a single estimator. It combines multiple weak or average predictors to a build strong predictor. These boosting algorithms always work well in data science competitions like Kaggle, AV Hackathon, CrowdAnalytix.</p>
<p>More: <a href="http://www.analyticsvidhya.com/blog/2015/05/boosting-algorithms-simplified/" target="_blank" rel="external">Know about Gradient and AdaBoost in detail</a></p>
<p><strong>Python Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Import Library</span></div><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</div><div class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></div><div class="line"><span class="comment"># Create Gradient Boosting Classifier object</span></div><div class="line">model= GradientBoostingClassifier(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">1.0</span>, max_depth=<span class="number">1</span>, random_state=<span class="number">0</span>)</div><div class="line"><span class="comment"># Train the model using the training sets and check score</span></div><div class="line">model.fit(X, y)</div><div class="line"><span class="comment">#Predict Output</span></div><div class="line">predicted= model.predict(x_test)</div></pre></td></tr></table></figure>

<p><strong>R</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">library(caret)</div><div class="line">x &lt;- cbind(x_train,y_train)</div><div class="line"><span class="comment"># Fitting model</span></div><div class="line">fitControl &lt;- trainControl( <span class="keyword">method</span> = <span class="string">"repeatedcv"</span>, number = <span class="number">4</span>, repeats = <span class="number">4</span>)</div><div class="line">fit &lt;- train(y ~ ., data = x, <span class="keyword">method</span> = <span class="string">"gbm"</span>, trControl = fitControl,verbose = <span class="type">FALSE</span>)</div><div class="line">predicted= predict(fit,x_test,<span class="keyword">type</span>= <span class="string">"prob"</span>)[,<span class="number">2</span>]</div></pre></td></tr></table></figure>

<p>GradientBoostingClassifier and Random Forest are two different boosting tree classifier and often people ask about <a href="http://discuss.analyticsvidhya.com/t/what-is-the-fundamental-difference-between-randomforest-and-gradient-boosting-algorithms/2341" target="_blank" rel="external">the difference between these two algorithms</a>.</p>
<h4 id="End_Notes">End Notes</h4>
<p>By now, I am sure, you would have an idea of commonly used machine learning algorithms. My sole intention behind writing this article and providing the codes in R and Python is to get you started right away. If you are keen to master machine learning, start right away. Take up problems, develop a physical understanding of the process, apply these codes and see the fun!</p>
<p>Did you find this article useful ? Share your views and opinions in the comments section below.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><a href="http://www.analyticsvidhya.com" target="_blank" rel="external">analyticsvidhya</a>网站有一些非常好的机器学习的文章，这是其中的一篇。<br>原文出处: <a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" target="_blank" rel="external">Essentials of Machine Learning Algorithms</a>,<br>国内有人翻译了，可以移步：<a href="http://blog.jobbole.com/92021/" target="_blank" rel="external">10 种机器学习算法的要点</a><br>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go开发一个 Slack 运维机器人]]></title>
    <link href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/"/>
    <id>http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/</id>
    <published>2015-11-04T04:31:01.000Z</published>
    <updated>2015-11-09T01:36:20.452Z</updated>
    <content type="html"><![CDATA[<p>受湾区日报的自动化机器人启发：<a href="https://wanqu.co/blog/2015-08-19-slack-hubot.html" target="_blank" rel="external">湾区日报的第一个“员工”：Slack/Hubot</a>， 我决定为自己的 side project 写一个自动化的slack运维机器人。</p>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>是一个搜集高质量技术文章的网站。主要是由爬虫到一些技术站点寻找关注度高的技术文章，以及一些技术聚合站点的高质量的文章，我也会发一些平常自己看到的技术文章。uriDB也允许用户注册发布文章。</p>
<p>因为这是自己的 side project, 我不会将精力全部放在这个项目上。 如果有一个机器人，可以方便的维护这个站点，那么可以极大减少我的工作量。</p>
<p>这个网站后台完全是由 Go 开发的，所以我还是想用Golang实现这个机器人，而没有采用<a href="https://hubot.github.com/" target="_blank" rel="external">hubot</a> + <a href="https://github.com/slackhq/hubot-slack" target="_blank" rel="external">hubot-slack</a>。</p>
<p>目前这个机器人实现了基本的功能：</p>
<ul>
<li>发表一个文章链接</li>
<li>修改文章的元数据</li>
<li>删除文章</li>
<li>分析一个文章链接</li>
</ul>
<p>有时间我会将服务器性能监控等功能加上。</p>
<a id="more"></a>
<h3 id="关于Slack">关于Slack</h3>
<p>Slack创始人是Stewart Butterfield，他在2009年创立游戏制作商Tiny Speck，之后联合创立了图片分享网站Flickr。13年他开始转型做Slack，这款产品13年8月内测，14年2月公测。2014年4月，正式推出不到三个月，Slack就已融资4275万美元。2014年10月，融资1.2亿美元，估值达11.2亿美元，成为了有史以来发展最快的 SaaS 公司。<br>本质上，Slack是一个企业内部沟通协作平台。提供了 Web 端，IOS 端和 Android 端的访问。</p>
<p>我们公司先前用hipchat,被<strong>comcast</strong>收购后开始改用slack。</p>
<p>Slack提供了机器人的功能，而且提供了清晰简单的API接口，这一点在实时通讯工具中值得称赞。人们可以使用各种语言实现各种各样的机器人和插件。你可以查看<a href="https://api.slack.com/community" target="_blank" rel="external">Community-built Integrations</a>，文章中列出了各种语言的插件和SDK。</p>
<p>我使用<a href="https://github.com/nlopes/slack" target="_blank" rel="external">nlopes/slack</a>来实现我的机器人。</p>
<p>第一步，你首先创建一个Team，并且加入到这个Team中。这是使用Slack的第一步。以后你可以直接访问http://<your team="">.slack.com登录到你的team中。</your></p>
<p>第二步，新建一个<a href="https://my.slack.com/services/new/bot" target="_blank" rel="external">bot user integration</a>。你需要为你的机器人起一个名字，比如我称我的机器人为 mybot。好像不支持中文，本来我想叫她&quot;小冰&quot;的。<br>可以为它指定头像，slack会为它生成一个 API Token。 这个API Token很重要， 以后访问slack API需要传入这个token。<br>slack提供乐意个简化的访问API的认证，你可以不使用oauth2的方式获取access token实现认证。而是直接获得api token访问API。<br>你也可以为你的普通登录用户生成full-access token，网址是: <a href="https://api.slack.com/web。" target="_blank" rel="external">https://api.slack.com/web。</a> </p>
<p>第三步，将你创建的bot加入到一个channel中。 比如我创建一个管理uridb网站的channel,将这个机器人邀请进来：<br><img src="1.png" alt=""></p>
<p>现在准备工作完成了。你可以在这个channel聊天了，但是这个机器人无动于衷，因为你还未实现它的逻辑。</p>
<h3 id="使用_Go_实现这个机器人">使用 Go 实现这个机器人</h3>
<p>创建一个 Go 项目， 并引入<a href="https://github.com/nlopes/slack" target="_blank" rel="external">nlopes/slack</a>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/nlopes/slack</div></pre></td></tr></table></figure>

<p>这个库访问slack api超级简单， 如下面访问用户信息的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/nlopes/slack"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    api := slack.New(<span class="string">"YOUR_TOKEN_HERE"</span>)</div><div class="line">    user, err := api.GetUserInfo(<span class="string">"U023BECGF"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        fmt.Printf(<span class="string">"%s\n"</span>, err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    fmt.Printf(<span class="string">"ID: %s, Fullname: %s, Email: %s\n"</span>, user.ID, user.Profile.RealName, user.Profile.Email)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为我们要机器人实时接受指令，需要访问 <a href="https://api.slack.com/rtm" target="_blank" rel="external">Real Time Messaging API</a>， 它是通过websocket实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/nlopes/slack"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	api := slack.New(<span class="string">"YOUR TOKEN HERE"</span>)</div><div class="line">	api.SetDebug(<span class="constant">true</span>)</div><div class="line"></div><div class="line">	rtm := api.NewRTM()</div><div class="line">	<span class="keyword">go</span> rtm.ManageConnection()</div><div class="line"></div><div class="line">Loop:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> msg := &lt;-rtm.IncomingEvents:</div><div class="line">			fmt.Print(<span class="string">"Event Received: "</span>)</div><div class="line">			<span class="keyword">switch</span> ev := msg.Data.(<span class="keyword">type</span>) {</div><div class="line">			<span class="keyword">case</span> *slack.HelloEvent:</div><div class="line">				<span class="comment">// Ignore hello</span></div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.ConnectedEvent:</div><div class="line">				fmt.Println(<span class="string">"Infos:"</span>, ev.Info)</div><div class="line">				fmt.Println(<span class="string">"Connection counter:"</span>, ev.ConnectionCount)</div><div class="line">				<span class="comment">// Replace #general with your Channel ID</span></div><div class="line">				rtm.SendMessage(rtm.NewOutgoingMessage(<span class="string">"Hello world"</span>, <span class="string">"#general"</span>))</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.MessageEvent:</div><div class="line">				fmt.Printf(<span class="string">"Message: %v\n"</span>, ev)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.PresenceChangeEvent:</div><div class="line">				fmt.Printf(<span class="string">"Presence Change: %v\n"</span>, ev)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.LatencyReport:</div><div class="line">				fmt.Printf(<span class="string">"Current latency: %v\n"</span>, ev.Value)</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.RTMError:</div><div class="line">				fmt.Printf(<span class="string">"Error: %s\n"</span>, ev.Error())</div><div class="line"></div><div class="line">			<span class="keyword">case</span> *slack.InvalidAuthEvent:</div><div class="line">				fmt.Printf(<span class="string">"Invalid credentials"</span>)</div><div class="line">				<span class="keyword">break</span> Loop</div><div class="line"></div><div class="line">			<span class="keyword">default</span>:</div><div class="line"></div><div class="line">				<span class="comment">// Ignore other events..</span></div><div class="line">				<span class="comment">// fmt.Printf("Unexpected: %v\n", msg.Data)</span></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最重要的是 <code>case *slack.MessageEvent:</code>，这里会接收到实时的消息。 我们可以判断消息是否来自我们定制的channel，以及指令是否是对机器人发出的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">			<span class="keyword">case</span> *slack.MessageEvent:</div><div class="line">				<span class="keyword">if</span> ev.Channel == channelID && ev.Team == teamID {</div><div class="line">					msg := ev.Text					</div><div class="line">					</div><div class="line">					sendToMyBot := checkMessage(msg)</div><div class="line">					</div><div class="line">					<span class="keyword">if</span> sendToMyBot {</div><div class="line">						<span class="keyword">go</span> handleCommand(msg)</div><div class="line">					}</div><div class="line"></div><div class="line">				}</div><div class="line">...</div></pre></td></tr></table></figure>

<p>剩下的逻辑就是你去实现<code>handleCommand</code>，你可以实现各种各样的命令,如:<br><a rel="external" href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/2.png" title="" class="fancybox" target="_blank"><img data-bd-imgshare-binded="1" src="2.png" alt="" width="400px"></a><br><br><br><br><a rel="external" href="http://colobu.com/2015/11/04/create-a-slack-bot-with-golang/3.png" title="" class="fancybox" target="_blank"><img data-bd-imgshare-binded="1" src="3.png" alt="" width="400px"></a></p>
<p>BTW:<br>增加了一个邪恶的功能，可以通过它远程执行linux命令，这样就可以运行命令查看服务器的状态，但是这个后门有点危险。<br><img src="4.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>受湾区日报的自动化机器人启发：<a href="https://wanqu.co/blog/2015-08-19-slack-hubot.html" target="_blank" rel="external">湾区日报的第一个“员工”：Slack/Hubot</a>， 我决定为自己的 side project 写一个自动化的slack运维机器人。</p>
<p><a href="http://uridb.com" target="_blank" rel="external">uriDB技术流</a>是一个搜集高质量技术文章的网站。主要是由爬虫到一些技术站点寻找关注度高的技术文章，以及一些技术聚合站点的高质量的文章，我也会发一些平常自己看到的技术文章。uriDB也允许用户注册发布文章。</p>
<p>因为这是自己的 side project, 我不会将精力全部放在这个项目上。 如果有一个机器人，可以方便的维护这个站点，那么可以极大减少我的工作量。</p>
<p>这个网站后台完全是由 Go 开发的，所以我还是想用Golang实现这个机器人，而没有采用<a href="https://hubot.github.com/" target="_blank" rel="external">hubot</a> + <a href="https://github.com/slackhq/hubot-slack" target="_blank" rel="external">hubot-slack</a>。</p>
<p>目前这个机器人实现了基本的功能：</p>
<ul>
<li>发表一个文章链接</li>
<li>修改文章的元数据</li>
<li>删除文章</li>
<li>分析一个文章链接</li>
</ul>
<p>有时间我会将服务器性能监控等功能加上。</p>
]]>
    
    </summary>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="slack" scheme="http://colobu.com/tags/slack/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Linux 上如何清除内存的 Cache、Buffer 和交换空间]]></title>
    <link href="http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/"/>
    <id>http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/</id>
    <published>2015-10-31T13:09:20.000Z</published>
    <updated>2015-10-31T13:30:33.911Z</updated>
    <content type="html"><![CDATA[<p>英文原文: <a href="http://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/" target="_blank" rel="external">How to Clear RAM Memory Cache, Buffer and Swap Space on Linux</a>,<br>中文翻译: <a href="https://linux.cn/article-5627-1.html" target="_blank" rel="external">在 Linux 上如何清除内存的 Cache、Buffer 和交换空间</a> by strugglingyouth<br>像任何其他的操作系统一样，GNU/Linux 已经实现的内存管理不仅有效，而且更好。但是，如果有任何进程正在蚕食你的内存，而你想要清除它的话，Linux 提供了一个刷新或清除RAM缓存方法。<br><img src="http://www.tecmint.com/wp-content/uploads/2015/05/Clear-RAM-Cache-in-Linux.jpg" alt=""><br><a id="more"></a></p>
<h3 id="如何在_Linux_中清除缓存（Cache）？">如何在 Linux 中清除缓存（Cache）？</h3>
<p>每个 Linux 系统有三种选项来清除缓存而不需要中断任何进程或服务。<br>（LCTT 译注：Cache，译作“缓存”，指 CPU 和内存之间高速缓存。Buffer，译作“缓冲区”，指在写入磁盘前的存储再内存中的内容。在本文中，Buffer 和 Cache 有时候会通指。）</p>
<ol>
<li>仅清除页面缓存（PageCache）</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sync; echo 1 &gt; /proc/sys/vm/drop_caches</span></div></pre></td></tr></table></figure>

<ol>
<li>清除目录项和inode</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sync; echo 2 &gt; /proc/sys/vm/drop_caches</span></div></pre></td></tr></table></figure>

<ol>
<li>清除页面缓存，目录项和inode</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sync; echo 3 &gt; /proc/sys/vm/drop_caches</span></div></pre></td></tr></table></figure>

<p>上述命令的说明：<br><code>sync</code>将刷新文件系统缓冲区（buffer），命令通过“;”分隔，顺序执行，shell在执行序列中的下一个命令之前会等待命令的终止。正如内核文档中提到的，写入到drop_cache将清空缓存而不会杀死任何应用程序/服务，<a href="http://www.tecmint.com/echo-command-in-linux/" target="_blank" rel="external">echo命令</a>做写入文件的工作。</p>
<p>如果你必须清除磁盘高速缓存，第一个命令在企业和生产环境中是最安全，&quot;...echo 1&gt; ...&quot;只会清除页面缓存。 在生产环境中不建议使用上面的第三个选项&quot;...echo 3 &gt; ...&quot; ，除非你明确自己在做什么，因为它会清除缓存页，目录项和inodes。</p>
<h4 id="在Linux上释放也许被内核所使用的缓冲区（Buffer）和缓存（Cache）是否是个好主意？">在Linux上释放也许被内核所使用的缓冲区（Buffer）和缓存（Cache）是否是个好主意？</h4>
<p>当你设置许多设定想要检查效果时，如果它实际上是专门针对 I/O 范围的基准测试，那么你可能需要清除缓冲区和缓存。你可以如上所示删除缓存，无需重新启动系统（即无需停机）。</p>
<p>Linux被设计成它在寻找磁盘之前到磁盘缓存寻找的方式。如果它发现该资源在缓存中，则该请求不会发送到磁盘。如果我们清理缓存，磁盘缓存就起不到作用了，系统会到磁盘上寻找资源。</p>
<p>此外，当清除缓存后它也将减慢系统运行速度，系统会将每一个被请求的资源再次加载到磁盘缓存中。</p>
<p>现在，我们将创建一个 shell 脚本，通过一个 cron 调度任务在每天下午2点自动清除RAM缓存。如下创建一个 shell 脚本 <em>clearcache.sh </em>并在其中添加以下行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment"># 注意，我们这里使用了 "echo 3"，但是不推荐使用在产品环境中，应该使用 "echo 1"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"echo 3 &gt; /proc/sys/vm/drop_caches"</span></div></pre></td></tr></table></figure>

<p>给<em>clearcache.sh</em>文件设置执行权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chmod 755 clearcache.sh</span></div></pre></td></tr></table></figure>

<p>现在，当你需要清除内存缓存时只需要调用脚本。</p>
<p>现在设置一个每天下午2点的定时任务来清除RAM缓存，打开crontab进行编辑。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># crontab -e</span></div></pre></td></tr></table></figure>

<p>添加以下行，保存并退出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> <span class="number">3</span> * * * /path/to/clearcache.sh</div></pre></td></tr></table></figure>

<p>有关如何创建一个定时任务，更多细节你可以查看我们的文章 <a href="http://www.tecmint.com/11-cron-scheduling-task-examples-in-linux/" target="_blank" rel="external">11 个定时调度任务的例子</a>。</p>
<h4 id="在生产环境的服务器上自动清除RAM是否是一个好主意？">在生产环境的服务器上自动清除RAM是否是一个好主意？</h4>
<p>不！它不是。想想一个情况，当你已经预定脚本在每天下午2点来清除内存缓存。那么其时该脚本会执行并刷新你的内存缓存。在某一天由于某些原因，可能您的网站的在线用户会超过预期地从你的服务器请求资源。</p>
<p>而在这时，按计划调度的脚本运行了，并清除了缓存中的一切。当所有的用户都从磁盘读取数据时，这将导致服务器崩溃并损坏数据库。因此，清除缓存仅在必要时并且在你的预料之中，否则你就是个呆瓜系统管理员。</p>
<h3 id="如何清除Linux的交换空间？">如何清除Linux的交换空间？</h3>
<p>如果你想清除掉Swap空间，你可以运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># swapoff -a && swapon -a</span></div></pre></td></tr></table></figure>

<p>此外，了解有关风险后，您可以将上面的命令添加到cron中。</p>
<p>现在，我们将上面两种命令结合成一个命令，写成正确的脚本来同时清除RAM缓存和交换空间。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches && swapoff -a && swapon -a && printf '\n%s\n' 'Ram-cache and Swap Cleared'</span></div></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su -c 'echo <span class="number">3</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches' && swapoff -a && swapon -a && printf '\n%s\n' '<span class="type">Ram</span>-cache <span class="keyword">and</span> <span class="type">Swap</span> <span class="type">Cleared</span>'</div></pre></td></tr></table></figure>

<p>在测试上面的命令之前，我们在执行脚本前后运行“free -m” 来检查缓存。<br>就是这样，如果你喜欢这篇文章，不要忘记向我们提供您宝贵的意见，让我们知道，您认为在企业和生产环境中清除内存缓存和缓冲区是否是一个好主意？</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2015/05/Clear-RAM-Cache.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原文: <a href="http://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/" target="_blank" rel="external">How to Clear RAM Memory Cache, Buffer and Swap Space on Linux</a>,<br>中文翻译: <a href="https://linux.cn/article-5627-1.html" target="_blank" rel="external">在 Linux 上如何清除内存的 Cache、Buffer 和交换空间</a> by strugglingyouth<br>像任何其他的操作系统一样，GNU/Linux 已经实现的内存管理不仅有效，而且更好。但是，如果有任何进程正在蚕食你的内存，而你想要清除它的话，Linux 提供了一个刷新或清除RAM缓存方法。<br><img src="http://www.tecmint.com/wp-content/uploads/2015/05/Clear-RAM-Cache-in-Linux.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎样在后台模式中登录一个docker容器的bash?]]></title>
    <link href="http://colobu.com/2015/10/30/How-to-get-bash-or-ssh-into-a-running-container-in-background-mode/"/>
    <id>http://colobu.com/2015/10/30/How-to-get-bash-or-ssh-into-a-running-container-in-background-mode/</id>
    <published>2015-10-30T02:22:15.000Z</published>
    <updated>2015-10-30T02:30:52.235Z</updated>
    <content type="html"><![CDATA[<p><a href="">Ask Ubuntu</a>上有人问怎么能login或者ssh一个运行的docker容器。<br>例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run <span class="operator">-d</span> webserver</div><div class="line">webserver is clean image from ubuntu:<span class="number">14.04</span></div><div class="line">$ <span class="built_in">sudo</span> docker ps</div><div class="line">CONTAINER ID  IMAGE            COMMAND    CREATED STATUS  PORTS          NAMES</div><div class="line"><span class="number">665</span>b4a1e17b6  webserver:latest /bin/bash  ...     ...     <span class="number">22</span>/tcp, <span class="number">80</span>/tcp loving_heisenberg</div></pre></td></tr></table></figure>

<p>想进行这样的登录:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run -t -i webserver (or maybe <span class="number">665</span>b4a1e17b6 instead)</div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment"># </span></div><div class="line">However when I run the line above I get new CONTAINER ID</div><div class="line">$ root@<span class="number">42</span>f1e37bd0e5:/<span class="comment">#</span></div></pre></td></tr></table></figure>

<a id="more"></a>
<p>答案是 <a href="https://docs.docker.com/reference/commandline/attach/" target="_blank" rel="external">attach</a>或者最新的<a href="https://docs.docker.com/reference/commandline/exec/" target="_blank" rel="external">exec</a></p>
<p>The answer is docker&#39;s <code>attach</code> command. So for my example above the solution will:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker attach <span class="number">665</span>b4a1e17b6 <span class="comment">#by ID</span></div><div class="line">or</div><div class="line">$ <span class="built_in">sudo</span> docker attach loving_heisenberg <span class="comment">#by Name</span></div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment">#</span></div></pre></td></tr></table></figure>

<p><strong>UPDATE: (docker &gt;= 1.3)</strong> Thanks to <strong>WiR3D</strong> user who suggested another way to get container&#39;s shell. If we use attach we can use only one instance of shell. So if we want open new terminal with new instance of container&#39;s shell, we just need run the following:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker <span class="keyword">exec</span> -i -t <span class="number">665</span>b4a1e17b6 bash <span class="comment">#by ID</span></div><div class="line">or</div><div class="line">$ <span class="built_in">sudo</span> docker <span class="keyword">exec</span> -i -t loving_heisenberg bash <span class="comment">#by Name</span></div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment">#</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="">Ask Ubuntu</a>上有人问怎么能login或者ssh一个运行的docker容器。<br>例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run <span class="operator">-d</span> webserver</div><div class="line">webserver is clean image from ubuntu:<span class="number">14.04</span></div><div class="line">$ <span class="built_in">sudo</span> docker ps</div><div class="line">CONTAINER ID  IMAGE            COMMAND    CREATED STATUS  PORTS          NAMES</div><div class="line"><span class="number">665</span>b4a1e17b6  webserver:latest /bin/bash  ...     ...     <span class="number">22</span>/tcp, <span class="number">80</span>/tcp loving_heisenberg</div></pre></td></tr></table></figure>

<p>想进行这样的登录:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> docker run -t -i webserver (or maybe <span class="number">665</span>b4a1e17b6 instead)</div><div class="line">$ root@<span class="number">665</span>b4a1e17b6:/<span class="comment"># </span></div><div class="line">However when I run the line above I get new CONTAINER ID</div><div class="line">$ root@<span class="number">42</span>f1e37bd0e5:/<span class="comment">#</span></div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Docker" scheme="http://colobu.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动H5前端性能优化指南]]></title>
    <link href="http://colobu.com/2015/10/30/h5-performance/"/>
    <id>http://colobu.com/2015/10/30/h5-performance/</id>
    <published>2015-10-30T01:53:50.000Z</published>
    <updated>2015-10-30T02:10:03.938Z</updated>
    <content type="html"><![CDATA[<p>腾讯出品的前端性能优化指南： <a href="http://isux.tencent.com/h5-performance.html" target="_blank" rel="external">原文</a>,<br>另外比较知名的很早的一篇前端优化规则是Yahoo出品的，现在依然有效。 <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">Best Practices for Speeding Up Your Web Site</a>, 中文<a href="http://segmentfault.com/a/1190000000735395" target="_blank" rel="external">Yahoo前端优化性能规则</a></p>
<p>以下是腾讯的移动h5前端性能优化指南全文：<br><a id="more"></a><br><img src="html5.png" alt=""></p>
<h2 id="概述">概述</h2>
<ol>
<li>PC优化手段在Mobile侧同样适用</li>
<li>在Mobile侧我们提出<strong>三秒种渲染完成首屏指标</strong></li>
<li>基于第二点，首屏加载3秒完成或使用Loading</li>
<li>基于联通3G网络平均338KB/s(2.71Mb/s)，所以<strong>首屏资源不应超过1014KB</strong></li>
<li>Mobile侧因手机配置原因，除加载外渲染速度也是优化重点</li>
<li>基于第五点，要合理处理代码减少渲染损耗</li>
<li>基于第二、第五点，<strong>所有影响首屏加载和渲染的代码应在处理逻辑中后置</strong></li>
<li>加载完成后用户交互使用时也需注意性能</li>
</ol>
<h2 id="优化指南">优化指南</h2>
<h3 id="加载优化">加载优化</h3>
<p>加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点</p>
<h4 id="减少HTTP请求">减少HTTP请求</h4>
<p>因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个<br>a) 合并CSS、JavaScript<br>b) 合并小图片，使用雪碧图</p>
<h4 id="缓存">缓存</h4>
<p>使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）<br>a) 缓存一切可缓存的资源<br>b) 使用长Cache（使用时间戳更新Cache）<br>c) 使用外联式引用CSS、JavaScript</p>
<h4 id="压缩HTML、CSS、JavaScript">压缩HTML、CSS、JavaScript</h4>
<p>减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip<br>a) 压缩（例如，多余的空格、换行符和缩进）<br>b) 启用GZip</p>
<h4 id="无阻塞">无阻塞</h4>
<p>写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载</p>
<h4 id="使用首屏加载">使用首屏加载</h4>
<p>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化</p>
<h4 id="按需加载">按需加载</h4>
<p>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量<br>PS：按需加载会导致大量重绘，影响渲染性能<br>a) LazyLoad<br>b) 滚屏加载<br>c) 通过Media Query加载</p>
<h4 id="预加载">预加载</h4>
<p>大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失<br>对用户行为分析，可以在当前页加载下一页资源，提升速度<br>a) 可感知Loading(如进入空间游戏的Loading)<br>b) 不可感知的Loading（如提前加载下一页）</p>
<h4 id="压缩图片">压缩图片</h4>
<p>图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示<br>PS：过度压缩图片大小影响图片显示效果<br>a) 使用智图（ <a href="http://zhitu.tencent.com/" target="_blank" rel="external">http://zhitu.tencent.com/</a> ）<br>b) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)<br>c) 使用Srcset<br>d) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)<br>e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））</p>
<h4 id="减少Cookie">减少Cookie</h4>
<p>Cookie会影响加载速度，所以静态资源域名不使用Cookie</p>
<h4 id="避免重定向">避免重定向</h4>
<p>重定向会影响加载速度，所以在服务器正确设置避免重定向</p>
<h4 id="异步加载第三方资源">异步加载第三方资源</h4>
<p>第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源</p>
<h3 id="脚本执行优化">脚本执行优化</h3>
<p>脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意</p>
<h4 id="CSS写在头部，JavaScript写在尾部或异步">CSS写在头部，JavaScript写在尾部或异步</h4>
<h4 id="避免图片和iFrame等的空Src">避免图片和iFrame等的空Src</h4>
<p>空Src会重新加载当前页面，影响速度和效率</p>
<h4 id="尽量避免重设图片大小">尽量避免重设图片大小</h4>
<p>重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能</p>
<h4 id="图片尽量避免使用DataURL">图片尽量避免使用DataURL</h4>
<p>DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长</p>
<h3 id="CSS优化">CSS优化</h3>
<h4 id="尽量避免写在HTML标签中写Style属性">尽量避免写在HTML标签中写Style属性</h4>
<h4 id="避免CSS表达式">避免CSS表达式</h4>
<p>CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式</p>
<h4 id="移除空的CSS规则">移除空的CSS规则</h4>
<p>空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则</p>
<h4 id="正确使用Display的属性">正确使用Display的属性</h4>
<p>Display属性会影响页面的渲染，因此请合理使用<br>a) display:inline后不应该再使用width、height、margin、padding以及float<br>b) display:inline-block后不应该再使用float<br>c) display:block后不应该再使用vertical-align<br>d) display:table-*后不应该再使用margin或者float</p>
<h4 id="不滥用Float">不滥用Float</h4>
<p>Float在渲染时计算量比较大，尽量减少使用</p>
<h4 id="不滥用Web字体">不滥用Web字体</h4>
<p>Web字体需要下载，解析，重绘当前页面，尽量减少使用</p>
<h4 id="不声明过多的Font-size">不声明过多的Font-size</h4>
<p>过多的Font-size引发CSS树的效率</p>
<h4 id="值为0时不需要任何单位">值为0时不需要任何单位</h4>
<p>为了浏览器的兼容性和性能，值为0时不要带单位</p>
<h4 id="标准化各种浏览器前缀">标准化各种浏览器前缀</h4>
<p>a) 无前缀应放在最后<br>b) CSS动画只用 （-webkit- 无前缀）两种即可<br>c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）</p>
<h4 id="避免让选择符看起来像正则表达式">避免让选择符看起来像正则表达式</h4>
<p>高级选择器执行耗时长且不易读懂，避免使用</p>
<h3 id="JavaScript执行优化">JavaScript执行优化</h3>
<h4 id="减少重绘和回流">减少重绘和回流</h4>
<p>a) 避免不必要的Dom操作<br>b) 尽量改变Class而不是Style，使用classList代替className<br>c) 避免使用document.write<br>d) 减少drawImage</p>
<h4 id="缓存Dom选择与计算">缓存Dom选择与计算</h4>
<p>每次Dom选择都要计算，缓存他</p>
<h4 id="缓存列表-length">缓存列表.length</h4>
<p>每次.length都要计算，用一个变量保存这个值</p>
<h4 id="尽量使用事件代理，避免批量绑定事件">尽量使用事件代理，避免批量绑定事件</h4>
<h4 id="尽量使用ID选择器">尽量使用ID选择器</h4>
<p>ID选择器是最快的</p>
<h4 id="TOUCH事件优化">TOUCH事件优化</h4>
<p>使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作</p>
<h3 id="渲染优化">渲染优化</h3>
<h4 id="HTML使用Viewport">HTML使用Viewport</h4>
<p>Viewport可以加速页面的渲染，请使用以下代码</p>
<meta name="”viewport”" content="”width=device-width," initial-scale="1″">

<h4 id="减少Dom节点">减少Dom节点</h4>
<p>Dom节点太多影响页面的渲染，应尽量减少Dom节点</p>
<h4 id="动画优化">动画优化</h4>
<p>a) 尽量使用CSS3动画<br>b) 合理使用requestAnimationFrame动画代替setTimeout<br>c) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）</p>
<h4 id="高频事件优化">高频事件优化</h4>
<p>Touchmove、Scroll 事件可导致多次渲染<br>a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染<br>b) 增加响应变化的时间间隔，减少重绘次数</p>
<h4 id="GPU加速">GPU加速</h4>
<p>CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用<br>PS：过渡使用会引发手机过耗电增加</p>
<p><strong>参考资料</strong></p>
<ul><br><li><a target="_blank" href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201412/293834.shtml">移动页面性能优化</a></li><br><li><a target="_blank" href="https://github.com/cssmagic/blog/issues/20">[译]&nbsp;如何做到一秒渲染一个移动页面</a></li><br><li><a target="_blank" href="http://lists.w3.org/Archives/Public/public-html-ig-zh/2014May/0005.html">首屏渲染优化提案反馈（原：Re:&nbsp;答复:&nbsp;中文兴趣小组5月5日电话会议）</a></li><br><li><a target="_blank" href="http://isux.tencent.com/html5-game-development-cheats.html">HTML5游戏前端开发秘籍</a></li><br><li><a target="_blank" href="http://isux.tencent.com/emancipate-gpu.html">被解放的GPU</a></li><br><li><a target="_blank" href="http://s5s5.github.io/CSS-Animations/">CSS动画</a></li><br><li><a target="_blank" href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">High Performance Animations</a></li><br><li><a target="_blank" href="https://developers.google.com/speed/docs/insights/rules">PageSpeed Insights规则</a></li><br><li><a target="_blank" href="https://developer.yahoo.com/performance/rules.html">Best Practices for Speeding Up Your Web Site</a></li><br><li><a target="_blank" href="http://browserdiet.com/en/">How to lose weight (in the browser)</a></li><br><li><a target="_blank" href="http://nomospace.github.io/posts/css-lint.html">关注&nbsp;CSS Lint</a></li><br><li><a target="_blank" href="http://blog.91gaoqing.com/archives/146.html">HTML5应用开发功耗调优化小结</a></li><br><li><a target="_blank" href="http://blog.csdn.net/milado_nju/article/details/39271463">理解WebKit和Chromium: Chromium WebView和Chrome浏览器渲染机制</a></li><br><li><a target="_blank" href="https://developers.google.com/web/fundamentals/performance/">Optimizing Performance — Web Fundamentals</a></li><br><li><a target="_blank" href="http://www.w3cfuns.com/article-5601016-1-1.html">移动前端工作的那些事—前端制作之动画效率问题简析</a></li><br><li><a target="_blank" href="http://www.sitepoint.com/optimizing-critical-rendering-path/">Optimizing the Critical Rendering Path</a></li><br><li><a target="_blank" href="http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/">7&nbsp;天打造前端性能监控系统</a></li><br><li><a target="_blank" href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201411/291773.shtml">数据驱动设计</a></li><br><li><a target="_blank" href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201404/258325.shtml">为你的移动页面寻找一丝新意（技术篇）——手机互动网页项目总结（下）</a></li><br><li><a target="_blank" href="http://www.imageoptimization.info/">Image Optimization</a></li><br><li><a target="_blank" href="http://www.cnblogs.com/yexiaochai/p/3759959.html">[webapp的优化整理]要做移动前端优化的朋友进来看看吧</a></li><br><li><a target="_blank" href="http://www.egret-labs.org/blog/3097.html">Egret Framework Canvas Renderer性能优化</a></li><br><li><a target="_blank" href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">Roundup on Parallel Connections</a></li><br><li><a target="_blank" href="http://www.speedtest.cn/info/2014-8th">2014年第二季度全国网速实测报告</a></li><br></ul>]]></content>
    <summary type="html">
    <![CDATA[<p>腾讯出品的前端性能优化指南： <a href="http://isux.tencent.com/h5-performance.html" target="_blank" rel="external">原文</a>,<br>另外比较知名的很早的一篇前端优化规则是Yahoo出品的，现在依然有效。 <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">Best Practices for Speeding Up Your Web Site</a>, 中文<a href="http://segmentfault.com/a/1190000000735395" target="_blank" rel="external">Yahoo前端优化性能规则</a></p>
<p>以下是腾讯的移动h5前端性能优化指南全文：<br>]]>
    
    </summary>
    
      <category term="html5" scheme="http://colobu.com/tags/html5/"/>
    
      <category term="前端开发" scheme="http://colobu.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于Golang将MongoDB的数据同步到Elasticsearch]]></title>
    <link href="http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/"/>
    <id>http://colobu.com/2015/10/27/Sync-Transformed-Data-from-MongoDB-to-Elasticsearch/</id>
    <published>2015-10-27T08:49:45.000Z</published>
    <updated>2015-10-30T03:26:15.212Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.elastic.co/" target="_blank" rel="external">Elasticsearch</a>是一个分布式可扩展的实时搜索和分析引擎。它能帮助你搜索、分析和浏览数据。Elasticsearch 是一个基于Lucene实现的搜索服务器，用Java开发实现。它提供了RESTful web接口，并作为Apache许可条款下的开放源码发布，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>Elasticsearch关键概念</p>
<p><dl></dl></p>
<p><dt>Cluster集群</dt></p>
<dd>有相同集群名称的节点Node的集合。集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</dd><br><br><dt>Cluster集群</dt><br><dd></dd><br><dt>Node节点</dt><br><dd>一个elasticsearch运行的实例。其实就是一个java进程。一般情况下，一台机器运行在一台机器上。</dd><br><dt>Shards分片</dt><br><dd>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</dd><br><dt>Replicas副本</dt><br><dd>代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</dd><br><dt>Recovery恢复</dt><br><dd>代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</dd><br><dt>River</dt><br><dd>代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。River在1.5中弃用了，2.0中移除了。</dd><br><dt>Gateway</dt><br><dd>代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</dd><br><dt>Discovery.zen</dt><br><dd>代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过多播协议来进行节点之间的通信，同时也支持点对点的交互。</dd><br><dt>Transport</dt><br><dd>代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、thrift、servlet、memcached、zeroMQ等的传输协议（通过插件方式集成）。</dd><br><dt>Index索引</dt><br><dd>Elasticsearch用来存储数据的逻辑区域，它类似于关系型数据库中的table概念。一个index可以在一个或者多个shard上面，同时一个shard也可能会有多个replicas。</dd><br><dt>Document</dt><br><dd>Elasticsearch里面存储的实体数据，类似于关系数据中一个table里面的一行数据。 document由多个field组成，不同的document里面同名的field一定具有相同的类型。document里面field可以重复出现，也就是一个field会有多个值，即multivalued。</dd><br><dt>Document type</dt><br><dd>为了查询需要，一个index可能会有多种document，也就是document type，但需要注意，不同document里面同名的field一定要是相同类型的。</dd><br><dt>Mapping</dt><br><dd>存储field的相关映射信息，不同document type会有不同的mapping。</dd>

<a id="more"></a>
<p>本文不是介绍Elasticsearch的安装配置文档，这些文档你可以在本文的参考资料中获得， 而是笔者在项目中的实践笔记。<br>我最近在开发过程中需要将Mongo数据库中的文章进行索引， 避免直接对Mongo数据库进行搜索导致的性能降低。基于Elasticsearch的手册的描述，以及在一些大公司如twitter的应用的经验，我选用它作为现在的项目的索引服务器。</p>
<p>现在的项目是Golang语言实现的，所以我调研的目标放在了Golang + MongoDB + Elasticsearch上面。</p>
<p><a href="https://github.com/richardwilly98/elasticsearch-river-mongodb" target="_blank" rel="external">elasticsearch-river-mongodb</a>是一个针对Mongo的elasticsearch river的插件。它从Mongo oplog中读取信息，将Mongo集群中的数据导入到 elasticsearch 中。考虑到river被弃用，暂时不考虑这个方案。</p>
<p>mandeepm91在文章 <a href="https://www.digitalocean.com/community/tutorials/how-to-sync-transformed-data-from-mongodb-to-elasticsearch-with-transporter-on-ubuntu-14-04" target="_blank" rel="external">How To Sync Transformed Data from MongoDB to Elasticsearch with Transporter on Ubuntu 14.04</a>提到了另外一个工具 <a href="https://github.com/compose/transporter" target="_blank" rel="external">Transporter</a>,这是一个相当好的工具，可以抽取Mongo单例或者Mongo集群的数据，然后使用<a href="https://github.com/robertkrimen/otto" target="_blank" rel="external">otto框架</a>进行Javascript处理，而且处理是通道式的。在调研中很容易的将Mongo数据库导入到Elasticsearch。</p>
<p>不过我也没有采用这个方案。因为我的项目中，对文章的增删改的动作比较少，可以直接调用Elasticsearch的API进行操作。而且这样可以做到数据的实时索引和查询。</p>
<p>上面的方案多少会影响服务器的性能，有可能会block在Elasticsearch的API调用上。 所以我在增删改文章时，将操作命令的log放入到一个消息服务器中(<a href="https://github.com/nsqio/nsq" target="_blank" rel="external">nsq</a>或者<a href="http://kafka.apache.org/" target="_blank" rel="external">kafka</a>)，然后在单独的一台服务器上接收消息并调用Elasticsearch的API。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-sync-transformed-data-from-mongodb-to-elasticsearch-with-transporter-on-ubuntu-14-04" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-sync-transformed-data-from-mongodb-to-elasticsearch-with-transporter-on-ubuntu-14-04</a></li>
<li><a href="https://github.com/compose/transporter" target="_blank" rel="external">https://github.com/compose/transporter</a></li>
<li><a href="http://www.learnes.net/" target="_blank" rel="external">Elasticsearch 权威指南</a></li>
<li><a href="https://www.gitbook.com/book/endymecy/elasticsearch-guide-chinese/details" target="_blank" rel="external">elasticsearch中文指南</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html</a></li>
<li><a href="https://github.com/mattbaird/elastigo" target="_blank" rel="external">https://github.com/mattbaird/elastigo</a></li>
<li><a href="https://github.com/olivere/elastic" target="_blank" rel="external">https://github.com/olivere/elastic</a></li>
<li><a href="https://github.com/richardwilly98/elasticsearch-river-mongodb" target="_blank" rel="external">https://github.com/richardwilly98/elasticsearch-river-mongodb</a></li>
<li><a href="http://baike.baidu.com/item/elasticsearch" target="_blank" rel="external">http://baike.baidu.com/item/elasticsearch</a></li>
<li><a href="https://www.elastic.co/blog/deprecating-rivers" target="_blank" rel="external">https://www.elastic.co/blog/deprecating-rivers</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://www.elastic.co/" target="_blank" rel="external">Elasticsearch</a>是一个分布式可扩展的实时搜索和分析引擎。它能帮助你搜索、分析和浏览数据。Elasticsearch 是一个基于Lucene实现的搜索服务器，用Java开发实现。它提供了RESTful web接口，并作为Apache许可条款下的开放源码发布，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>Elasticsearch关键概念</p>
<p><dl></dl></p>
<p><dt>Cluster集群</dt></p>
<dd>有相同集群名称的节点Node的集合。集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</dd><br><br><dt>Cluster集群</dt><br><dd></dd><br><dt>Node节点</dt><br><dd>一个elasticsearch运行的实例。其实就是一个java进程。一般情况下，一台机器运行在一台机器上。</dd><br><dt>Shards分片</dt><br><dd>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</dd><br><dt>Replicas副本</dt><br><dd>代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</dd><br><dt>Recovery恢复</dt><br><dd>代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</dd><br><dt>River</dt><br><dd>代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。River在1.5中弃用了，2.0中移除了。</dd><br><dt>Gateway</dt><br><dd>代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</dd><br><dt>Discovery.zen</dt><br><dd>代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过多播协议来进行节点之间的通信，同时也支持点对点的交互。</dd><br><dt>Transport</dt><br><dd>代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、thrift、servlet、memcached、zeroMQ等的传输协议（通过插件方式集成）。</dd><br><dt>Index索引</dt><br><dd>Elasticsearch用来存储数据的逻辑区域，它类似于关系型数据库中的table概念。一个index可以在一个或者多个shard上面，同时一个shard也可能会有多个replicas。</dd><br><dt>Document</dt><br><dd>Elasticsearch里面存储的实体数据，类似于关系数据中一个table里面的一行数据。 document由多个field组成，不同的document里面同名的field一定具有相同的类型。document里面field可以重复出现，也就是一个field会有多个值，即multivalued。</dd><br><dt>Document type</dt><br><dd>为了查询需要，一个index可能会有多种document，也就是document type，但需要注意，不同document里面同名的field一定要是相同类型的。</dd><br><dt>Mapping</dt><br><dd>存储field的相关映射信息，不同document type会有不同的mapping。</dd>

]]>
    
    </summary>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="mongo" scheme="http://colobu.com/tags/mongo/"/>
    
      <category term="elasticsearch" scheme="http://colobu.com/tags/elasticsearch/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongodb 定期备份]]></title>
    <link href="http://colobu.com/2015/10/27/mongodb-backup/"/>
    <id>http://colobu.com/2015/10/27/mongodb-backup/</id>
    <published>2015-10-27T02:43:43.000Z</published>
    <updated>2015-10-27T03:02:57.802Z</updated>
    <content type="html"><![CDATA[<p>在生产系统中，数据库的备份是必要的，否则当服务器被攻击，硬盘坏掉，运维误删等原因将数据库干掉的时候就欲哭无泪了。</p>
<p>备份MongoDB数据库常见的方式有三种：</p>
<ul>
<li>使用[MongoDB管理服务（MMS）(<a href="https://mms.mongodb.com/)进行云备份" target="_blank" rel="external">https://mms.mongodb.com/)进行云备份</a></li>
<li>使用文件系统快照</li>
<li>使用MongoDB自身的mongodump工具</li>
</ul>
<p>本文介绍第三种简单的备份，对于备份数据量不是太大的数据库还是很有效的。<br><a id="more"></a></p>
<p>Sheharyar Naseer在<a href="https://sheharyar.me/blog/regular-mongo-backups-using-cron/" target="_blank" rel="external">Regular Mongo Backups Using Cron</a>一文中提供了一个简单的脚本mongo_backup.sh：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"></div><div class="line">MONGO_DATABASE=<span class="string">"your_db_name"</span></div><div class="line">APP_NAME=<span class="string">"your_app_name"</span></div><div class="line"></div><div class="line">MONGO_HOST=<span class="string">"127.0.0.1"</span></div><div class="line">MONGO_PORT=<span class="string">"27017"</span></div><div class="line">TIMESTAMP=`date +%F-%H%M`</div><div class="line">MONGODUMP_PATH=<span class="string">"/usr/bin/mongodump"</span></div><div class="line">BACKUPS_DIR=<span class="string">"/home/username/backups/<span class="variable">$APP_NAME</span>"</span></div><div class="line">BACKUP_NAME=<span class="string">"<span class="variable">$APP_NAME</span>-<span class="variable">$TIMESTAMP</span>"</span></div><div class="line"></div><div class="line"><span class="comment"># mongo admin --eval "printjson(db.fsyncLock())"</span></div><div class="line"><span class="comment"># $MONGODUMP_PATH -h $MONGO_HOST:$MONGO_PORT -d $MONGO_DATABASE</span></div><div class="line"><span class="variable">$MONGODUMP_PATH</span> <span class="operator">-d</span> <span class="variable">$MONGO_DATABASE</span></div><div class="line"><span class="comment"># mongo admin --eval "printjson(db.fsyncUnlock())"</span></div><div class="line"></div><div class="line">mkdir -p <span class="variable">$BACKUPS_DIR</span></div><div class="line">mv dump <span class="variable">$BACKUP_NAME</span></div><div class="line">tar -zcvf <span class="variable">$BACKUPS_DIR</span>/<span class="variable">$BACKUP_NAME</span>.tgz <span class="variable">$BACKUP_NAME</span></div><div class="line">rm -rf <span class="variable">$BACKUP_NAME</span></div></pre></td></tr></table></figure>

<p>View <a href="https://gist.github.com/sheharyarn/0f04c1ba18462cddaaf5" target="_blank" rel="external">Gist</a> on Github</p>
<p>如果你想在备份的时候锁住数据库，避免备份的时候有更新操作，可以uncomment <code>fsyncLock</code> 和 <code>fsyncUnlock</code>这两行。</p>
<p>然后将其加入到cron中:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab <span class="operator">-e</span></div></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">00</span> <span class="number">00</span> * * * /bin/bash /home/username/scripts/mongo_backup.sh</div></pre></td></tr></table></figure>

<p>micahwedemeyer提供了更强大的一个脚本<a href="https://github.com/micahwedemeyer/automongobackup/blob/master/src/automongobackup.sh" target="_blank" rel="external">automongobackup.sh</a>，提供了更强大的备份的功能。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="http://www.infoq.com/cn/articles/mongodb-deployment-backup-security" target="_blank" rel="external">http://www.infoq.com/cn/articles/mongodb-deployment-backup-security</a></li>
<li><a href="https://docs.mongodb.org/manual/reference/program/mongodump/" target="_blank" rel="external">https://docs.mongodb.org/manual/reference/program/mongodump/</a></li>
<li><a href="https://docs.mongodb.org/manual/reference/program/mongorestore/" target="_blank" rel="external">https://docs.mongodb.org/manual/reference/program/mongorestore/</a></li>
<li><a href="https://sheharyar.me/blog/regular-mongo-backups-using-cron/" target="_blank" rel="external">https://sheharyar.me/blog/regular-mongo-backups-using-cron/</a></li>
<li><a href="https://github.com/micahwedemeyer/automongobackup" target="_blank" rel="external">https://github.com/micahwedemeyer/automongobackup</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在生产系统中，数据库的备份是必要的，否则当服务器被攻击，硬盘坏掉，运维误删等原因将数据库干掉的时候就欲哭无泪了。</p>
<p>备份MongoDB数据库常见的方式有三种：</p>
<ul>
<li>使用[MongoDB管理服务（MMS）(<a href="https://mms.mongodb.com/)进行云备份" target="_blank" rel="external">https://mms.mongodb.com/)进行云备份</a></li>
<li>使用文件系统快照</li>
<li>使用MongoDB自身的mongodump工具</li>
</ul>
<p>本文介绍第三种简单的备份，对于备份数据量不是太大的数据库还是很有效的。<br>]]>
    
    </summary>
    
      <category term="mongo" scheme="http://colobu.com/tags/mongo/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nginx 限流]]></title>
    <link href="http://colobu.com/2015/10/26/nginx-limit-modules/"/>
    <id>http://colobu.com/2015/10/26/nginx-limit-modules/</id>
    <published>2015-10-26T08:37:22.000Z</published>
    <updated>2015-11-03T06:26:43.341Z</updated>
    <content type="html"><![CDATA[<p>电商平台营销时候，经常会碰到的大流量问题，除了做流量分流处理，可能还要做用户黑白名单、信誉分析，进而根据用户ip信誉权重做相应的流量拦截、限制流量。<br>Nginx自身有的请求限制模块<a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="external">ngx_http_limit_req_module</a>、流量限制模块<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html" target="_blank" rel="external">ngx_stream_limit_conn_module</a>基于令牌桶算法，可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制。</p>
<p>对于提供下载的网站，肯定是要进行流量控制的，例如软件下载站、视频服务等。<br>它也可以减少一些爬虫程序或者DDOS的攻击。</p>
<p>对这两个模块的介绍的文章也不少，这里转载一篇<a href="http://hopestar.github.io/" target="_blank" rel="external">hopestar</a>的文章: <a href="http://hopestar.github.io/2013/06/08/nginx-limit-moule-note/" target="_blank" rel="external">nginx限制IP连接数的范例参考</a>， 因为他介绍的很简洁。</p>
<blockquote>
<p> 下面文章的limit_zone指令已经被弃用，请用limit_conn_zone替换<br><a id="more"></a></p>
</blockquote>
<hr>
<p>如何Nginx限制同一个ip的连接数，限制并发数目:</p>
<h3 id="限流">限流</h3>
<h4 id="(1)_添加limit_zone和limit_req_zone">(1) 添加limit_zone和limit_req_zone</h4>
<p>这个变量只能在http使用 :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">vi</span> /export/servers/nginx/conf/nginx.conf </div><div class="line">limit_zone one  <span class="variable">$binary_remote_addr</span>  <span class="number">20m</span>;</div><div class="line"><span class="title">limit_req_zone</span>  <span class="variable">$binary_remote_addr</span>  zone=req_one:<span class="number">20m</span> rate=12r/s;</div></pre></td></tr></table></figure>

<h4 id="(2)_添加limit_conn_和limit_req">(2) 添加limit_conn 和limit_req</h4>
<p>这个变量可以在<code>http</code>, <code>server</code>, <code>location</code>使用 我是限制nginx上的所有服务，所以添加到http里面 （如果你需要限制部分服务，可在nginx/conf/domains里面选择相应的server或者location添加上便可）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">vi</span> /export/servers/nginx/conf/nginx.conf </div><div class="line"></div><div class="line">limit_zone one <span class="variable">$binary_remote_addr</span> <span class="number">20m</span>;</div><div class="line"><span class="title">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=req_one:<span class="number">20m</span> rate=12r/s;</div><div class="line"><span class="title">limit_conn</span> one <span class="number">10</span>;</div><div class="line"><span class="title">limit_req</span> zone=req_one burst=<span class="number">120</span>;</div></pre></td></tr></table></figure>

<p>参数详解(数值按具体需要和服务器承载能力设置,):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">limit_zone，是针对每个变量(这里指<span class="literal">IP</span>，即$binary_remote_addr)定义一个存储session状态的容器。这个示例中定义了一个20m的容器，按照32bytes/session，可以处理<span class="number">640000</span>个session。</div><div class="line">limit_req_zone 与limit_zone类似。rate是请求频率. 每秒允许<span class="number">12</span>个请求。</div><div class="line">limit_conn  one <span class="number">10</span> : 表示一个<span class="literal">IP</span>能发起<span class="number">10</span>个并发连接数</div><div class="line"><span class="label">limit_req:</span> 与limit_req_zone对应。burst表示缓存住的请求数。</div></pre></td></tr></table></figure>

<p>范例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="title">http</span></div><div class="line">{</div><div class="line"><span class="title">limit_zone</span> one  <span class="variable">$binary_remote_addr</span>  <span class="number">20m</span>;</div><div class="line"><span class="title">limit_req_zone</span>  <span class="variable">$binary_remote_addr</span>  zone=req_one:<span class="number">20m</span> rate=12r/s;</div><div class="line"><span class="title">limit_conn</span>   one  <span class="number">10</span>;</div><div class="line"><span class="title">limit_req</span>   zone=req_one burst=<span class="number">120</span>;</div><div class="line"></div><div class="line"><span class="title">server</span>  {</div><div class="line">        <span class="title">listen</span>          <span class="number">80</span>;</div><div class="line">        <span class="title">server_name</span>     status.xxx.com ;</div><div class="line"></div><div class="line">        <span class="title">location</span> / {</div><div class="line">                 <span class="title">stub_status</span>            <span class="built_in">on</span>;</div><div class="line">                 <span class="title">access_log</span>             <span class="built_in">off</span>;</div><div class="line">        }</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="(3)_重启nginx">(3) 重启nginx</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/<span class="keyword">export</span>/servers/nginx/sbin/nginx <span class="operator">-s</span> reload</div></pre></td></tr></table></figure>

<p>Nginx限制流量/限制带宽 具体参考官方文档</p>
<h3 id="nginx白名单设置">nginx白名单设置</h3>
<p>以上配置会对所有的ip都进行限制，有些时候我们不希望对搜索引擎的蜘蛛或者某些自己的代理机过来的请求进行限制， 对于特定的白名单ip我们可以借助geo指令实现。</p>
<p>先在nginx的请求日志进行统计，查看那个ip的访问量比较大， 运行:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> access.<span class="built_in">log</span> | <span class="keyword">grep</span> <span class="string">"03/Jun"</span> |awk <span class="string">'{print $1}'</span>|<span class="built_in">sort</span> |uniq -<span class="keyword">c</span>|<span class="built_in">sort</span> -nrk <span class="number">1</span>|head -<span class="keyword">n</span> <span class="number">10</span></div><div class="line">#列出访问日志里面在<span class="number">6</span>月<span class="number">3</span>号这天前<span class="number">10</span>个访问量最大的ip.</div></pre></td></tr></table></figure>

<p>接下来就可以对这些IP进行分析了。看哪些需要进行白名单设置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> http{</div><div class="line">     geo  <span class="variable">$limited</span>  { <span class="comment"># the variable created is $limited</span></div><div class="line">      <span class="keyword">default</span>          <span class="number">1</span>;</div><div class="line">      <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">32</span>     <span class="number">0</span>;</div><div class="line">      <span class="number">10.12</span><span class="number">.212</span><span class="number">.63</span>     <span class="number">0</span>;</div><div class="line">    }</div><div class="line">    map <span class="variable">$limited</span> <span class="variable">$limit</span> {</div><div class="line">    <span class="number">1</span> <span class="variable">$binary_remote_addr</span>;</div><div class="line">    <span class="number">0</span> <span class="string">""</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    limit_zone one  <span class="variable">$binary_remote_addr</span>  <span class="number">20</span>m;</div><div class="line">    limit_req_zone  <span class="variable">$limit</span>  zone=req_one:<span class="number">20</span>m rate=<span class="number">20</span>r/s;</div><div class="line">    limit_conn   one  <span class="number">10</span>;</div><div class="line">    limit_req   zone=req_one burst=<span class="number">120</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面两个需要用到map和geo模块，这是nginx自带的模块，有的运维喜欢把他们关闭，自己<code>./sbin/nginx -V</code> 留意一下。把配置的<code>--whithout-XXX-module</code> 去掉重新编译一下就可以了。 上面这段配置的意思是：</p>
<p>1.geo指令定义了一个白名单$limited变量，默认值为1，如果客户端ip在上面的范围内，$limited的值为0<br>2.使用map指令映射搜索引擎客户端的ip为空串，如果不是搜索引擎就显示本身真实的ip，这样搜索引擎ip就不能存到limit_req_zone内存session中，所以不会限制搜索引擎的ip访问</p>
<h3 id="PS:获取客户端的真实IP">PS:获取客户端的真实IP</h3>
<p>顺带一提，为了获取客户端的真实IP。该模块需要安装read_ip模块，运维应该默认有安装。没有的话也可自行安装： 配置方式相当简单，重新编译 Nginx 加上 --with-http_realip_module 参数，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">.</span><span class="comment">/configure</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">prefix=/opt/nginx</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">with</span><span class="literal">-</span><span class="comment">http_stub_status_module</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">with</span><span class="literal">-</span><span class="comment">pcre=</span><span class="string">.</span><span class="string">.</span><span class="comment">/pcre</span><span class="literal">-</span><span class="comment">6</span><span class="string">.</span><span class="comment">6</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">with</span><span class="literal">-</span><span class="comment">http_realip_module</span></div><div class="line"><span class="comment">make</span></div><div class="line"><span class="comment">make</span> <span class="comment">install</span></div></pre></td></tr></table></figure>

<p>在server中增加:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">set_real_ip_from</span>   <span class="number">192.168.1.0</span>/<span class="number">24</span>;</div><div class="line"><span class="title">set_real_ip_from</span>   <span class="number">192.168.2.1</span>;</div><div class="line"><span class="title">real_ip_header</span>     [X-Real-IP|X-Forwarded-For];</div></pre></td></tr></table></figure>

<p>需要说明的地方就是设置IP源的时候可以设置单个IP，也可以设置IP段，另外是使用X-Real-IP还是X-Forwarded-For，取决于前面的服务器有哪个头。</p>
<p>set_real_ip_from 设置的IP端可以让运维查看日志，看下你的请求是来自哪些ip段。</p>
<p>重新加载一下服务，差不多就OK了。</p>
<p>再查看日志的话，应该可以看到客户端的真实IP了。</p>
<p>注意：如果未安装该模块的话你的获取到的IP端可能是来自前端代理（如squid）的IP，结果就是多个用户被当成单个用户对待，导致应用不能响应。 参考:<a href="http://hi.baidu.com/thinkinginlamp/item/e2cf05263eb4d18e6e2cc3e6" target="_blank" rel="external">http://hi.baidu.com/thinkinginlamp/item/e2cf05263eb4d18e6e2cc3e6</a></p>
<p>再PS一下： 自测: 有条件的自己可以用ab或者webben自测一下。</p>
<p>未安装前压测的话，因为有大量请求，所以access.log会有大量日志，而error.log日志没有变化。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@qrwefsdf talk]# webbench  -<span class="built_in">c</span> <span class="number">30</span> -t <span class="number">30</span> http:<span class="comment">//xxx.com  </span></div><div class="line"><span class="type">Webbench</span> - <span class="type">Simple</span> <span class="type">Web</span> <span class="type">Benchmark</span> <span class="number">1.5</span></div><div class="line"><span class="type">Copyright</span> (<span class="built_in">c</span>) <span class="type">Radim</span> <span class="type">Kolar</span> <span class="number">1997</span>-<span class="number">2004</span>, <span class="type">GPL</span> <span class="type">Open</span> <span class="type">Source</span> <span class="type">Software</span>.</div><div class="line"><span class="type">Benchmarking</span>: <span class="type">GET</span> http:<span class="comment">//xxx.com  </span></div><div class="line"><span class="number">30</span> clients, running <span class="number">30</span> sec.</div><div class="line"><span class="type">Speed</span>=<span class="number">193468</span> pages/<span class="built_in">min</span>, <span class="number">1254317</span> bytes/sec.</div><div class="line"><span class="type">Requests</span>: <span class="number">96734</span> susceed, <span class="number">0</span> failed.</div></pre></td></tr></table></figure>

<p>安装后会发现很多超出的请求会返回503,所以access.log日志变化不快，error.log有大量记录,提示limit_reque缓住了多少请求。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@qrwefsdf talk]# webbench  -<span class="built_in">c</span> <span class="number">30</span> -t <span class="number">30</span> http:<span class="comment">//xxxx.com</span></div><div class="line"><span class="type">Webbench</span> - <span class="type">Simple</span> <span class="type">Web</span> <span class="type">Benchmark</span> <span class="number">1.5</span></div><div class="line"><span class="type">Copyright</span> (<span class="built_in">c</span>) <span class="type">Radim</span> <span class="type">Kolar</span> <span class="number">1997</span>-<span class="number">2004</span>, <span class="type">GPL</span> <span class="type">Open</span> <span class="type">Source</span> <span class="type">Software</span>.</div><div class="line"><span class="type">Benchmarking</span>: <span class="type">GET</span> http:<span class="comment">//xxx.com  </span></div><div class="line"><span class="number">30</span> clients, running <span class="number">30</span> sec.</div><div class="line"><span class="type">Speed</span>=<span class="number">120</span> pages/<span class="built_in">min</span>, <span class="number">778</span> bytes/sec.</div><div class="line"><span class="type">Requests</span>: <span class="number">60</span> susceed, <span class="number">0</span> failed.</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>电商平台营销时候，经常会碰到的大流量问题，除了做流量分流处理，可能还要做用户黑白名单、信誉分析，进而根据用户ip信誉权重做相应的流量拦截、限制流量。<br>Nginx自身有的请求限制模块<a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="external">ngx_http_limit_req_module</a>、流量限制模块<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html" target="_blank" rel="external">ngx_stream_limit_conn_module</a>基于令牌桶算法，可以方便的控制令牌速率，自定义调节限流，实现基本的限流控制。</p>
<p>对于提供下载的网站，肯定是要进行流量控制的，例如软件下载站、视频服务等。<br>它也可以减少一些爬虫程序或者DDOS的攻击。</p>
<p>对这两个模块的介绍的文章也不少，这里转载一篇<a href="http://hopestar.github.io/" target="_blank" rel="external">hopestar</a>的文章: <a href="http://hopestar.github.io/2013/06/08/nginx-limit-moule-note/" target="_blank" rel="external">nginx限制IP连接数的范例参考</a>， 因为他介绍的很简洁。</p>
<blockquote>
<p> 下面文章的limit_zone指令已经被弃用，请用limit_conn_zone替换<br>]]>
    
    </summary>
    
      <category term="nginx" scheme="http://colobu.com/tags/nginx/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Virtualbox mount共享文件夹错误]]></title>
    <link href="http://colobu.com/2015/10/26/virtualbox-mount-shared-folder-error/"/>
    <id>http://colobu.com/2015/10/26/virtualbox-mount-shared-folder-error/</id>
    <published>2015-10-26T07:13:08.000Z</published>
    <updated>2015-10-27T00:54:07.166Z</updated>
    <content type="html"><![CDATA[<p>最近创建了一个Centos 7的虚拟机，使用的是virtualbox 版本 5.0.6 r103037。<br>安装了增强包之后，依然无法挂载共享文件夹，报错如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">...</span>]<span class="comment"># mount -t vboxsf share /mnt/share</span></div><div class="line">/sbin/mount.vboxsf: mounting failed with the error: No such device</div></pre></td></tr></table></figure>

<p>用redhat 6.4是正常的。<br><a href="http://stackoverflow.com/questions/28328775/virtualbox-mount-vboxsf-mounting-failed-with-the-error-no-such-device" target="_blank" rel="external">stackoverflow</a>有人也遇到了这个问题，解决办法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modprobe <span class="operator">-a</span> vboxguest vboxsf vboxvideo</div></pre></td></tr></table></figure>

<p>特别记录下来以备将来查询。</p>
<p>你也可以在<code>/etc/modules-load.d/</code>创建要加载的模块，一个文件加载一个模块，如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/etc/modules-<span class="operator"><span class="keyword">load</span>.d/vboxsf.conf</span></div><div class="line"></div><div class="line"># <span class="keyword">Load</span> vboxsf.ko <span class="keyword">at</span> boot</div><div class="line">vboxsf</div></pre></td></tr></table></figure>

<p>这样启动的时候就将相应的模块加载进来了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近创建了一个Centos 7的虚拟机，使用的是virtualbox 版本 5.0.6 r103037。<br>安装了增强包之后，依然无法挂载共享文件夹，报错如下：</p>
<figure class="highlight"><table><tr><td class="gu]]>
    </summary>
    
      <category term="virtualbox" scheme="http://colobu.com/tags/virtualbox/"/>
    
      <category term="linux" scheme="http://colobu.com/tags/linux/"/>
    
      <category term="Linux" scheme="http://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建超小的Golang docker 镜像]]></title>
    <link href="http://colobu.com/2015/10/12/create-minimal-golang-docker-images/"/>
    <id>http://colobu.com/2015/10/12/create-minimal-golang-docker-images/</id>
    <published>2015-10-12T04:21:19.000Z</published>
    <updated>2015-10-14T07:24:18.212Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.docker.io/" target="_blank" rel="external">Docker</a>是PaaS供应商dotCloud开源的一个基于LXC 的高级容器引擎，源代码托管在 GitHub 上, 基于Go语言开发并遵从Apache 2.0协议开源。正如DockerPool在免费Docker电子书<a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="external">Docker —— 从入门到实践</a>中这样提到的：</p>
<blockquote>
<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
</blockquote>
<p>Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架包括系统。</p>
<a id="more"></a>
<p>本文不会介绍Docker原理和操作，而是介绍如何使用Docker创建一个Golang应用程序的镜像，这样我们就可以在其它机器上运行这个镜像。<br>本文参考了很多的文章，这些文章列在了本文的底部。</p>
<h3 id="编写一个Golang服务器">编写一个Golang服务器</h3>
<p>这里我在研究<a href="https://github.com/fvbock/endless" target="_blank" rel="external">endless</a>库的时候写了一个测试程序，就用它来测试一下docker镜像的创建。<br>endless可以允许我们在重启网络服务器的时候零时间宕机， 英语是graceful restart,我称之为无缝重启。<br>服务器监听4242端口，顺便使用raymond模版引擎替换golang自带的模版引擎，采用bone这个高性能的mux库。<br>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"github.com/aymerick/raymond"</span></div><div class="line">	<span class="string">"github.com/fvbock/endless"</span></div><div class="line">	<span class="string">"github.com/go-zoo/bone"</span></div><div class="line">)</div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">//homeTpl, _ = raymond.ParseFile("home.hbs")</span></div><div class="line">	homeTpl = raymond.MustParse(<span class="string">`&lt;html&gt;</span></div><div class="line">	&lt;head&gt;</div><div class="line">	  &lt;title&gt;test&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">	&lt;div class="entry"&gt;</div><div class="line">	  &lt;h1&gt;&lt;/h1&gt;</div><div class="line">	  &lt;div class="body"&gt;</div><div class="line">	    </div><div class="line">	  &lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">	&lt;/html&gt;</div><div class="line">`)</div><div class="line">)</div><div class="line"><span class="keyword">func</span> homeHandler(rw http.ResponseWriter, req *http.Request) {</div><div class="line">	ctx := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">string</span>{<span class="string">"greet"</span>: <span class="string">"hello"</span>, <span class="string">"name"</span>: <span class="string">"world"</span>}</div><div class="line">	result := homeTpl.MustExec(ctx)</div><div class="line">	rw.Write([]<span class="typename">byte</span>(result))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> varHandler(rw http.ResponseWriter, req *http.Request) {</div><div class="line">	varr := bone.GetValue(req, <span class="string">"var"</span>)</div><div class="line">	test := bone.GetValue(req, <span class="string">"test"</span>)</div><div class="line"></div><div class="line">	rw.Write([]<span class="typename">byte</span>(varr + <span class="string">" "</span> + test))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> Handler404(rw http.ResponseWriter, req *http.Request) {</div><div class="line">	rw.Write([]<span class="typename">byte</span>(<span class="string">"These are not resources you're looking for ..."</span>))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> restartHandler(rw http.ResponseWriter, req *http.Request) {</div><div class="line">	syscall.Kill(syscall.Getppid(), syscall.SIGHUP)</div><div class="line">	rw.Write([]<span class="typename">byte</span>(<span class="string">"restarted"</span>))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line">	mux := bone.New()</div><div class="line">	<span class="comment">// Custom 404</span></div><div class="line">	mux.NotFoundFunc(Handler404)</div><div class="line">	<span class="comment">// Handle with any http method, Handle takes http.Handler as argument.</span></div><div class="line">	mux.Handle(<span class="string">"/index"</span>, http.HandlerFunc(homeHandler))</div><div class="line">	mux.Handle(<span class="string">"/index/:var/info/:test"</span>, http.HandlerFunc(varHandler))</div><div class="line">	<span class="comment">// Get, Post etc... takes http.HandlerFunc as argument.</span></div><div class="line">	mux.Post(<span class="string">"/home"</span>, http.HandlerFunc(homeHandler))</div><div class="line">	mux.Get(<span class="string">"/home/:var"</span>, http.HandlerFunc(varHandler))</div><div class="line">	mux.GetFunc(<span class="string">"/test/*"</span>, <span class="keyword">func</span>(rw http.ResponseWriter, req *http.Request) {</div><div class="line">		rw.Write([]<span class="typename">byte</span>(req.RequestURI))</div><div class="line">	})</div><div class="line">	mux.Get(<span class="string">"/restart"</span>, http.HandlerFunc(restartHandler))</div><div class="line">	err := endless.ListenAndServe(<span class="string">":4242"</span>, mux)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalln(err)</div><div class="line">	}</div><div class="line">	log.Println(<span class="string">"Server on 4242 stopped"</span>)</div><div class="line">	os.Exit<span class="number">(0</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Golang镜像">Golang镜像</h3>
<p>Docker官方提供了Golang各版本的镜像： <a href="https://hub.docker.com/_/golang/" target="_blank" rel="external">Official Repository - golang</a>.<br>它包含了Golang的编译和运行时环境。最简单的使用方法就是在你的<code>Dockerfile</code>文件中加入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM golan<span class="variable">g:1</span>.<span class="number">3</span>-onbuild</div></pre></td></tr></table></figure>

<p>这个镜像包含了多个<code>ONBUILD</code>触发器。你可以编译和运行你的镜像：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker build -t my-golang-app .</div><div class="line">$ docker run -it --rm --name my-running-app my-golang-app</div></pre></td></tr></table></figure>

<h3 id="为编译好的Golang应用创建小的镜像">为编译好的Golang应用创建小的镜像</h3>
<p>上面的Golang容器相当的大，因为它包含了Golang的编译和运行环境。<br>官方网站上列出了镜像的大小：</p>
<blockquote>
<p>golang:1.5.1-onbuild</p>
<p>$ docker pull library/golang@sha256:f938465579d1cde302a447fef237a5a45d7e96609b97c83b9144446615ad9e72</p>
<p>  Total Virtual Size: 709.5 MB (709470237 bytes)<br>   Total v2 Content-Length: 247.0 MB (246986021 bytes)</p>
</blockquote>
<p>实际上我们并不需要那么多的软件，因为我们的Golang应用程序是预先编译好的，而不是在Golang容器中现场编译运行，因此我们不需要Golang的编译环境等。如果你查看golang:1.5的Dockerfile,会发现它基于buildpack-deps:jessie-scm，会安装GCC及一堆的build工具，下载Go的发布文件并安装。基本上这些对于我们来说并不需要。我们需要的是：</p>
<blockquote>
<p>一个可以运行我们编译好的Golang应用的镜像。</p>
</blockquote>
<p>我们可以从<code>scratch</code>镜像创建。<br><code>scratch</code>镜像是一个空的镜像文件，特别适合创建超级小的镜像。<br><code>Dockerfile</code>文件如下：</p>
<figure class="highlight dockfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> scratch</div><div class="line">ADD main /</div><div class="line">CMD [<span class="string">"/main"</span>]</div></pre></td></tr></table></figure>

<p>运行<br>输出如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># docker build -t example-scratch .</div><div class="line">Sending build context to Docker daemon 8.054 MB</div><div class="line">Step 0 : FROM scratch</div><div class="line"> -<span class="ruby"><span class="input"><span class="prompt">--&gt;</span> </span></span></div><div class="line">Step 1 : ADD main /</div><div class="line"> -<span class="ruby"><span class="input"><span class="prompt">--&gt;</span> <span class="number">4</span>ad02fa47a7d</span></span></div><div class="line"></div><div class="line">Removing intermediate container d64080c4b42f</div><div class="line">Step 2 : CMD /main</div><div class="line"> -<span class="ruby"><span class="input"><span class="prompt">--&gt;</span> <span class="constant">Running</span> in <span class="number">5</span>d9a08c3a20e</span></span></div><div class="line"> -<span class="ruby"><span class="input"><span class="prompt">--&gt;</span> <span class="number">5</span>c29c8249678</span></span></div><div class="line">Removing intermediate container 5d9a08c3a20e</div><div class="line">Successfully built 5c29c8249678</div></pre></td></tr></table></figure>

<p>这样镜像就创建成功了，查看一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@localhost</span> work]<span class="comment"># docker images</span></div><div class="line"><span class="constant">REPOSITORY</span>          <span class="constant">TAG</span>                 <span class="constant">IMAGE</span> <span class="constant">ID</span>            <span class="constant">CREATED</span>             <span class="constant">VIRTUAL</span> <span class="constant">SIZE</span></div><div class="line">example-scratch     latest              <span class="number">5</span>c29c8249678        <span class="number">3</span> minutes ago       <span class="number">8.052</span> <span class="constant">MB</span></div></pre></td></tr></table></figure>

<p>只有8M左右，非常的小。</p>
<p>但是运行这个镜像，容器无法创建：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker run -it -p 4242:4242 example-scratch</span></div><div class="line">no such <span class="built_in">file</span> <span class="operator">or</span> <span class="built_in">directory</span></div><div class="line">Error response <span class="built_in">from</span> daemon: Cannot start container <span class="number">79</span>bb9fb62788b4a8c1487695a3219ddf3aa85bde2bc44473838f6f4d1583a204: [<span class="number">8</span>] System error: no such <span class="built_in">file</span> <span class="operator">or</span> <span class="built_in">directory</span></div></pre></td></tr></table></figure>

<p>原因是我们的main文件生成的时候依赖的一些库如libc还是动态链接的，但是scratch 镜像完全是空的，什么东西也不包含，所以生成main时候要按照下面的方式生成，使生成的main静态链接所有的库：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">CGO_ENABLED=</span><span class="number">0</span> <span class="variable">GOOS=</span>linux go build -a -installsuffix cgo -o main .</div></pre></td></tr></table></figure>

<p>然后重新生成镜像并运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># docker build -t example-scratch .</span></div><div class="line"><span class="preprocessor"># docker run -it -p 4242:4242 example-scratch</span></div></pre></td></tr></table></figure>

<p>容器运行成功，在浏览器中访问<a href="http://宿主IP:4242/index成功返回结果" target="_blank" rel="external">http://宿主IP:4242/index成功返回结果</a></p>
<h3 id="发布">发布</h3>
<p>可以方便的将刚才的镜像发布到docker.io上。<br>首先将刚才的镜像打tag:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># docker images</span></div><div class="line">REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE</div><div class="line">example-scratch     latest              <span class="number">2</span>ea4bbfd67dc        <span class="number">10</span> minutes ago      <span class="number">8.01</span> MB</div><div class="line"><span class="preprocessor"># docker tag 2ea4bbfd67dc smallnest/example-scratch</span></div><div class="line"><span class="preprocessor"># docker images</span></div><div class="line">REPOSITORY                 <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE</div><div class="line">smallnest/example-scratch   latest              <span class="number">2</span>ea4bbfd67dc        <span class="number">10</span> minutes ago      <span class="number">8.01</span> MB</div><div class="line">example-scratch             latest              <span class="number">2</span>ea4bbfd67dc        <span class="number">10</span> minutes ago      <span class="number">8.01</span> MB</div></pre></td></tr></table></figure>

<p>运行<code>docker login</code>登录，然后运行下面的命令push到docker.io上。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push smallnest/example-scratch</div></pre></td></tr></table></figure>

<p>访问 <a href="https://hub.docker.com/r/smallnest/example-scratch/" target="_blank" rel="external">https://hub.docker.com/r/smallnest/example-scratch/</a> 可以看到刚刚push的这个镜像，这样我们就可以pull到其它机器上运行了。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="https://blog.golang.org/docker" target="_blank" rel="external">https://blog.golang.org/docker</a></li>
<li><a href="https://hub.docker.com/_/golang/" target="_blank" rel="external">https://hub.docker.com/_/golang/</a></li>
<li><a href="https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/" target="_blank" rel="external">https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/</a></li>
<li><a href="https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07" target="_blank" rel="external">https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07</a></li>
<li><a href="http://www.iron.io/blog/2015/07/an-easier-way-to-create-tiny-golang-docker-images.html" target="_blank" rel="external">http://www.iron.io/blog/2015/07/an-easier-way-to-create-tiny-golang-docker-images.html</a></li>
<li><a href="https://labs.ctl.io/small-docker-images-for-go-apps/" target="_blank" rel="external">https://labs.ctl.io/small-docker-images-for-go-apps/</a></li>
<li><a href="http://dockerpool.com/static/books/docker_practice/introduction/why.html" target="_blank" rel="external">http://dockerpool.com/static/books/docker_practice/introduction/why.html</a></li>
<li><a href="https://docs.docker.com/installation/centos/" target="_blank" rel="external">https://docs.docker.com/installation/centos/</a></li>
<li><a href="http://segmentfault.com/a/1190000002766882" target="_blank" rel="external">http://segmentfault.com/a/1190000002766882</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.docker.io/" target="_blank" rel="external">Docker</a>是PaaS供应商dotCloud开源的一个基于LXC 的高级容器引擎，源代码托管在 GitHub 上, 基于Go语言开发并遵从Apache 2.0协议开源。正如DockerPool在免费Docker电子书<a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="external">Docker —— 从入门到实践</a>中这样提到的：</p>
<blockquote>
<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>
<p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
</blockquote>
<p>Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架包括系统。</p>
]]>
    
    </summary>
    
      <category term="Docker" scheme="http://colobu.com/tags/Docker/"/>
    
      <category term="Go" scheme="http://colobu.com/tags/Go/"/>
    
      <category term="Docker" scheme="http://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux Signal及Golang中的信号处理]]></title>
    <link href="http://colobu.com/2015/10/09/Linux-Signals/"/>
    <id>http://colobu.com/2015/10/09/Linux-Signals/</id>
    <published>2015-10-09T07:21:28.000Z</published>
    <updated>2015-10-09T09:03:54.100Z</updated>
    <content type="html"><![CDATA[<p>信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。<br>当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。<br>如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。</p>
<a id="more"></a>
<h3 id="发送信号">发送信号</h3>
<p><em>kill</em> <strong>系统调用(system call)</strong>可以用来发送一个特定的信号给进程。<br><em>kill</em> <strong>命令</strong>允许用户发送一个特定的信号给进程。<br><em>raise</em> <strong>库函数</strong>可以发送特定的信号给当前进程。</p>
<p>在Linux下运行<code>man kill</code>可以查看此命令的介绍和用法。</p>
<blockquote>
<p>The command <strong>kill</strong> sends the specified signal to the specified process or process group.  If no signal is specified, the TERM signal is sent.  The TERM signal will kill processes which do not catch  this  signal.   For  other  processes, it may be necessary to use the KILL (9) signal, since this signal cannot be caught.</p>
<p>Most  modern  shells  have  a  builtin kill function, with a usage rather similar to that of the command described here. The &#39;-a&#39; and &#39;-p&#39; options, and the possibility to specify pids by command name is a local extension.</p>
<p>If sig is 0, then no signal is sent, but error checking is still performed.</p>
</blockquote>
<p>一些异常比如除以0或者 segmentation violation 相应的会产生<code>SIGFPE</code>和<code>SIGSEGV</code>信号，缺省情况下导致core dump和程序退出。<br>内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生<code>SIGPIPE</code>信号。<br>在进程的终端敲入特定的组合键也会导致系统发送某个特定的信号给此进程：</p>
<ul>
<li>Ctrl-C 发送 INT signal (SIGINT)，通常导致进程结束</li>
<li>Ctrl-Z 发送 TSTP signal (SIGTSTP); 通常导致进程挂起(suspend)</li>
<li>Ctrl-\ 发送 QUIT signal (SIGQUIT); 通常导致进程结束 和 dump core.</li>
<li>Ctrl-T (不是所有的UNIX都支持) 发送INFO signal (SIGINFO); 导致操作系统显示此运行命令的信息</li>
</ul>
<p><code>kill -9 pid</code> 会发送 <code>SIGKILL</code>信号给进程。</p>
<h3 id="处理信号">处理信号</h3>
<p>Signal handler可以通过<code>signal()</code>系统调用进行设置。如果没有设置，缺省的handler会被调用，当然进程也可以设置忽略此信号。<br>有两种信号不能被拦截和处理: <code>SIGKILL</code>和<code>SIGSTOP</code>。</p>
<p>当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<p>用户可以通过<code>signal</code>或<code>sigaction</code>函数修改信号的响应动作（也就是常说的“注册信号”）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p>
<h3 id="信号类型">信号类型</h3>
<p>个平台的信号定义或许有些不同。下面列出了POSIX中定义的信号。<br>Linux 使用34-64信号用作实时系统中。<br>命令<code>man 7 signal</code>提供了官方的信号介绍。</p>
<p>在POSIX.1-1990标准中定义的信号列表</p>
<table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>Term</td><td>终端控制进程结束(终端连接断开)</td></tr><tr><td>SIGINT</td><td>2</td><td>Term</td><td>用户发送INTR字符(Ctrl+C)触发</td></tr><tr><td>SIGQUIT</td><td>3</td><td>Core</td><td>用户发送QUIT字符(Ctrl+/)触发</td></tr><tr><td>SIGILL</td><td>4</td><td>Core</td><td>非法指令(程序错误、试图执行数据段、栈溢出等)</td></tr><tr><td>SIGABRT</td><td>6</td><td>Core</td><td>调用abort函数触发</td></tr><tr><td>SIGFPE</td><td>8</td><td>Core</td><td>算术运行错误(浮点运算错误、除数为零等)</td></tr><tr><td>SIGKILL</td><td>9</td><td>Term</td><td>无条件结束程序(不能被捕获、阻塞或忽略)</td></tr><tr><td>SIGSEGV</td><td>11</td><td>Core</td><td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td></tr><tr><td>SIGPIPE</td><td>13</td><td>Term</td><td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td></tr><tr><td>SIGALRM</td><td>14</td><td>Term</td><td>时钟定时信号</td></tr><tr><td>SIGTERM</td><td>15</td><td>Term</td><td>结束程序(可以被捕获、阻塞或忽略)</td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>Term</td><td>用户保留</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>Term</td><td>用户保留</td></tr><tr><td>SIGCHLD</td><td>20,17,18</td><td>Ign</td><td>子进程结束(由父进程接收)</td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td>Cont</td><td>继续执行已经停止的进程(不能被阻塞)</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>Stop</td><td>停止进程(不能被捕获、阻塞或忽略)</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>Stop</td><td>停止进程(可以被捕获、阻塞或忽略)</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>Stop</td><td>后台程序从终端中读取数据时触发</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>Stop</td><td>后台程序向终端中写数据时触发</td></tr></tbody></table> 

<p>在SUSv2和POSIX.1-2001标准中的信号列表:</p>
<table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGTRAP</td><td>5</td><td>Core</td><td>Trap指令触发(如断点，在调试器中使用)</td></tr><tr><td>SIGBUS</td><td>0,7,10</td><td>Core</td><td>非法地址(内存地址对齐错误)</td></tr><tr><td>SIGPOLL</td><td></td><td>Term</td><td>Pollable event (Sys V). Synonym for SIGIO</td></tr><tr><td>SIGPROF</td><td>27,27,29</td><td>Term</td><td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td></tr><tr><td>SIGSYS</td><td>12,31,12</td><td>Core</td><td>无效的系统调用(SVr4)</td></tr><tr><td>SIGURG</td><td>16,23,21</td><td>Ign</td><td>有紧急数据到达Socket(4.2BSD)</td></tr><tr><td>SIGVTALRM</td><td>26,26,28</td><td>Term</td><td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td></tr><tr><td>SIGXCPU</td><td>24,24,30</td><td>Core</td><td>超过CPU时间资源限制(4.2BSD)</td></tr><tr><td>SIGXFSZ</td><td>25,25,31</td><td>Core</td><td>超过文件大小资源限制(4.2BSD)</td></tr></tbody></table>

<h3 id="Go中的Signal发送和处理">Go中的Signal发送和处理</h3>
<p>有时候我们想在Go程序中处理Signal信号，比如收到<code>SIGTERM</code>信号后优雅的关闭程序(参看下一节的应用)。<br>Go信号通知机制可以通过往一个channel中发送<code>os.Signal</code>实现。<br>首先我们创建一个os.Signal channel，然后使用<code>signal.Notify</code>注册要接收的信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"os"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"os/signal"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"syscall"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">    <span class="comment">// Go signal notification works by sending `os.Signal`</span></div><div class="line">    <span class="comment">// values on a channel. We'll create a channel to</span></div><div class="line">    <span class="comment">// receive these notifications (we'll also make one to</span></div><div class="line">    <span class="comment">// notify us when the program can exit).</span></div><div class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>,<span class="number"> 1</span>)</div><div class="line"></div><div class="line">    <span class="comment">// `signal.Notify` registers the given channel to</span></div><div class="line">    <span class="comment">// receive notifications of the specified signals.</span></div><div class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line"></div><div class="line">    <span class="comment">// This goroutine executes a blocking receive for</span></div><div class="line">    <span class="comment">// signals. When it gets one it'll print it out</span></div><div class="line">    <span class="comment">// and then notify the program that it can finish.</span></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        sig := &lt;-sigs</div><div class="line">        fmt.Println()</div><div class="line">        fmt.Println(sig)</div><div class="line">        done &lt;- <span class="constant">true</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="comment">// The program will wait here until it gets the</span></div><div class="line">    <span class="comment">// expected signal (as indicated by the goroutine</span></div><div class="line">    <span class="comment">// above sending a value on `done`) and then exit.</span></div><div class="line">    fmt.Println(<span class="string">"awaiting signal"</span>)</div><div class="line">    &lt;-done</div><div class="line">    fmt.Println(<span class="string">"exiting"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>go run main.go</code>执行这个程序，敲入ctrl-C会发送<code>SIGINT</code>信号。 此程序接收到这个信号后会打印退出。</p>
<h3 id="Go网络服务器如果无缝重启">Go网络服务器如果无缝重启</h3>
<p>Go很适合编写服务器端的网络程序。DevOps经常会遇到的一个情况是升级系统或者重新加载配置文件，在这种情况下我们需要重启此网络程序，如果网络程序暂停的时间较长，则给客户的感觉很不好。<br>如何实现优雅地重启一个Go网络程序呢。主要要解决两个问题：</p>
<ol>
<li>进程重启不需要关闭监听的端口</li>
<li>既有请求应当完全处理或者超时</li>
</ol>
<p><a href="http://twitter.com/humblehack" target="_blank" rel="external">@humblehack</a> 在他的文章<a href="http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="external">Graceful Restart in Golang</a>中提供了一种方式，而<a href="https://github.com/fvbock" target="_blank" rel="external">Florian von Bock</a>根据此思路实现了一个框架<a href="https://github.com/fvbock/endless" target="_blank" rel="external">endless</a>。<br>此框架使用起来超级简单:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">err := endless.ListenAndServe(<span class="string">"localhost:4242"</span>, mux)</div></pre></td></tr></table></figure>

<p>只需替换 <code>http.ListenAndServe</code> 和 <code>http.ListenAndServeTLS</code>。</p>
<p>它会监听这些信号： <code>syscall.SIGHUP</code>, <code>syscall.SIGUSR1</code>, <code>syscall.SIGUSR2</code>, <code>syscall.SIGINT</code>, <code>syscall.SIGTERM</code>, 和 <code>syscall.SIGTSTP</code>。</p>
<p>此文章提到的思路是：</p>
<ol>
<li>通过<code>exec.Command</code> fork一个新的进程，同时继承当前进程的打开的文件(输入输出，socket等)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">file := netListener.File() <span class="comment">// this returns a Dup()</span></div><div class="line">path := <span class="string">"/path/to/executable"</span></div><div class="line">args := []<span class="typename">string</span>{</div><div class="line">    <span class="string">"-graceful"</span>}</div><div class="line"></div><div class="line">cmd := exec.Command(path, args...)</div><div class="line">cmd.Stdout = os.Stdout</div><div class="line">cmd.Stderr = os.Stderr</div><div class="line">cmd.ExtraFiles = []*os.File{file}</div><div class="line"></div><div class="line">err := cmd.Start()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatalf(<span class="string">"gracefulRestart: Failed to launch, error: %v"</span>, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>子进程初始化<br>网络程序的启动代码</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">server := &http.Server{Addr: <span class="string">"0.0.0.0:8888"</span>}</div><div class="line"></div><div class="line"> <span class="keyword">var</span> gracefulChild <span class="typename">bool</span></div><div class="line"> <span class="keyword">var</span> l net.Listever</div><div class="line"> <span class="keyword">var</span> err error</div><div class="line"></div><div class="line"> flag.BoolVar(&gracefulChild, <span class="string">"graceful"</span>, <span class="constant">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</div><div class="line"></div><div class="line"> <span class="keyword">if</span> gracefulChild {</div><div class="line">     log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</div><div class="line">     f := os.NewFile<span class="number">(3</span>, <span class="string">""</span>)</div><div class="line">     l, err = net.FileListener(f)</div><div class="line"> } <span class="keyword">else</span> {</div><div class="line">     log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</div><div class="line">     l, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</div><div class="line"> }</div></pre></td></tr></table></figure>

<ol>
<li>父进程停止</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> gracefulChild {</div><div class="line">    parent := syscall.Getppid()</div><div class="line">    log.Printf(<span class="string">"main: Killing parent pid: %v"</span>, parent)</div><div class="line">    syscall.Kill(parent, syscall.SIGTERM)</div><div class="line">}</div><div class="line"></div><div class="line">server.Serve(l)</div></pre></td></tr></table></figure>

<p>同时他还提供的如何处理已经正在处理的请求。可以查看它的文章了解详细情况。</p>
<p>因此，处理特定的信号可以实现程序无缝的重启。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Unix_signal" target="_blank" rel="external">https://en.wikipedia.org/wiki/Unix_signal</a></li>
<li><a href="http://hutaow.com/blog/2013/10/19/linux-signal/" target="_blank" rel="external">http://hutaow.com/blog/2013/10/19/linux-signal/</a></li>
<li><a href="http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf" target="_blank" rel="external">http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf</a></li>
<li><a href="https://golang.org/pkg/os/signal/" target="_blank" rel="external">https://golang.org/pkg/os/signal/</a></li>
<li><a href="https://gobyexample.com/signals" target="_blank" rel="external">https://gobyexample.com/signals</a></li>
<li><a href="http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="external">http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/</a></li>
<li><a href="https://fitstar.github.io/falcore/hot_restart.html" target="_blank" rel="external">https://fitstar.github.io/falcore/hot_restart.html</a></li>
<li><a href="https://github.com/rcrowley/goagain" target="_blank" rel="external">https://github.com/rcrowley/goagain</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。<br>当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。<br>如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。</p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[交叉编译Go程序]]></title>
    <link href="http://colobu.com/2015/09/28/go-cross-compiling/"/>
    <id>http://colobu.com/2015/09/28/go-cross-compiling/</id>
    <published>2015-09-28T06:10:33.000Z</published>
    <updated>2015-10-10T02:31:17.119Z</updated>
    <content type="html"><![CDATA[<p>Go 1.5以前，交叉编译程序还是有一点麻烦的，你需要<a href="http://dave.cheney.net/2013/07/09/an-introduction-to-cross-compilation-with-go-1-1" target="_blank" rel="external">massive scripts t</a>来编译和宿主机器不同的程序。</p>
<p>正如<a href="http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5" target="_blank" rel="external"> comes with support for all architectures built in</a>文章中介绍的， Go 1.5可就简单的多了，你只需设置 <strong>GOOS</strong> 和 <strong>GOARCH </strong> 两个环境变量就能生成所需平台的Go程序。</p>
<p>比如使用下面的代码测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Printf(<span class="string">"OS: %s\nArchitecture: %s\n"</span>, runtime.GOOS, runtime.GOARCH)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译它： <code>$ GOOS=darwin GOARCH=386 go build test.go</code><br>就可以生成运行在<code>OS X</code>上的程序。<br><a id="more"></a></p>
<p>可用的OS和ARCH的值如下：</p>
<table cellpadding="0"><tbody><tr><th width="50"></th><th align="left" width="100"><code>$GOOS</code></th><th align="left" width="100"><code>$GOARCH</code></th></tr><tr><td></td><td><code>darwin</code></td><td><code>386</code></td></tr><tr><td></td><td><code>darwin</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>darwin</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>darwin</code></td><td><code>arm64</code></td></tr><tr><td></td><td><code>dragonfly</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>freebsd</code></td><td><code>386</code></td></tr><tr><td></td><td><code>freebsd</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>freebsd</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>386</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>arm64</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>ppc64</code></td></tr><tr><td></td><td><code>linux</code></td><td><code>ppc64le</code></td></tr><tr><td></td><td><code>netbsd</code></td><td><code>386</code></td></tr><tr><td></td><td><code>netbsd</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>netbsd</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>openbsd</code></td><td><code>386</code></td></tr><tr><td></td><td><code>openbsd</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>openbsd</code></td><td><code>arm</code></td></tr><tr><td></td><td><code>plan9</code></td><td><code>386</code></td></tr><tr><td></td><td><code>plan9</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>solaris</code></td><td><code>amd64</code></td></tr><tr><td></td><td><code>windows</code></td><td><code>386</code></td></tr><tr><td></td><td><code>windows</code></td><td><code>amd64</code></td></tr></tbody></table>

<p>不同的操作系统下的库可能有不同的实现， 比如<a href="https://golang.org/src/syscall/" target="_blank" rel="external">syscall</a>库。go build没有内置的<code>#define</code>或者预处理器之类的处理平台相关的代码取舍， 而是采用tag和文件后缀的方式实现。<br><strong>tag方式</strong><br>tag遵循一下规则</p>
<ol>
<li>a build tag is evaluated as the OR of space-separated options</li>
<li>each option evaluates as the AND of its comma-separated terms</li>
<li>each term is an alphanumeric word or, preceded by !, its negation</li>
</ol>
<p>在文件的头部增加tag:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build darwin freebsd netbsd openbsd</span></div></pre></td></tr></table></figure>

<p>可以有多个tag,之间是<strong>AND</strong>的关系</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build linux darwin</span></div><div class="line"><span class="comment">// +build 386</span></div></pre></td></tr></table></figure>

<p>注意tag和package中间需要有空行分隔，下面的例子是不对的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build !linux</span></div><div class="line"><span class="keyword">package</span> mypkg <span class="comment">// wrong</span></div></pre></td></tr></table></figure>

<p><strong>文件后缀方式</strong><br>以<em>_$GOOS.go</em>为后缀的文件只在此平台上编译，其它平台上编译时就当此文件不存在。完整的后缀如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_<span class="variable">$GOOS_</span><span class="variable">$GOARCH</span>.go</div></pre></td></tr></table></figure>

<p>如syscall_linux_amd64.go,syscall_windows_386.go,syscall_windows.go等。</p>
<h4 id="参考文档">参考文档</h4>
<ol>
<li><a href="http://golangcookbook.com/chapters/running/cross-compiling/" target="_blank" rel="external">http://golangcookbook.com/chapters/running/cross-compiling/</a></li>
<li><a href="http://dave.cheney.net/2013/07/09/an-introduction-to-cross-compilation-with-go-1-1" target="_blank" rel="external">http://dave.cheney.net/2013/07/09/an-introduction-to-cross-compilation-with-go-1-1</a></li>
<li><a href="http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5" target="_blank" rel="external">http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5</a></li>
<li><a href="https://golang.org/doc/install/source#environment" target="_blank" rel="external">https://golang.org/doc/install/source#environment</a></li>
<li><a href="http://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool" target="_blank" rel="external">http://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.5以前，交叉编译程序还是有一点麻烦的，你需要<a href="http://dave.cheney.net/2013/07/09/an-introduction-to-cross-compilation-with-go-1-1" target="_blank" rel="external">massive scripts t</a>来编译和宿主机器不同的程序。</p>
<p>正如<a href="http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5" target="_blank" rel="external"> comes with support for all architectures built in</a>文章中介绍的， Go 1.5可就简单的多了，你只需设置 <strong>GOOS</strong> 和 <strong>GOARCH </strong> 两个环境变量就能生成所需平台的Go程序。</p>
<p>比如使用下面的代码测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Printf(<span class="string">"OS: %s\nArchitecture: %s\n"</span>, runtime.GOOS, runtime.GOARCH)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译它： <code>$ GOOS=darwin GOARCH=386 go build test.go</code><br>就可以生成运行在<code>OS X</code>上的程序。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[几种Go序列化库的性能比较]]></title>
    <link href="http://colobu.com/2015/09/28/Golang-Serializer-Benchmark-Comparison/"/>
    <id>http://colobu.com/2015/09/28/Golang-Serializer-Benchmark-Comparison/</id>
    <published>2015-09-28T05:39:23.000Z</published>
    <updated>2015-09-28T06:03:08.306Z</updated>
    <content type="html"><![CDATA[<p>序列化库在网络传输，RPC，数据库访问等环境中经常用到，它的性能的好坏直接影响着整个产品的性能。<br>本文列出了几种高性能的Go语言的序列化库，并通过一个简单的无循环引用的数据结构测试它们的性能。<br>测试代码: <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp at github</a><br><a id="more"></a></p>
<h3 id="测试的_Serializers">测试的 Serializers</h3>
<p>以golang自带的<em>encoding/json</em>和<em>encoding/xml</em>为基准，测试以下性能比较好的几种序列化库。</p>
<ul>
<li><a href="http://golang.org/pkg/encoding/json/" target="_blank" rel="external">encoding/json</a></li>
<li><a href="http://golang.org/pkg/encoding/xml/" target="_blank" rel="external">encoding/xml</a></li>
<li><a href="http://github.com/youtube/vitess/go/bson" target="_blank" rel="external">github.com/youtube/vitess/go/bson</a></li>
<li><a href="http://github.com/philhofer/msgp" target="_blank" rel="external">github.com/philhofer/msgp</a></li>
<li><a href="http://github.com/golang/protobuf" target="_blank" rel="external">github.com/golang/protobuf</a></li>
<li><a href="http://github.com/gogo/protobuf" target="_blank" rel="external">github.com/gogo/protobuf</a></li>
<li><a href="http://github.com/google/flatbuffers" target="_blank" rel="external">github.com/google/flatbuffers</a></li>
</ul>
<h3 id="排除的_Serializers">排除的 Serializers</h3>
<p>基于 alecthomas 已有的<a href="https://github.com/alecthomas/go_serialization_benchmarks" target="_blank" rel="external">测试</a>，下面的库由于性能的原因没有进行测试。</p>
<ul>
<li><a href="http://golang.org/pkg/encoding/gob/" target="_blank" rel="external">encoding/gob</a></li>
<li><a href="http://github.com/alecthomas/binary" target="_blank" rel="external">github.com/alecthomas/binary</a></li>
<li><a href="http://github.com/davecgh/go-xdr/xdr" target="_blank" rel="external">github.com/davecgh/go-xdr/xdr</a></li>
<li><a href="http://github.com/ugorji/go/codec" target="_blank" rel="external">github.com/ugorji/go/codec</a></li>
<li><a href="http://labix.org/v2/mgo/bson" target="_blank" rel="external">labix.org/v2/mgo/bson</a></li>
<li><a href="http://github.com/DeDiS/protobuf" target="_blank" rel="external">github.com/DeDiS/protobuf</a></li>
<li><a href="http://gopkg.in/vmihailenco/msgpack.v2" target="_blank" rel="external">gopkg.in/vmihailenco/msgpack.v2</a></li>
</ul>
<h3 id="测试环境">测试环境</h3>
<p>对于<code>github.com/youtube/vitess/go/bson</code>，你可能需要安装 <code>goimports</code>和<code>codegen</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get github.com/youtube/vitess/<span class="keyword">go</span>/bson</div><div class="line"><span class="keyword">go</span> get golang.org/x/tools/cmd/goimports</div><div class="line"><span class="keyword">go</span> get github.com/youtube/vitess/tree/master/<span class="keyword">go</span>/cmd/bsongen</div><div class="line">bsongen -file data.<span class="keyword">go</span> -o bson_data.<span class="keyword">go</span> -<span class="keyword">type</span> ColorGroup</div></pre></td></tr></table></figure>

<p>对于 <code>MessagePack</code>，你需要安装库以及利用<code>go generate</code>生成相关的类:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get github.com/tinylib/msgp</div><div class="line"><span class="keyword">go</span> generate</div></pre></td></tr></table></figure>

<p>对于<code>ProtoBuf</code>,你需要安装<a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">protoc编译器</a>，以及protoc库以及生成相关的类：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get github.com/golang/protobuf</div><div class="line"><span class="keyword">go</span> generate</div></pre></td></tr></table></figure>

<p>对于<code>gogo/protobuf</code>,你需要安装库以及生成相关的类：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get github.com/gogo/protobuf/gogoproto</div><div class="line"><span class="keyword">go</span> get github.com/gogo/protobuf/protoc-gen-gofast</div><div class="line"><span class="keyword">go</span> generate</div></pre></td></tr></table></figure>

<p>对于<code>flatbuffers</code>,你需要安装<a href="https://github.com/google/flatbuffers/releases" target="_blank" rel="external">flatbuffers编译器</a>, 以及flatbuffers库：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">github.com/google/flatbuffers/<span class="keyword">go</span></div><div class="line"><span class="keyword">go</span> generate</div></pre></td></tr></table></figure>

<p>事实上，这里通过<code>go generate</code>生成相关的类，你也可以通过命令行生成，请参考<code>data.go</code>中的注释。</p>
<p>运行下面的命令测试:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">go test -bench</span>=<span class="string">.</span></div></pre></td></tr></table></figure>

<h3 id="测试数据">测试数据</h3>
<p>所有的测试基于以下的struct,自动生成的struct， 比如protobuf也和此结构基本一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> {</div><div class="line">	ID     <span class="typename">int</span> <span class="string">`json:"id" xml:"id,attr""`</span></div><div class="line">	Name   <span class="typename">string</span> <span class="string">`json:"name" xml:"name"`</span></div><div class="line">	Colors []<span class="typename">string</span> <span class="string">`json:"colors" xml:"colors"`</span></div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="性能测试结果">性能测试结果</h3>
<figure class="highlight csv"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="header">benchmark _name                               iter                 time/iter </span></div><div class="line">------------------------------------------------------------------------------</div><div class="line">BenchmarkMarshalByJson-4                      1000000              1877 ns/op</div><div class="line">BenchmarkUnmarshalByJson-4                    300000               4099 ns/op</div><div class="line"></div><div class="line">BenchmarkMarshalByXml-4                       200000               8315 ns/op</div><div class="line">BenchmarkUnmarshalByXml-4                     100000               26627 ns/op</div><div class="line"></div><div class="line">BenchmarkMarshalByBson-4                      500000               3518 ns/op</div><div class="line">BenchmarkUnmarshalByBson-4                    1000000              1778 ns/op</div><div class="line"></div><div class="line">BenchmarkMarshalByMsgp-4                      5000000              292 ns/op</div><div class="line">BenchmarkUnmarshalByMsgp-4                    3000000              543 ns/op</div><div class="line"></div><div class="line">BenchmarkMarshalByProtoBuf-4                  1000000              1011 ns/op</div><div class="line">BenchmarkUnmarshalByProtoBuf-4                1000000              1750 ns/op</div><div class="line"></div><div class="line">BenchmarkMarshalByGogoProtoBuf-4              5000000              220 ns/op</div><div class="line">BenchmarkUnmarshalByGogoProtoBuf-4            2000000              901 ns/op</div><div class="line"></div><div class="line">BenchmarkMarshalByFlatBuffers-4               3000000              566 ns/op</div><div class="line">BenchmarkUnmarshalByFlatBuffers-4             50000000             9.54 ns/op</div><div class="line">BenchmarUmByFlatBuffers<span class="emphasis">_withFields-4          3000000              554 ns/op</span></div></pre></td></tr></table></figure>

<p>多次测试结果差不多。<br>从结果上上来看， <strong>MessagePack</strong> , <strong>gogo/protobuf</strong> ,和 <strong>flatbuffers</strong> 差不多，这三个优秀的库在序列化和反序列化上各有千秋，而且都是跨语言的。<br>从便利性上来讲，你可以选择 <strong>MessagePack</strong> 和 <strong>gogo/protobuf</strong> 都可以，两者都有大厂在用。<br><strong>flatbuffers</strong> 有点反人类，因为它的操作很底层，而且从结果上来看，序列化的性能要差一点。但是它有一个好处，那就是如果你只需要特定的字段，<br>你无须将所有的字段都反序列化。从结果上看，不反序列化字段每个调用只用了9.54纳秒，这是因为字段只有在被访问的时候才从byte数组转化为相应的类型。<br>因此在特殊的场景下，它可以提高N被的性能。但是序列化的代码的面相太难看了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>序列化库在网络传输，RPC，数据库访问等环境中经常用到，它的性能的好坏直接影响着整个产品的性能。<br>本文列出了几种高性能的Go语言的序列化库，并通过一个简单的无循环引用的数据结构测试它们的性能。<br>测试代码: <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp at github</a><br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 反射的规则]]></title>
    <link href="http://colobu.com/2015/09/23/laws-of-goang-reflection/"/>
    <id>http://colobu.com/2015/09/23/laws-of-goang-reflection/</id>
    <published>2015-09-23T06:56:44.000Z</published>
    <updated>2015-09-23T08:04:05.931Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://blog.golang.org/laws-of-reflection" target="_blank" rel="external">The Laws of Reflection</a><br>翻译: <a href="http://mikespook.com/2011/09/%E5%8F%8D%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99/" target="_blank" rel="external">反射的规则</a> by <a href="http://mikespook.com/author/mikespook/" target="_blank" rel="external">mikespook</a> 转载时略作修改</p>
<h3 id="反射的规则">反射的规则</h3>
<p>在运行时反射是程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。它同时也是造成混淆的重要来源。</p>
<p>在这篇文章中将试图明确解释在 Go 中的反射是如何工作的。每个语言的反射模型都不同（同时许多语言根本不支持反射）。不过这篇文章是关于 Go 的，因此接下来的内容“反射”这一词表示“在 Go 中的反射”。<br><a id="more"></a></p>
<h3 id="类型_Types_和接口_Interfaces">类型 Types 和接口 Interfaces</h3>
<p>由于反射构建于类型系统之上，就从复习一下 Go 中的类型开始吧。<br>Go 是静态类型的。每一个变量有一个静态的类型，也就是说，有一个已知类型并且在编译时就确定下来了：<em>int</em>，<em>float32</em>，<em>MyType</em>，<em>[]byte</em> 等等。如果定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> j MyInt</div></pre></td></tr></table></figure>

<p>那么<em> i</em> 的类型为 <em>int</em> 而<em>j</em> 的类型为 <em>MyInt</em>。即使变量<em> i</em> 和 <em>j</em> 有相同的底层类型，它们仍然是有不同的静态类型的。未经转换是不能相互直接赋值的。</p>
<p>在类型中有一个重要的类别就是接口类型，表达了固定的一个方法集合。一个接口变量可以存储任意实际值（非接口），只要这个值直线了接口的方法。众所周知的一个例子就是<em> is io.Reade</em>r 和 <em>io.Writer</em>，来自 <a href="http://golang.org/pkg/io/" target="_blank" rel="external">io 包</a>的类型 <em>Reader</em> 和 <em>Writer</em>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></div><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {</div><div class="line">    Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></div><div class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> {</div><div class="line">    Write(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>任何用这个声明实现了 <em>Read</em>（或 <em>Write</em>）方法的类型，可以说它实现了 <em>io.Reader</em>（或 <em>io.Writer</em>）。基于本讨论来说，这意味着 <em>io.Reader</em> 类型的变量可以保存任意值，只要这个值的类型实现了 Read 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r io.Reader</div><div class="line">r = os.Stdin</div><div class="line">r = bufio.NewReader(r)</div><div class="line">r = <span class="built_in">new</span>(bytes.Buffer)</div><div class="line"><span class="comment">// and so on</span></div></pre></td></tr></table></figure>

<p>有一个事情是一定要明确的，不论 <em>r</em> 保存了什么值，<em>r</em> 的类型总是<em> io.Reader</em>：Go 是静态类型，而 <em>r</em> 的静态类型是 <em>io.Reader</em>。</p>
<p>接口类型的一个极端重要的例子是空接口： <code>interface{}</code>, 它表示空的方法集合，由于任何值都有另个或者多个方法，所以任何值都可以满足它。</p>
<p>也有人说 Go 的接口是动态类型的，不过这是一种误解。它们是静态类型的：接口类型的变量总是具有相同的静态类型，即使在运行时存储在接口变量中的值可能会改变类型，该值将始终满足该接口。</p>
<p>对于所有这些都必须严谨的对待，因为反射和接口密切相关。</p>
<h3 id="接口的表现representation">接口的表现representation</h3>
<p>Russ Cox 已经写了一篇详细介绍 Go 中接口值表现的<a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html" target="_blank" rel="external">文章</a>。所以无需在这里重复整个故事了，不过简单的总结还是必要的。</p>
<p>接口类型的变量存储了两个内容：赋值给变量实际的值和这个值的类型描述。更准确的说，值是底层实现了接口的实际数据项目，而类型描述了这个项目完整的类型。例如下面，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r io.Reader</div><div class="line">tty, err := os.OpenFile(<span class="string">"/dev/tty"</span>, os.O_RDWR,<span class="number"> 0</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">}</div><div class="line">r = tty</div></pre></td></tr></table></figure>

<p><em>r</em> 包含的是 <em>(value, type)</em> 对，如 <em>(tty, </em>os.File)<em>。注意类型 </em>os.File<em> 除了 </em>Read<em> 方法还实现了其他方法：尽管接口值仅仅提供了访问 </em>Read* 方法的可能，但是内部包含了这个值的完整的类型信息。这也就是为什么可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> w io.Writer</div><div class="line">w = r.(io.Writer)</div></pre></td></tr></table></figure>

<p>在这个赋值中的表达式是一个类型断言：它断言 <em>r</em> 内部项的同时也实现了 <em>io.Writer</em>，因此可以赋值它到 <em>w</em>。在赋值之后，<em>w</em> 将会包含 <em>(tty, </em>os.File)<em>。跟在 </em>r* 中保存的一致。接口的静态类型决定了哪个方法可以通过接口变量调用，即便内部实际的值可能有一个更大的方法集。</p>
<p>接下来，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>{}</div><div class="line">empty = w</div></pre></td></tr></table></figure>

<p>而空接口值 <em>e</em> 也将包含同样的 <em>(tty, </em>os.File)*。这很方便：空接口可以保存任何值同时保留关于那个值的所有信息。</p>
<p>（这里无需类型断言，因为 <em>w</em> 是肯定满足空接口的。在这个例子中，将一个值从 <em>Reader</em> 变为 <em>Writer</em>，由于 <em>Writer</em> 的方法不是 <em>Reader</em> 的子集，所以就必须明确使用类型断言。）</p>
<p>一个很重要的细节是接口内部的对总是 (value, 实际类型) 的格式，而不会有 (value, 接口类型) 的格式。接口不能保存接口值。</p>
<p>现在准备好来反射了。</p>
<h3 id="反射的第一条规则">反射的第一条规则</h3>
<p><strong>1 从接口值到反射对象的反射</strong></p>
<p>在基本的层面上，反射只是一个检查存储在接口变量中的类型和值的算法。从头说起，在 reflect 包中有两个类型需要了解：<code>Type</code> 和 <code>Value</code>。这两个类型使得可以访问接口变量的内容，还有两个简单的函数，<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>，从接口值中分别获取 <code>reflect.Type</code> 和 <code>reflect.Value</code>。（同样，从 <code>reflect.Value</code> 也很容易能够获得 <code>reflect.Type</code>，不过这里让 <code>Value</code> 和 <code>Type</code> 在概念上分离了。）</p>
<p>从 <code>TypeOf</code> 开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">    fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个程序打印</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>: <span class="typename">float64</span></div></pre></td></tr></table></figure>

<p>接口在哪里呢，读者可能会对此有疑虑，看起来程序传递了一个 <em>float64</em> 类型的变量 <em>x</em>，而不是一个接口值，到 <code>reflect.TypeOf</code>。但是，它确实就在那里：如同 <em>godoc</em> 报告的那样，<code>reflect.TypeOf</code> 的声明包含了空接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TypeOf returns the reflection Type of the value in the interface{}.</span></div><div class="line"><span class="keyword">func</span> TypeOf(i <span class="keyword">interface</span>{}) Type</div></pre></td></tr></table></figure>

<p>当调用 <em>reflect.TypeOf(x)</em> 的时候，<em>x</em> 首先存储于一个作为参数传递的空接口中；<em>reflect.TypeOf</em> 解包这个空接口来还原类型信息。<br><em>reflect.ValueOf</em> 函数，当然就是还原那个值（从这里开始将会略过那些概念示例，而聚焦于可执行的代码）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">fmt.Println(<span class="string">"value:"</span>, reflect.ValueOf(x))</div></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value: &lt;<span class="typename">float64</span> Value&gt;</div></pre></td></tr></table></figure>

<p><em>reflect.Type</em> 和 <em>reflect.Value</em> 都有许多方法用于检查和操作它们。一个重要的例子是 <em>Value</em> 有一个 <em>Type</em> 方法返回 <em>reflect.Value</em> 的 <em>Type</em>。另一个是 <em>Type</em> 和 <em>Value </em>都有 <em>Kind</em> 方法返回一个常量来表示类型：<em>Uint</em>、<em>Float64</em>、<em>Slice</em> 等等。同样 <em>Value</em> 有叫做 <em>Int</em> 和 <em>Float</em> 的方法可以获取存储在内部的值（跟 <em>int64</em> 和 <em>float64</em> 一样）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</div><div class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</div><div class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</div></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>: <span class="typename">float64</span></div><div class="line">kind is <span class="typename">float64</span>: <span class="constant">true</span></div><div class="line">value:<span class="number"> 3.4</span></div></pre></td></tr></table></figure>

<p>同时也有类似 <em>SetInt</em> 和 <em>SetFloat</em> 的方法，不过在使用它们之前需要理解可设置性，这部分的主题在下面的第三条规则中讨论。</p>
<p>反射库有着若干特性值得特别说明。首先，为了保持 API 的简洁，“获取者”和“设置者”用 <em>Value</em> 的最宽泛的类型来处理值：例如，<em>int64</em> 可用于所有带符号整数。也就是说 <em>Value</em> 的 <em>Int</em> 方法返回一个 <em>int64</em>，而 <em>SetInt</em> 值接受一个<em> int64</em>；所以可能必须转换到实际的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">uint8</span> = <span class="string">'x'</span></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())                            <span class="comment">// uint8.</span></div><div class="line">fmt.Println(<span class="string">"kind is uint8: "</span>, v.Kind() == reflect.Uint8) <span class="comment">// true.</span></div><div class="line">x = <span class="typename">uint8</span>(v.Uint())                                       <span class="comment">// v.Uint returns a uint64.</span></div></pre></td></tr></table></figure>

<p>第二个特性是反射对象的 <code>Kind</code> 描述了底层类型，而不是静态类型。如果一个反射对象包含了用户定义的整数类型的值，就像</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> x MyInt =<span class="number"> 7</span></div><div class="line">v := reflect.ValueOf(x)</div></pre></td></tr></table></figure>

<p><em>v</em> 的 <code>Kind</code> 仍然是 <em>reflect.Int</em>，尽管<em> x </em>的静态类型是 <em>MyInt</em>，而不是 <em>int</em>。换句话说，<code>Kind</code> 无法从 <em>MyInt</em> 中区分 <em>int</em>，而 <code>Type</code> 可以。</p>
<h3 id="反射的第二条规则">反射的第二条规则</h3>
<p><strong>2 从反射对象到接口值的反射</strong><br>如同物理中的反射，在 Go 中的反射也存在它自己的镜像。<br>从 <em>reflect.Value</em> 可以使用<em> Interface</em> 方法还原接口值；方法打包类型和值信息到接口表达中，并返回这个结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Interface returns v's value as an interface{}.</span></div><div class="line"><span class="keyword">func</span> (v Value) Interface() <span class="keyword">interface</span>{}</div></pre></td></tr></table></figure>

<p>因此可以这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y := v.Interface().(<span class="typename">float64</span>) <span class="comment">// y 将为类型 float64。</span></div><div class="line">fmt.Println(y)</div></pre></td></tr></table></figure>

<p>通过反射对象 <em>v</em> 可以打印 <em>float64</em> 的表达值。</p>
<p>然而，还可以做得更好。<em>fmt.Println，fmt.Printf</em> 和其他的打印方法都是以一个空接口值作为参数的，由 <em>fmt</em> 包在内部解包的方式就像之前的例子一样。因此正确的打印 <em>reflect.Value </em>内容的方法就是将 <em>Interface</em> 方法的结果传递给格式化打印：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(v.Interface())</div></pre></td></tr></table></figure>

<p>（为什么不是 <em>fmt.Println(v)</em>？因为 <em>v</em> 是一个 <em>reflect.Value</em>；这里希望是它保存的实际的值。）由于值是 <em>float64</em>，如果需要的话，甚至可以使用浮点格式化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Printf(<span class="string">"value is %7.1e\n"</span>, v.Interface())</div></pre></td></tr></table></figure>

<p>然后就得到这个</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.4e+00</div></pre></td></tr></table></figure>

<p>再次强调，对于 <em>v.Interface()</em> 无需类型断言其为 <em>float64</em>；空接口值在内部有实际值的类型信息，而 <em>Printf</em> 会发现它。</p>
<p>简单来说，<em>Interface</em> 方法是 <em>ValueOf</em> 函数的镜像，除了返回值总是静态类型 <em>interface{}</em>。</p>
<p>回顾：反射可以从接口值得到反射对象，也可以反过来。</p>
<h3 id="反射的第三条规则">反射的第三条规则</h3>
<p><strong>3 要想修改反射对象，其值必须可设置</strong><br>第三条规则是最为精细和迷惑的，但是如果从第一个规则开始，还是足以让人明白的。</p>
<p>这里有一些不能工作的代码，值得学习。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">v.SetFloat<span class="number">(7.1</span>) <span class="comment">// Error: will panic.</span></div></pre></td></tr></table></figure>

<p>如果运行这个代码，它报出神秘的 panic 消息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">panic: reflect.Value.SetFloat <span class="keyword">using</span> unaddressable <span class="keyword">value</span></div></pre></td></tr></table></figure>

<p>问题不在于值 <em>7.1</em> 不能地址化；在于 <em>v</em> 不可设置。设置性是反射值的一个属性，并不是所有的反射值有它。</p>
<p>值的 <code>CanSet</code> 方法提供了值的设置性；在这个例子中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">fmt.Println(<span class="string">"settability of v:"</span> , v.CanSet())</div></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">settability <span class="keyword">of</span> v: <span class="literal">false</span></div></pre></td></tr></table></figure>

<p>对不可设置值调用 <code>Set</code> 方法会有错误。但是什么是设置性？<br>设置性有一点点像地址化，但是更严格。这是用于创建反射对象的时候，能够修改实际存储的属性。设置性用于决定反射对象是否保存原始项目。当这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">v := reflect.ValueOf(x)</div></pre></td></tr></table></figure>

<p>就传递了一个 <em>x</em> 的副本到 <em>reflect.ValueOf</em>，所以接口值作为 <em>reflect.ValueOf</em> 参数创建了 <em>x</em> 的副本，而不是 <em>x</em> 本身。因此，如果语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">v.SetFloat<span class="number">(7.1</span>)</div></pre></td></tr></table></figure>

<p>允许执行，虽然 <em> v</em>  看起来是从 <em> x </em> 创建的，它也无法更新 <em> x</em> 。反之，如果在反射值内部允许更新 <em> x </em> 的副本，那么 <em> x</em>  本身不会收到影响。这会造成混淆，并且毫无意义，因此这是非法的，而设置性是用于解决这个问题的属性。<br>这很神奇？其实不是。这实际上是一个常见的非同寻常的情况。考虑传递 x 到函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(x)</div></pre></td></tr></table></figure>

<p>由于传递的是 x 的值的副本，而不是 x 本身，所以并不期望 f 可以修改 x。如果想要 f 直接修改 x，必须向函数传递 x 的地址（也就是，指向 x 的指针）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(&x)</div></pre></td></tr></table></figure>

<p>这是清晰且熟悉的，而反射通过同样的途径工作。如果希望通过反射来修改 <em>x</em>，必须向反射库提供一个希望修改的值的指针。</p>
<p>来试试吧。首先像平常那样初始化 <em>x</em>，然后创建指向它的反射值，叫做 <em>p</em>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">p := reflect.ValueOf(&x) <span class="comment">// Note: take the address of x.</span></div><div class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</div><div class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</div></pre></td></tr></table></figure>


<p>这样输出为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> of p: *<span class="typename">float64</span></div><div class="line">settability of p: <span class="constant">false</span></div></pre></td></tr></table></figure>

<p>反射对象<em> p</em> 并不是可设置的，但是我们不是想设置 <em>p</em>，而是 <em>p。为了获得 </em>p<em> 指向的内容，调用值上的 <code>Elem</code> 方法，从指针间接指向，然后保存反射值的结果叫做 </em>v*：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v := p.Elem()</div><div class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</div></pre></td></tr></table></figure>

<p>现在 v 是可设置的反射对象，如同示例的输出，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">settability of v: <span class="constant">true</span></div></pre></td></tr></table></figure>

<p>而由于它来自 <em>x</em>，最终可以使用 <em>v.SetFloat</em> 来修改 <em>x </em>的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v.SetFloat<span class="number">(7.1</span>)</div><div class="line">fmt.Println(v.Interface())</div><div class="line">fmt.Println(x)</div></pre></td></tr></table></figure>

<p>得到期望的输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">7.1</div><div class="line">7.1</div></pre></td></tr></table></figure>

<p>反射可能很难理解，但是语言做了它应该做的，尽管底层的实现被反射的 <em>Type</em> 和 <em>Value</em> 隐藏了。务必记得反射值需要某些内容的地址来修改它指向的东西。</p>
<h3 id="结构体">结构体</h3>
<p>在之前的例子中<em>v</em> 本身不是指针，它只是从一个指针中获取的。这种情况更加常见的是当使用反射修改结构体的字段的时候。也就是当有结构体的地址的时候，可以修改它的字段。</p>
<p>这里有一个分析结构值 <em>t</em> 的简单例子。由于希望等下对结构体进行修改，所以从它的地址创建了反射对象。设置了 <em>typeOfT</em> 为其类型，然后用直接的方法调用来遍历其字段（参考 <a href="http://golang.org/pkg/reflect/" target="_blank" rel="external">reflect 包</a>了解更多信息）。注意从结构类型中解析了字段名字，但是字段本身是原始的 <em>reflect.Value</em> 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</div><div class="line">    A <span class="typename">int</span></div><div class="line">    B <span class="typename">string</span></div><div class="line">}</div><div class="line">t := T<span class="number">{23</span>, <span class="string">"skidoo"</span>}</div><div class="line">s := reflect.ValueOf(&t).Elem()</div><div class="line">typeOfT := s.Type()</div><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; s.NumField(); i++ {</div><div class="line">    f := s.Field(i)</div><div class="line">    fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</div><div class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个程序的输出是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">0</span>: <span class="string">A int = 23</span></div><div class="line"><span class="attribute">1</span>: <span class="string">B string = skidoo</span></div></pre></td></tr></table></figure>

<p>这里还有一个关于设置性的要点：<em>T</em> 的字段名要大写（可导出），因为只有可导出的字段是可设置的。</p>
<p>由于 <em>s</em> 包含可设置的反射对象，所以可以修改结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s.Field<span class="number">(0</span>).SetInt<span class="number">(77</span>)</div><div class="line">s.Field<span class="number">(1</span>).SetString(<span class="string">"Sunset Strip"</span>)</div><div class="line">fmt.Println(<span class="string">"t is now"</span>, t)</div></pre></td></tr></table></figure>

<p>这里是结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t <span class="keyword">is</span> <span class="keyword">now</span> {77 Sunset Strip}</div></pre></td></tr></table></figure>

<p>如果修改程序使得 <em>s</em> 创建于 <em>t</em>，而不是 <em>&amp;t</em>，调用 <code>SetInt</code> 和 <code>SetString</code> 会失败，因为 <em>t</em> 的字段不可设置。</p>
<h3 id="总结">总结</h3>
<p>再次提示，反射的规则如下：</p>
<ul>
<li>从接口值到反射对象的反射。</li>
<li>从反射对象到接口值的反射。</li>
<li>为了修改反射对象，其值必须可设置。</li>
</ul>
<p>一旦理解了 Go 中的反射的这些规则，就会变得容易使用了，虽然它仍然很微妙。这是一个强大的工具，除非真得有必要，否则应当避免使用或小心使用。</p>
<p>还有大量的关于反射的内容没有涉及到——channel 上的发送和接收、分配内存、使用 slice 和 map、调用方法和函数——但是这篇文章已经够长了。这些话题将会在以后的文章中逐一讲解。</p>
<p><em>Rob Pike 撰写，2011年9月</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://blog.golang.org/laws-of-reflection" target="_blank" rel="external">The Laws of Reflection</a><br>翻译: <a href="http://mikespook.com/2011/09/%E5%8F%8D%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99/" target="_blank" rel="external">反射的规则</a> by <a href="http://mikespook.com/author/mikespook/" target="_blank" rel="external">mikespook</a> 转载时略作修改</p>
<h3 id="反射的规则">反射的规则</h3>
<p>在运行时反射是程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。它同时也是造成混淆的重要来源。</p>
<p>在这篇文章中将试图明确解释在 Go 中的反射是如何工作的。每个语言的反射模型都不同（同时许多语言根本不支持反射）。不过这篇文章是关于 Go 的，因此接下来的内容“反射”这一词表示“在 Go 中的反射”。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[goreq: 极简单的流式golang http client]]></title>
    <link href="http://colobu.com/2015/09/21/goreq-A-simplified-golang-http-client/"/>
    <id>http://colobu.com/2015/09/21/goreq-A-simplified-golang-http-client/</id>
    <published>2015-09-21T06:27:09.000Z</published>
    <updated>2015-09-21T08:49:25.503Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/smallnest/goreq" target="_blank" rel="external">goreq</a>是一个极其简单的流式golang http client。它是我寻找类似Java OKHttp库的golang http client库时创建的。<br>最原始的代码fork自<a href="https://github.com/parnurzeal/gorequest" target="_blank" rel="external">gorequest</a>，它实现了Node.js库<a href="https://github.com/visionmedia/superagent" target="_blank" rel="external">SuperAgent</a>类似的功能。但是gorequest有一些bug没有fix，用户也提出了一些新的特性没有支持。<br>我重构了代码，更正了一些bug，增加了新的特性，尤其是POST BODY现在可以支持任意类型， 不再局限于json或者form字符串格式。 因为改动比较大，不好提交pull requests,干脆创建了一个新的轮子。这就是这个项目的最初目的。</p>
<p>比如下面调用baidu API根据IP地址获取地理信息的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">headers := <span class="string">`{"User-Agent":"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0",</span></div><div class="line">		"Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",</div><div class="line">		"Referer":"http://developer.baidu.com/map/index.php?title=webapi/ip-api"}`</div><div class="line">	</div><div class="line">_, body, _ := goreq.New().SetHeaders(headers).Get(<span class="string">"http://api.map.baidu.com/location/ip?ak=E4805d16520de693a3fe707cdc962045&ip=202.198.16.3&coor=bd09ll"</span>).End()</div></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="支持的HTTP_METHOD">支持的HTTP METHOD</h3>
<p>支持 <strong>GET, POST, HEAD, PUT, DELETE, PATCH</strong> 等http method,而且都想HTTP GET一样简单， 比如下面的HTTP PUT:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_, body, _ := goreq.New().Put(<span class="string">"http://httpbin.org/put"</span>).SendRawString(<span class="string">"hello world"</span>).End()</div><div class="line"><span class="built_in">println</span>(body)</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">args</span>": <span class="value">{}</span>,</div><div class="line">  "<span class="attribute">data</span>": <span class="value"><span class="string">"hello world"</span></span>,</div><div class="line">  "<span class="attribute">files</span>": <span class="value">{}</span>,</div><div class="line">  "<span class="attribute">form</span>": <span class="value">{}</span>,</div><div class="line">  "<span class="attribute">headers</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">Accept-Encoding</span>": <span class="value"><span class="string">"gzip"</span></span>,</div><div class="line">    "<span class="attribute">Content-Length</span>": <span class="value"><span class="string">"11"</span></span>,</div><div class="line">    "<span class="attribute">Content-Type</span>": <span class="value"><span class="string">"text/plain"</span></span>,</div><div class="line">    "<span class="attribute">Host</span>": <span class="value"><span class="string">"httpbin.org"</span></span>,</div><div class="line">    "<span class="attribute">User-Agent</span>": <span class="value"><span class="string">"Go-http-client/1.1"</span></span></div><div class="line">  },</div><div class="line">  "<span class="attribute">json</span>": <span class="value"><span class="literal">null</span></span>,</div><div class="line">  "<span class="attribute">origin</span>": <span class="value"><span class="string">"117.121.34.13"</span></span>,</div><div class="line">  "<span class="attribute">url</span>": <span class="value"><span class="string">"http://httpbin.org/put"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Request_Body及Header">Request Body及Header</h3>
<p>发送一个JSON格式的内容也很简单， 你可以传入一个struct, GoReq自动将它转为一个JSON字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_, body, _ := goreq.New().Put(<span class="string">"http://httpbin.org/put"</span>).SendMapString(<span class="string">"name=Baymax&password=12345678"</span>).End()</div></pre></td></tr></table></figure>

<p>注意在这种情况下(设置了body，未设置Content-Type)， Content-Type为<code>application/json</code>。<br>甚至你可以传递一个查询字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_, body, _ := goreq.New().Put(<span class="string">"http://httpbin.org/put"</span>).ContentType(<span class="string">"json"</span>).SendMapString(<span class="string">"name=Baymax&password=12345678"</span>).End()</div></pre></td></tr></table></figure>

<p>注意在这种情况下(设置了body，未设置Content-Type)， Content-Type为<code>application/x-www-form-urlencoded</code>。所以这里显示地设置为&quot;application/json&quot;</p>
<h3 id="Proxy和超时">Proxy和超时</h3>
<p>可以为读写设置一个超时时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_, _, err := goreq.New().Get(<span class="string">"http://httpbin.org//delay/100"</span>).Timeout<span class="number">(10</span> * time.Second).End()</div><div class="line"><span class="built_in">println</span>(err<span class="number">[0</span>].Error())</div></pre></td></tr></table></figure>

<h3 id="Basic_Auth">Basic Auth</h3>
<p>GoReq支持Basic Auth身份验证:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_, body, _ := goreq.New().Get(<span class="string">"http://httpbin.org/basic-auth/Baymax/12345678"</span>).SetBasicAuth(<span class="string">"Baymax"</span>, <span class="string">"12345678"</span>).End()</div></pre></td></tr></table></figure>

<p>更多的例子和文档请查看 <a href="http://godoc.org/github.com/smallnest/goreq" target="_blank" rel="external">godoc</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/smallnest/goreq" target="_blank" rel="external">goreq</a>是一个极其简单的流式golang http client。它是我寻找类似Java OKHttp库的golang http client库时创建的。<br>最原始的代码fork自<a href="https://github.com/parnurzeal/gorequest" target="_blank" rel="external">gorequest</a>，它实现了Node.js库<a href="https://github.com/visionmedia/superagent" target="_blank" rel="external">SuperAgent</a>类似的功能。但是gorequest有一些bug没有fix，用户也提出了一些新的特性没有支持。<br>我重构了代码，更正了一些bug，增加了新的特性，尤其是POST BODY现在可以支持任意类型， 不再局限于json或者form字符串格式。 因为改动比较大，不好提交pull requests,干脆创建了一个新的轮子。这就是这个项目的最初目的。</p>
<p>比如下面调用baidu API根据IP地址获取地理信息的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">headers := <span class="string">`{"User-Agent":"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0",</span></div><div class="line">		"Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",</div><div class="line">		"Referer":"http://developer.baidu.com/map/index.php?title=webapi/ip-api"}`</div><div class="line">	</div><div class="line">_, body, _ := goreq.New().SetHeaders(headers).Get(<span class="string">"http://api.map.baidu.com/location/ip?ak=E4805d16520de693a3fe707cdc962045&ip=202.198.16.3&coor=bd09ll"</span>).End()</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
